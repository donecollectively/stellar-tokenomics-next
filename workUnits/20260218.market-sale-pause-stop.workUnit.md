# Work Unit: market-sale-pause-stop

**Title**: Add Paused state and Stop/Resume activities to MarketSale lifecycle
**Created**: 2026-02-18
**Source**: ad-hoc

> **Required context**: Load [work-planner.SKILL.md](../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder (osiris), Offchain Coder (freya), Stellar Testing (tessa)
**ARCH Items**: N/A — no architecture docs established in this project; scope governed by REQT items below
**REQT Items**:
- REQT/46gmm6198w (Sale Lifecycle) — state machine being extended
- REQT/e7dqc25smj (Paused State) — new state
- REQT/yq3genxzkf (Retired State) — new state
- REQT/fx7m3y1ctf (Active → Paused) — new transition
- REQT/3h96mdmn5k (Paused → Active) — new transition
- REQT/hcagxtdt35 (Paused → Retired) — new transition
- REQT/7j07yjvpbh (No Direct Active → Retired) — illegal transition guard
- REQT/jdepn901ag (No Selling While Paused) — illegal transition guard
- REQT/w0hvrt4xx8 (No State Regression from Retired) — illegal transition guard
- REQT/a1c1x495x6 (mustBePaused Helper) — new helper
- REQT/1whgp2m8jq (Active State) — updated for Resuming entry path
- REQT/w6e5qsfxq1 (VXF Validation on Transitions) — updated for paused/resume
- REQT/6z88fg6j2s (Paused Update Validates VXF) — new
- REQT/jkbaba8n7n (Resuming Validates VXF) — new
- REQT/eqd2j44phf (Settings Editability While Paused) — new
- REQT/b731sye0fz (Settings Bounds When Paused) — new
- REQT/05fzh7rd1q (Paused Sale Management) — new area: Stopping, Resuming, UpdatingPausedSale
- REQT/03ff0mfddc (Stopping Activity) — new
- REQT/qh3qkk8f92 (Resuming Activity) — new
- REQT/fkww59zyt3 (General Validation on Resume) — new, defense-in-depth
- REQT/60azhtn9dy (Non-Editable Fields Unchanged on Resume) — new, defense-in-depth
- REQT/b30wn4bdw2 (UpdatingPausedSale Activity) — new
- REQT/xygjysee4h (Frozen Fields While Paused) — new
- REQT/d1967hd11e (Editable Fields While Paused) — new
- REQT/h6wqgc7fat (Sale Retirement) — new area
- REQT/6kg1f7h500 (Retiring Activity) — new
- REQT/dtpwzjqn9p (Retiring UTxO Value Unchanged) — new

## Problem / Context

The MarketSale state machine currently supports: `Pending → Active → (selling) → Retired/SoldOut`. There is no way to **pause** an active sale — the only option is `Retiring`, which is a terminal state (stubbed, unimplemented).

A `Paused` state is needed so that:
- An active sale can be temporarily stopped (e.g., to adjust pricing, fix configuration, respond to market conditions)
- While paused, sale details can be modified (similar to how `UpdatingPendingSale` works for Pending sales)
- The sale can then be re-launched without needing to create a new sale record, burn tokens, and re-deposit

This is distinct from `Retiring`, which is permanent and involves token withdrawal/burning.

### State Machine Change

```
Current:   Pending → Active → Retired/SoldOut
                                 ↑ (stubbed)

Proposed:  Pending → Active ⇄ Paused → Retired
           (must Stop before Retiring — Paused is the deliberation state)
```

### Technical Analysis (from Offchain Coder)

The existing `Activating` activity **cannot** be reused for `Paused → Active` because:
1. On-chain policy (`MarketSalePolicy.hl:399`) hard-gates on `prevState == Pending`
2. `validateActivating()` calls `validateDetailsWhenPending()` which asserts zero nested/retired threads — invalid for a previously-active sale
3. Activating assumes tokens are being deposited; resuming assumes they're already present

Therefore, a **separate `Resuming` spending activity** is required.

## Focus Files

### On-chain (osiris)
- `src/MarketSale/MarketSaleData.hl` — `MarketSaleState` enum, `OtherSaleStateV1`, validation functions
- `src/MarketSale/MarketSalePolicy.hl` — `SpendingActivity` enum, activity validation in `additionalDelegateValidation`

### Off-chain (freya)
- `src/MarketSale/MarketSaleController.ts` — transaction builders, `requirements()`, `beforeUpdate()`
- `src/MarketSale/MarketSaleDataWrapper.ts` — data wrapper (may need Paused-aware logic)

### Tests (tessa)
- `src/MarketSale/tests/MarketSale.test.ts` — existing lifecycle tests
- `src/MarketSale/tests/MarketSaleTestHelper.ts` — test helpers

### Type info (build artifacts, affected by on-chain changes)
- `src/MarketSale/MarketSale.typeInfo.d.ts`
- `src/MarketSale/MarketSale.bridge.ts`

## Plan / Guidance

### Phase 1: On-chain (osiris)

1. **Add `Paused` state** to `MarketSaleState` enum. Currently: `Pending`, `Active`, `Retired`, `SoldOut`. Add `Paused` — consider enum position carefully for backward compatibility.

   **⚠️ Enum position matters**: Adding `Paused` changes the CBOR encoding of subsequent variants. Since `Retired` and `SoldOut` are not yet used on-chain (both stubbed), this is safe now but must be done before any `Retired`/`SoldOut` data exists on-chain.

2. **Add `mustBePaused` helper** to `OtherSaleStateV1` (mirrors `mustBePending`/`mustBeActive`).

3. **Add `Stopping` spending activity** to `SpendingActivity` enum:
   ```
   Stopping { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Active`
   - Next state must be `Paused`
   - Gov authority required
   - All datum fields must be unchanged (state field excepted)
   - UTxO token value must not change

4. **Add `Resuming` spending activity** to `SpendingActivity` enum:
   ```
   Resuming { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Paused`
   - Next state must be `Active`
   - Gov authority required
   - Tokens in UTxO must still match `saleLotAssets * totalSaleLots`
   - VxfDestination fields must validate
   - All non-editable fields unchanged (saleAssets, startAt, progressDetails, threadInfo, salePace, id, type) — only state transitions
   - Record must pass `validate()` — defense-in-depth for datum integrity when re-entering Active

5. **Add `UpdatingPausedSale` spending activity** (separate from `UpdatingPendingSale`):
   ```
   UpdatingPausedSale { id: ByteArray }
   ```
   Validation per the frozen/editable field inventory in Advisory Notes:
   - State must remain Paused (in and out)
   - `salePace` must equal previous (carry forward)
   - All progress details frozen (`next == prev` for each field)
   - `saleAssets` entire struct frozen (`next == prev`)
   - `startAt` frozen
   - `threadInfo` frozen by equality (no structural re-validation)
   - UTxO token value must not change
   - Editable: `name`, `settings` (with bounds validation), `vxfTokensTo`, `vxfFundsTo` (validate if present)

6. **Add `validateDetailsWhenPaused`** to `SaleProgressDetailsV1`:
   - All four fields must equal previous (`lotsSold`, `lastPurchaseAt`, `prevPurchaseAt`, `lotCount`)

7. **Wire up `Retiring`** (currently stubbed) for `Paused → Retired` transition only:
   ```
   Retiring { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Paused`
   - Next state must be `Retired`
   - Gov authority required
   - All datum fields must be unchanged (state field excepted) — same structural pattern as Stopping
   - UTxO token value must not change — tokens stay locked, disposed of later by `CleanupRetired` (FUTURE)

### Phase 2: Off-chain (freya)

1. **`mkTxnStopMarketSale`** — builds the Stop transaction (Active → Paused)
2. **`mkTxnResumeMarketSale`** — builds the Resume transaction (Paused → Active); no automatic pricing adjustments (see Advisory Notes)
3. **`mkTxnRetireMarketSale`** — builds the Retire transaction (Paused → Retired)
4. **UpdatingPausedSale off-chain path** — no dedicated convenience method needed. Use the generic `mkTxnUpdateRecord` + `UpdatingPausedSale` activity redeemer (same pattern as the existing `updatePendingMarketSale` test helper uses `mkTxnUpdateRecord` + `UpdatingPendingSale`). The test helper should provide an `updatePausedMarketSale` method mirroring `updatePendingMarketSale`.
5. **Update `beforeUpdate()`** — currently special-cases Active state (passthrough) and Pending (fixups). Add an explicit Paused branch that returns `updated` unchanged with a comment explaining why: all progress details are frozen while Paused, so no fixups are needed. Do NOT rely on implicit fall-through — the design intent must be visible in the code.
6. **Update `findMarketSales()`** — add `paused?: boolean` filter flag (currently only has `pending`, `active`, `retired`)
7. **Update `requirements()`** — add requirement entries for the new activities
8. **Pre-flight validation** — verify state is Active before Stop, Paused before Resume/Edit/Retire

### Phase 3: Tests (tessa)

1. **Stop activity tests**:
   - Stops an Active sale → state becomes Paused
   - Can't stop a Pending sale
   - Can't stop an already-Paused sale
   - Requires gov authority to stop
   - All datum fields unchanged (except state)
   - UTxO token value unchanged
   - Can't sell tokens while Paused

2. **Resume activity tests**:
   - Resumes a Paused sale → state becomes Active
   - Can't resume a Pending or Active sale
   - Tokens must still be present (match saleLotAssets × totalSaleLots)
   - Requires gov authority
   - VxfDestination fields must validate
   - After resume, selling works normally

3. **UpdatingPausedSale tests**:
   - Can update `name` while Paused
   - Can update `settings` (pricing parameters) while Paused, with bounds validation
   - Can update `vxfTokensTo` and `vxfFundsTo` while Paused, with validation-if-present
   - Can't change state during edit
   - Can't change `salePace` (must carry forward)
   - Can't change progress details (all four fields frozen)
   - Can't change `saleAssets` (entire struct frozen)
   - Can't change `startAt`
   - Can't change `threadInfo`
   - Can't change UTxO token value
   - Requires gov authority

4. **Retiring tests** (from Paused):
   - Retires a Paused sale → state becomes Retired
   - Can't retire from Active (must Stop first)
   - Can't retire from Pending
   - Requires gov authority
   - All datum fields unchanged except state
   - UTxO token value unchanged (tokens stay locked)

## Acceptance Criteria

- [ ] `MarketSaleState` enum includes `Paused`
- [ ] `mustBePaused` helper exists on `OtherSaleStateV1`
- [ ] `Stopping` spending activity transitions Active → Paused with gov authority; all other fields unchanged
- [ ] `Resuming` spending activity transitions Paused → Active with gov authority; validates deposited tokens and VxfDestination
- [ ] `UpdatingPausedSale` spending activity enforces frozen/editable field inventory per Advisory Notes
- [ ] `validateDetailsWhenPaused` on `SaleProgressDetailsV1` enforces all four fields frozen
- [ ] `Retiring` spending activity transitions Paused → Retired with gov authority; all fields except state unchanged; UTxO value unchanged (tokens stay locked for future CleanupRetired)
- [ ] Selling is rejected when state is Paused
- [ ] Frozen fields: state (except via dedicated activities), salePace, all progressDetails, entire saleAssets struct, startAt, threadInfo, id, type, UTxO token value
- [ ] Editable fields: name, settings (with bounds), vxfTokensTo (validate if present), vxfFundsTo (validate if present)
- [ ] Off-chain transaction builders exist for Stop, Resume, UpdatingPausedSale, and Retire
- [ ] Off-chain pre-flight validation catches wrong-state attempts
- [ ] Tests cover happy paths and rejection cases for all four activities
- [ ] `requirements()` in MarketSaleController updated
- [ ] Once Retired, no transition back to any other state is permitted (REQT/w0hvrt4xx8)
- [ ] Resuming calls `validate()` for defense-in-depth datum integrity (REQT/fkww59zyt3)
- [ ] Resuming verifies all non-editable fields unchanged from input to output (REQT/60azhtn9dy)
- [ ] Front-end advisory: Stop action MUST display warning — "Dynamic price discounts accumulate while paused — Keep the pause duration short!"

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

## Advisory Notes

### Pre-Work Analysis (2026-02-18)

#### Offchain Coder — Activating reuse analysis

The existing `Activating` activity cannot serve double duty for `Paused → Active`:
- Hard-coded `mustBePending` checks in both policy and data validation
- `validateDetailsWhenPending()` asserts zero thread counters (invalid post-activity)
- Semantic mismatch: Activating deposits tokens; Resuming confirms they're already present

**Conclusion**: Separate `Resuming` activity required.

#### Design decision: UpdatingPausedSale is a separate activity

A Paused sale has `lotsSold > 0` and non-initial progress details, so `validateDetailsWhenPending()` constraints (e.g., "lotsSold must be 0", "prevPurchaseAt must equal startAt") don't apply. A separate `UpdatingPausedSale` activity is required with its own validation path.

#### Design decision: Retiring transitions from Paused only

`Retiring` (currently stubbed) will be wired to transition from `Paused → Retired`. This makes Paused the deliberation state: stop selling, then decide whether to resume or wind down. Direct `Active → Retired` is not supported — you must Stop first.

#### UpdatingPausedSale — Validation Design (field-by-field analysis)

Each check from `validateUpdatePendingSale` was evaluated for applicability to the Paused state. The analysis was conducted one consideration at a time with stakeholder review of each decision.

##### Frozen vs. Editable Field Inventory

**Frozen (read-only) fields:**

| Field | Path | Reason |
|-------|------|--------|
| `state` | `saleState.state` | Must remain Paused; state changes use Stop/Resume/Retire |
| `salePace` | `saleState.salePace` | Preserves real market dynamics from prior activity |
| `lotsSold` | `saleState.progressDetails.lotsSold` | Historical fact |
| `lastPurchaseAt` | `saleState.progressDetails.lastPurchaseAt` | Historical fact |
| `prevPurchaseAt` | `saleState.progressDetails.prevPurchaseAt` | Historical fact |
| `lotCount` | `saleState.progressDetails.lotCount` | Frozen; MAY be relaxed in future versions if replaced with sufficient constraints to retain other points of integrity |
| `saleAssets` (entire struct) | `details.V1.saleAssets` | Entangled with deposited tokens and purchase history |
| ↳ `saleLotAssets` | | — |
| ↳ `totalSaleLots` | | — |
| ↳ `singleBuyMaxLots` | | — |
| ↳ `primaryAssetMph` | | — |
| ↳ `primaryAssetName` | | — |
| ↳ `primaryAssetTargetCount` | | — |
| `startAt` | `fixedSaleDetails.startAt` | Time anchor for all pacing/pricing calculations (see pricing impact analysis below) |
| `threadInfo` (entire struct) | `details.V1.threadInfo` | Frozen by equality; structural re-validation not needed (equality is strictly stronger) |
| `id` | top-level | Identity |
| `type` | top-level | Identity |
| UTxO token value | (on-chain value) | No token movement during edits |

**Editable fields:**

| Field | Path | Validation |
|-------|------|------------|
| `name` | top-level | Must be at least 10 characters (existing `validate()` check) |
| `settings` | `fixedSaleDetails.settings` | Bounds validation (sane ranges for all pricing parameters) |
| ↳ `targetPrice` | | — |
| ↳ `targetedSellingTime` | | — |
| ↳ `minPrice` | | — |
| ↳ `maxPrice` | | — |
| ↳ all pace/discount knobs | | — |
| `vxfTokensTo` | `fixedSaleDetails.vxfTokensTo` | Validate if present |
| `vxfFundsTo` | `fixedSaleDetails.vxfFundsTo` | Validate if present |

##### Validation check mapping (UpdatingPendingSale → UpdatingPausedSale)

| # | UpdatingPendingSale Check | UpdatingPausedSale Adaptation |
|---|---------------------------|-------------------------------|
| 1 | `prevState.mustBePending` / `nextState.mustBePending` | `prevState.mustBePaused` / `nextState.mustBePaused` |
| 2 | `salePace == 1.0` | `next.salePace == prev.salePace` (carry forward, don't reset) |
| 3 | `progressDetails.validateDetailsWhenPending()` (lotsSold==0, timestamps==startAt, lotCount==totalSaleLots) | New `validateDetailsWhenPaused()`: all four fields frozen (`next == prev` for each) |
| 4 | `threadInfo == prev.threadInfo` + `validateDetailsWhenPending()` (zero counters) | `threadInfo == prev.threadInfo` only; drop structural re-validation |
| 5 | `inputAssets == outputAssets` (UTxO tokens unchanged) | Identical |
| 6 | Primary asset identity change logic (complex branching) | Not allowed: `next.primaryAssetMph == prev`, `next.primaryAssetName == prev` (via `saleAssets` frozen) |
| 7 | `primaryAssetTargetCount == totalSaleLots × lotSize` consistency | Not needed (entire `saleAssets` struct frozen) |
| 8 | VxfDestination validation if present | Identical |
| 9 | `settings.validateDetailsWhenPending()` (bounds checks) | Identical (function name misleading — checks are state-independent sane bounds) |

#### Design decision: No automatic pricing adjustments on Resume

Pausing a sale causes two pricing effects when it resumes:

1. **Progress pricing**: `elapsedSaleHours` includes pause duration, making `overallPace` drop → deeper progress discounts. **Mitigation**: admin can manually extend `targetedSellingTime` via `UpdatingPausedSale`.

2. **Dynamic pricing**: `hoursSinceLastPurchase` includes pause duration, crashing `inferredPace` and triggering heavy idle-decay → first buyers after resume get prices near `minPrice`. **No mitigation** other than keeping pauses short.

Automatic adjustments were considered (auto-extending `targetedSellingTime`, shifting `lastPurchaseAt`/`prevPurchaseAt` forward on Resume, `Paused { pausedAt }` data variant) but scoped out as future enhancement. The partial fix (auto-extend only) was rejected — it adds on-chain complexity without solving the more visible dynamic pace drop.

**Front-end requirement**: Before executing Stop, the UI MUST display a warning: **"Dynamic price discounts accumulate while paused — Keep the pause duration short!"**

**Future enhancement**: `Paused { pausedAt }` variant + automatic adjustment of `targetedSellingTime`, `lastPurchaseAt`, and `prevPurchaseAt` on Resume to fully neutralize pause duration effects on both pricing factors.

#### Design decision: Child chunks must not sell while root is Paused

When chunk-splitting is implemented, child chunks MUST NOT sell while the root sale is in Paused state. Stopping the root effectively halts the entire sale across all chunks, without requiring each chunk to be stopped individually.

**Mechanism** (future, when splitting is implemented): `SellingTokens` validation on child chunks must require the root sale's UTxO as a reference input and verify the root's state is Active.

**Current status**: Splitting is fully stubbed — no child chunks exist. An IMPORTANT policy comment has been placed in `MarketSalePolicy.hl` at the `SellingTokens` handler to guide future implementation. No reqts docs exist to record this formally.

#### Pricing Impact Analysis: `startAt` and `targetedSellingTime` while Paused

`startAt` feeds directly into all pacing/pricing calculations via `elapsedSaleHours()`:
```
elapsedSaleHours = (purchaseTime - startAt) / HOUR
actualSellingPace = (lotsSold + lotsPurchased) / elapsedSaleHours
overallPace = actualSellingPace / targetSellingPace
```
where `targetSellingPace = lotCount / (targetedSellingTime in hours)`.

The `overallPace` drives the progress pricing discount (when pace < 1.0) and expansion (when > 1.0). Changing `startAt` while real purchase history exists would corrupt elapsed-time calculations; changing `targetedSellingTime` reframes the expected pace without altering history.

##### Representative scenarios

Using defaults: `targetPrice=1.0 ADA`, `minPrice=0.5`, `lotCount=1000`, `targetedSellingTime=108h (4.5d)`, `discountFloorPoint=0.2`, `discountWhenSlow=0.25`.

| Scenario | Sold | Elapsed | targetedSellingTime | overallPace | Progress Discount | Est. Price | Notes |
|----------|------|---------|---------------------|-------------|-------------------|------------|-------|
| **A1**: 5% left, on time | 950 | 108h | 108h | 0.951 | ~1.5% | ~0.97 | Healthy, near target |
| **A2**: 5% left, 2× time | 950 | 216h | 108h | 0.475 | ~16% | ~0.72 | Moderate discount + pace decay |
| **B1**: 50% left, on time | 500 | 108h | 108h | 0.501 | ~16% | ~0.72 | Significant slowdown |
| **B2**: 50% left, 2× time | 500 | 216h | 108h | 0.251 | ~23% | ~0.60 | Approaching floor zone |
| **B3**: 50% left, 4× time | 500 | 432h | 108h | 0.125 | 25% (max) | ~0.50 | Floored — hits minPrice |
| **C1**: 50% left, time extended | 500 | 108h | **216h** | 1.002 | 0% | ~1.00 | Extended time reframes pace — no discount |

##### Dynamic pace drop on resume

Separately from the progress pricing factor, the **dynamic pace** crashes on resume because `hoursSinceLastPurchase` includes the pause duration. This causes `inferredPace` to be near-zero and triggers heavy idle-decay weighting.

Using same defaults, `prevSalePace = 9.0 lots/hr`, first buyer purchases 1 lot after resume:

| Pause Duration | hoursSinceLastPurchase | inferredPace | nextDynamicPace | dynamicPriceFactor | Est. Price (with progress ~1.0) |
|---------------|----------------------|--------------|-----------------|--------------------|---------------------------------|
| 1h | 1.17h | 0.855 | 5.20 | 0.73 | ~0.73 |
| 6h | 6.17h | 0.162 | 2.33 | 0.54 | ~0.54 |
| 24h | 24.17h | 0.041 | 0.73 | 0.44 | 0.50 (floor) |
| 72h | 72.17h | 0.014 | 0.25 | 0.40 | 0.50 (floor) |

The dynamic pace recovers over subsequent purchases (each purchase pulls the weighted average back up), but the first 3-5 buyers after a long pause receive prices near `minPrice`.

This behavior is **accepted** and mitigated by:
- Front-end warning before stopping: "Dynamic price discounts accumulate while paused — Keep the pause duration short!"
- Admin can adjust pricing `settings` (e.g., increase `targetPrice`, reduce `dynaPaceIdleDecayRate`) while paused to partially compensate

##### Conclusions

- **`startAt` must be frozen while Paused** — it's the time anchor for all pacing math. Moving it forward would collapse `elapsedSaleHours` toward zero, spiking `actualSellingPace` to infinity and corrupting pricing.
- **`targetedSellingTime` is safely editable while Paused** — it reframes pace expectations without altering history. This is the designed governance lever for "we're not behind schedule, we just have a longer timeline."
- **Dynamic pace drops on resume** — first buyers get discounted prices proportional to pause duration. Accepted behavior; mitigated by keeping pauses short and front-end warning.
- **Pricing degrades gracefully** when time runs out — no cliff behavior. Progress discount maxes at 25% (`discountWhenSlow`), and `minPrice` (0.50) is the absolute floor.
- **No hard sale end date exists** — the sale sells until tokens are physically depleted from the UTxO. There is no on-chain `lotsSold + lotsPurchased <= lotCount` guard (the transaction simply fails when output value would go negative).

### Pre-Work Collaborative Review (2026-02-18)

#### Architect leads — findings

##### Finding F1: Retiring token handling underspecified — blocks implementation

**Observation**: The plan (Phase 1, item 7) says "Token withdrawal/burning details (to be further specified)" and REQT/je621r06f7 says "Retiring MUST handle withdrawal/burning of remaining tokens from the sale UTxO. Specific mechanism to be further specified during implementation." This is a requirements/plan ambiguity. The coder has three possible interpretations: (a) Retiring only transitions state, tokens stay in UTxO for future CleanupRetired; (b) Retiring withdraws tokens back to gov authority; (c) Retiring burns tokens. Without explicit scoping, the coder must guess. The existing `CleanupRetired` burning activity (FUTURE/REQT-kr9rseqaxf) suggests option (a) is intended, but the requirement text ("MUST handle") contradicts deferral.

> **Resolution**: Stakeholder confirmed option (a). REQT/je621r06f7 revised to state-transition-only: tokens remain locked, disposed later by CleanupRetired (FUTURE). New REQT/dtpwzjqn9p added for UTxO value unchanged. Plan item 7, acceptance criteria, and test plan updated. Retiring is now structurally parallel to Stopping (state change + unchanged datum + unchanged value).

##### Finding F2: Off-chain plan omits UpdatingPausedSale transaction builder

**Observation**: Phase 2 lists three new off-chain transaction builders: `mkTxnStopMarketSale`, `mkTxnResumeMarketSale`, `mkTxnRetireMarketSale`. But the acceptance criteria state "Off-chain transaction builders exist for Stop, Resume, **UpdatingPausedSale**, and Retire." The `UpdatingPausedSale` builder is missing from the plan. The existing `mkTxnUpdateRecord` + `UpdatingPausedSale` activity redeemer may suffice (mirroring how `updatePendingMarketSale` works in the test helper), but the plan should explicitly address this — either as a dedicated convenience method or as guidance for using the generic update path.

> **Resolution**: Added Phase 2 items 4-5. Item 4: UpdatingPausedSale uses generic `mkTxnUpdateRecord` + activity redeemer (no dedicated convenience method); test helper gets `updatePausedMarketSale`. Item 5: `beforeUpdate()` gets explicit Paused branch — passthrough with comment, no implicit fall-through.

#### Code Whisperer — sequenced follow-up

##### Finding F3: Shared validation duplication risk between validateUpdatePendingSale and new validateUpdatePausedSale

**Observation**: `validateUpdatePendingSale()` in MarketSaleData.hl is ~80 lines. The new `validateUpdatePausedSale()` will share substantial validation code: UTxO token value unchanged check, VxfDestination validation (if present), `validate()` call, and threadInfo equality. Without shared helpers, fixing a bug in one validator requires remembering to fix the other — classic shotgun surgery risk. The Advisory Notes' validation check mapping (items 1, 4, 5, 8, 9) shows shared checks. A `validateCommonUpdateChecks()` helper could extract the shared logic, with each state-specific validator calling it plus its own frozen/editable field checks.

#### Stellar Testing — sequenced follow-up

##### Finding F4: Resume test plan missing defense-in-depth coverage

**Observation**: The test plan for Resuming lists token presence, VxfDestination validation, gov authority, and post-resume selling. But two acceptance criteria with explicit defense-in-depth REQTs lack corresponding test cases: (a) REQT/fkww59zyt3 — "Resuming calls `validate()` for defense-in-depth datum integrity" — needs a negative test showing Resume rejects a record with invalid name (<10 chars) or other validate() failures; (b) REQT/60azhtn9dy — "Resuming verifies all non-editable fields unchanged from input to output" — needs negative tests showing Resume rejects mutations to frozen fields (saleAssets, startAt, progressDetails, threadInfo). Without these, the defense-in-depth validation could be omitted during implementation without test failure.

## Worker Report

*(to be appended after implementation)*
