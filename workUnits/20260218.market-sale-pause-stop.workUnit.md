# Work Unit: market-sale-pause-stop

**Title**: Add Paused state and Stop/Resume activities to MarketSale lifecycle
**Created**: 2026-02-18
**Source**: ad-hoc

> **Required context**: Load [work-planner.SKILL.md](../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder (osiris), Offchain Coder (freya), Stellar Testing (tessa)
**ARCH Items**: N/A — no architecture docs established in this project; scope governed by REQT items below
**REQT Items**:
- REQT/46gmm6198w (Sale Lifecycle) — state machine being extended
- REQT/e7dqc25smj (Paused State) — new state
- REQT/yq3genxzkf (Retired State) — new state
- REQT/fx7m3y1ctf (Active → Paused) — new transition
- REQT/3h96mdmn5k (Paused → Active) — new transition
- REQT/hcagxtdt35 (Paused → Retired) — new transition
- REQT/7j07yjvpbh (No Direct Active → Retired) — illegal transition guard
- REQT/jdepn901ag (No Selling While Paused) — illegal transition guard
- REQT/w0hvrt4xx8 (No State Regression from Retired) — illegal transition guard
- REQT/a1c1x495x6 (mustBePaused Helper) — new helper
- REQT/1whgp2m8jq (Active State) — updated for Resuming entry path
- REQT/w6e5qsfxq1 (VXF Validation on Transitions) — updated for paused/resume
- REQT/6z88fg6j2s (Paused Update Validates VXF) — new
- REQT/jkbaba8n7n (Resuming Validates VXF) — new
- REQT/eqd2j44phf (Settings Editability While Paused) — new
- REQT/b731sye0fz (Settings Bounds When Paused) — new
- REQT/05fzh7rd1q (Paused Sale Management) — new area: Stopping, Resuming, UpdatingPausedSale
- REQT/03ff0mfddc (Stopping Activity) — new
- REQT/qh3qkk8f92 (Resuming Activity) — new
- REQT/fkww59zyt3 (General Validation on Resume) — new, defense-in-depth
- REQT/60azhtn9dy (Non-Editable Fields Unchanged on Resume) — new, defense-in-depth
- REQT/b30wn4bdw2 (UpdatingPausedSale Activity) — new
- REQT/xygjysee4h (Frozen Fields While Paused) — new
- REQT/d1967hd11e (Editable Fields While Paused) — new
- REQT/h6wqgc7fat (Sale Retirement) — new area
- REQT/6kg1f7h500 (Retiring Activity) — new
- REQT/dtpwzjqn9p (Retiring UTxO Value Unchanged) — new

## Problem / Context

The MarketSale state machine currently supports: `Pending → Active → (selling) → Retired/SoldOut`. There is no way to **pause** an active sale — the only option is `Retiring`, which is a terminal state (stubbed, unimplemented).

A `Paused` state is needed so that:
- An active sale can be temporarily stopped (e.g., to adjust pricing, fix configuration, respond to market conditions)
- While paused, sale details can be modified (similar to how `UpdatingPendingSale` works for Pending sales)
- The sale can then be re-launched without needing to create a new sale record, burn tokens, and re-deposit

This is distinct from `Retiring`, which is permanent and involves token withdrawal/burning.

### State Machine Change

```
Current:   Pending → Active → Retired/SoldOut
                                 ↑ (stubbed)

Proposed:  Pending → Active ⇄ Paused → Retired
           (must Stop before Retiring — Paused is the deliberation state)
```

### Technical Analysis (from Offchain Coder)

The existing `Activating` activity **cannot** be reused for `Paused → Active` because:
1. On-chain policy (`MarketSalePolicy.hl:399`) hard-gates on `prevState == Pending`
2. `validateActivating()` calls `validateDetailsWhenPending()` which asserts zero nested/retired threads — invalid for a previously-active sale
3. Activating assumes tokens are being deposited; resuming assumes they're already present

Therefore, a **separate `Resuming` spending activity** is required.

## Focus Files

### On-chain (osiris)
- `src/MarketSale/MarketSaleData.hl` — `MarketSaleState` enum, `OtherSaleStateV1`, validation functions
- `src/MarketSale/MarketSalePolicy.hl` — `SpendingActivity` enum, activity validation in `additionalDelegateValidation`

### Off-chain (freya)
- `src/MarketSale/MarketSaleController.ts` — transaction builders, `requirements()`, `beforeUpdate()`
- `src/MarketSale/MarketSaleDataWrapper.ts` — data wrapper (may need Paused-aware logic)

### Tests (tessa)
- `src/MarketSale/tests/MarketSale.test.ts` — existing lifecycle tests
- `src/MarketSale/tests/MarketSaleTestHelper.ts` — test helpers

### Type info (build artifacts, affected by on-chain changes)
- `src/MarketSale/MarketSale.typeInfo.d.ts`
- `src/MarketSale/MarketSale.bridge.ts`

## Plan / Guidance

### Phase 1: On-chain (osiris)

1. **Add `Paused` state** to `MarketSaleState` enum. Currently: `Pending`, `Active`, `Retired`, `SoldOut`. Add `Paused` — consider enum position carefully for backward compatibility.

   **⚠️ Enum position matters**: Adding `Paused` changes the CBOR encoding of subsequent variants. Since `Retired` and `SoldOut` are not yet used on-chain (both stubbed), this is safe now but must be done before any `Retired`/`SoldOut` data exists on-chain.

2. **Add `mustBePaused` helper** to `OtherSaleStateV1` (mirrors `mustBePending`/`mustBeActive`).

3. **No new on-chain code for "no selling while Paused"** (REQT/jdepn901ag): The existing `SellingTokens` handler already calls `mustBeActive` on both previous and next state. Once `Paused` exists in the enum, `mustBeActive` rejects it automatically. Do NOT add a redundant Paused-specific guard. The test (`sell-while-paused-rejected`) confirms existing behavior against the new state.

4. **Add `Stopping` spending activity** to `SpendingActivity` enum:
   ```
   Stopping { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Active`
   - Next state must be `Paused`
   - Gov authority required
   - All datum fields must be unchanged (state field excepted)
   - UTxO token value must not change

5. **Add `Resuming` spending activity** to `SpendingActivity` enum:
   ```
   Resuming { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Paused`
   - Next state must be `Active`
   - Gov authority required
   - Tokens in UTxO must still match `saleLotAssets * totalSaleLots`
   - VxfDestination fields must validate
   - All non-editable fields unchanged (saleAssets, startAt, progressDetails, threadInfo, salePace, id, type) — only state transitions
   - Record must pass `validate()` — defense-in-depth for datum integrity when re-entering Active

6. **Extract `validateCommonUpdateChecks`** on `MarketSaleData` — a shared helper called by both `validateUpdatePendingSale` and the new `validateUpdatePausedSale`. Extracts the five invariant checks that apply to ANY sale update regardless of state:
   - UTxO token value unchanged (`inputAssets == outputAssets`)
   - ThreadInfo frozen (`prev == next`)
   - VxfDestination validation if present (both `vxfTokensTo` and `vxfFundsTo`)
   - General `validate()` call
   - Settings bounds validation (`validateDetailsWhenPending()` — state-independent despite its name)

   After extraction, `validateUpdatePendingSale` calls `validateCommonUpdateChecks` + its own state-specific checks (mustBePending, pace == 1.0, progress validateDetailsWhenPending, primary asset change logic). The new `validateUpdatePausedSale` calls the same shared helper + its own checks (mustBePaused, pace == prev, progress validateDetailsWhenPaused, saleAssets frozen). **This extraction MUST happen before adding the Paused validator** — refactor first, then extend.

7. **Add `UpdatingPausedSale` spending activity** (separate from `UpdatingPendingSale`):
   ```
   UpdatingPausedSale { id: ByteArray }
   ```
   Validation per the frozen/editable field inventory in Advisory Notes:
   - State must remain Paused (in and out)
   - `salePace` must equal previous (carry forward)
   - All progress details frozen (`next == prev` for each field)
   - `saleAssets` entire struct frozen (`next == prev`)
   - `startAt` frozen
   - `threadInfo` frozen by equality (no structural re-validation)
   - UTxO token value must not change
   - Editable: `name`, `settings` (with bounds validation), `vxfTokensTo`, `vxfFundsTo` (validate if present)

8. **Add `validateDetailsWhenPaused`** to `SaleProgressDetailsV1`:
   - All four fields must equal previous (`lotsSold`, `lastPurchaseAt`, `prevPurchaseAt`, `lotCount`)

9. **Wire up `Retiring`** (currently stubbed) for `Paused → Retired` transition only:
   ```
   Retiring { id: ByteArray }
   ```
   Validation:
   - Previous state must be `Paused`
   - Next state must be `Retired`
   - Gov authority required
   - All datum fields must be unchanged (state field excepted) — same structural pattern as Stopping
   - UTxO token value must not change — tokens stay locked, disposed of later by `CleanupRetired` (FUTURE)

### Phase 2: Off-chain (freya)

1. **`mkTxnStopMarketSale`** — builds the Stop transaction (Active → Paused)
2. **`mkTxnResumeMarketSale`** — builds the Resume transaction (Paused → Active); no automatic pricing adjustments (see Advisory Notes)
3. **`mkTxnRetireMarketSale`** — builds the Retire transaction (Paused → Retired)
4. **UpdatingPausedSale off-chain path** — no dedicated convenience method needed. Use the generic `mkTxnUpdateRecord` + `UpdatingPausedSale` activity redeemer (same pattern as the existing `updatePendingMarketSale` test helper uses `mkTxnUpdateRecord` + `UpdatingPendingSale`). The test helper should provide an `updatePausedMarketSale` method mirroring `updatePendingMarketSale`.
5. **Update `beforeUpdate()`** — currently special-cases Active state (passthrough) and Pending (fixups). Add an explicit Paused branch that returns `updated` unchanged with a comment explaining why: all progress details are frozen while Paused, so no fixups are needed. Do NOT rely on implicit fall-through — the design intent must be visible in the code.
6. ~~**Update `findMarketSales()`**~~ — **REMOVED by stakeholder override**: no specific use-case for a `paused` filter flag at this time. Paused is a transient admin state, not a query dimension. Can be added later if a use-case emerges.
7. **Update `requirements()`** — add requirement entries for the new activities
8. **Pre-flight validation** — verify state is Active before Stop, Paused before Resume/Edit/Retire

### Phase 3: Tests (tessa)

1. **Stop activity tests**:
   - Stops an Active sale → state becomes Paused
   - Can't stop a Pending sale
   - Can't stop an already-Paused sale
   - Requires gov authority to stop
   - All datum fields unchanged (except state)
   - UTxO token value unchanged
   - Can't sell tokens while Paused

2. **Resume activity tests**:
   - Resumes a Paused sale → state becomes Active
   - Can't resume a Pending or Active sale
   - Tokens must still be present (match saleLotAssets × totalSaleLots)
   - Requires gov authority
   - VxfDestination fields must validate
   - After resume, selling works normally
   - Rejects resume when record has invalid name (defense-in-depth: validate() on resume, REQT/fkww59zyt3)
   - Rejects resume when saleAssets mutated (defense-in-depth: non-editable fields unchanged, REQT/60azhtn9dy)
   - Rejects resume when startAt mutated (REQT/60azhtn9dy)
   - Rejects resume when progressDetails mutated (REQT/60azhtn9dy)

3. **UpdatingPausedSale tests**:
   - Can update `name` while Paused
   - Can update `settings` (pricing parameters) while Paused, with bounds validation
   - Can update `vxfTokensTo` and `vxfFundsTo` while Paused, with validation-if-present
   - Can't change state during edit
   - Can't change `salePace` (must carry forward)
   - Can't change progress details (all four fields frozen)
   - Can't change `saleAssets` (entire struct frozen)
   - Can't change `startAt`
   - Can't change `threadInfo`
   - Can't change UTxO token value
   - Requires gov authority

4. **Retiring tests** (from Paused):
   - Retires a Paused sale → state becomes Retired
   - Can't retire from Active (must Stop first)
   - Can't retire from Pending
   - Requires gov authority
   - All datum fields unchanged except state
   - UTxO token value unchanged (tokens stay locked)

## Acceptance Criteria

- [ ] `validateCommonUpdateChecks` extracted on `MarketSaleData` — shared by both `validateUpdatePendingSale` and `validateUpdatePausedSale`; `validateUpdatePendingSale` refactored to call it before `validateUpdatePausedSale` is added
- [ ] `MarketSaleState` enum includes `Paused`
- [ ] `mustBePaused` helper exists on `OtherSaleStateV1`
- [ ] `Stopping` spending activity transitions Active → Paused with gov authority; all other fields unchanged
- [ ] `Resuming` spending activity transitions Paused → Active with gov authority; validates deposited tokens and VxfDestination
- [ ] `UpdatingPausedSale` spending activity enforces frozen/editable field inventory per Advisory Notes
- [ ] `validateDetailsWhenPaused` on `SaleProgressDetailsV1` enforces all four fields frozen
- [ ] `Retiring` spending activity transitions Paused → Retired with gov authority; all fields except state unchanged; UTxO value unchanged (tokens stay locked for future CleanupRetired)
- [ ] Selling is rejected when state is Paused
- [ ] Frozen fields: state (except via dedicated activities), salePace, all progressDetails, entire saleAssets struct, startAt, threadInfo, id, type, UTxO token value
- [ ] Editable fields: name, settings (with bounds), vxfTokensTo (validate if present), vxfFundsTo (validate if present)
- [ ] Off-chain transaction builders exist for Stop, Resume, UpdatingPausedSale, and Retire
- [ ] Off-chain pre-flight validation catches wrong-state attempts
- [ ] Tests cover happy paths and rejection cases for all four activities
- [ ] `requirements()` in MarketSaleController updated
- [ ] Once Retired, no transition back to any other state is permitted (REQT/w0hvrt4xx8)
- [ ] Resuming calls `validate()` for defense-in-depth datum integrity (REQT/fkww59zyt3)
- [ ] Resuming verifies all non-editable fields unchanged from input to output (REQT/60azhtn9dy)
- [ ] Front-end advisory documented: the Advisory Notes section contains guidance for front-end implementers that the Stop action MUST display a warning about dynamic price discount accumulation during pause

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Approved with Notes | 2026-02-18 | F1 (Retiring scope), F2 (plan gap), F6 (no new SellingTokens code), F7 (AC reworded) resolved. Requirements coverage verified. |
| Code Whisperer | Approved with Notes | 2026-02-18 | F3 (shared validation extraction) resolved — mandated in plan. F5 (naming) deferred for interactive steering during implementation. |
| Domain-Fit Tester (Stellar Testing) | Approved | 2026-02-18 | F4 (defense-in-depth test gap) resolved. Test sketch: 24 test cases, 4 activities, snapshot chain, helper methods. |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

## Advisory Notes

### Pre-Work Analysis (2026-02-18)

#### Offchain Coder — Activating reuse analysis

The existing `Activating` activity cannot serve double duty for `Paused → Active`:
- Hard-coded `mustBePending` checks in both policy and data validation
- `validateDetailsWhenPending()` asserts zero thread counters (invalid post-activity)
- Semantic mismatch: Activating deposits tokens; Resuming confirms they're already present

**Conclusion**: Separate `Resuming` activity required.

#### Design decision: UpdatingPausedSale is a separate activity

A Paused sale has `lotsSold > 0` and non-initial progress details, so `validateDetailsWhenPending()` constraints (e.g., "lotsSold must be 0", "prevPurchaseAt must equal startAt") don't apply. A separate `UpdatingPausedSale` activity is required with its own validation path.

#### Design decision: Retiring transitions from Paused only

`Retiring` (currently stubbed) will be wired to transition from `Paused → Retired`. This makes Paused the deliberation state: stop selling, then decide whether to resume or wind down. Direct `Active → Retired` is not supported — you must Stop first.

#### UpdatingPausedSale — Validation Design (field-by-field analysis)

Each check from `validateUpdatePendingSale` was evaluated for applicability to the Paused state. The analysis was conducted one consideration at a time with stakeholder review of each decision.

##### Frozen vs. Editable Field Inventory

**Frozen (read-only) fields:**

| Field | Path | Reason |
|-------|------|--------|
| `state` | `saleState.state` | Must remain Paused; state changes use Stop/Resume/Retire |
| `salePace` | `saleState.salePace` | Preserves real market dynamics from prior activity |
| `lotsSold` | `saleState.progressDetails.lotsSold` | Historical fact |
| `lastPurchaseAt` | `saleState.progressDetails.lastPurchaseAt` | Historical fact |
| `prevPurchaseAt` | `saleState.progressDetails.prevPurchaseAt` | Historical fact |
| `lotCount` | `saleState.progressDetails.lotCount` | Frozen; MAY be relaxed in future versions if replaced with sufficient constraints to retain other points of integrity |
| `saleAssets` (entire struct) | `details.V1.saleAssets` | Entangled with deposited tokens and purchase history |
| ↳ `saleLotAssets` | | — |
| ↳ `totalSaleLots` | | — |
| ↳ `singleBuyMaxLots` | | — |
| ↳ `primaryAssetMph` | | — |
| ↳ `primaryAssetName` | | — |
| ↳ `primaryAssetTargetCount` | | — |
| `startAt` | `fixedSaleDetails.startAt` | Time anchor for all pacing/pricing calculations (see pricing impact analysis below) |
| `threadInfo` (entire struct) | `details.V1.threadInfo` | Frozen by equality; structural re-validation not needed (equality is strictly stronger) |
| `id` | top-level | Identity |
| `type` | top-level | Identity |
| UTxO token value | (on-chain value) | No token movement during edits |

**Editable fields:**

| Field | Path | Validation |
|-------|------|------------|
| `name` | top-level | Must be at least 10 characters (existing `validate()` check) |
| `settings` | `fixedSaleDetails.settings` | Bounds validation (sane ranges for all pricing parameters) |
| ↳ `targetPrice` | | — |
| ↳ `targetedSellingTime` | | — |
| ↳ `minPrice` | | — |
| ↳ `maxPrice` | | — |
| ↳ all pace/discount knobs | | — |
| `vxfTokensTo` | `fixedSaleDetails.vxfTokensTo` | Validate if present |
| `vxfFundsTo` | `fixedSaleDetails.vxfFundsTo` | Validate if present |

##### Validation check mapping (UpdatingPendingSale → UpdatingPausedSale)

| # | UpdatingPendingSale Check | UpdatingPausedSale Adaptation |
|---|---------------------------|-------------------------------|
| 1 | `prevState.mustBePending` / `nextState.mustBePending` | `prevState.mustBePaused` / `nextState.mustBePaused` |
| 2 | `salePace == 1.0` | `next.salePace == prev.salePace` (carry forward, don't reset) |
| 3 | `progressDetails.validateDetailsWhenPending()` (lotsSold==0, timestamps==startAt, lotCount==totalSaleLots) | New `validateDetailsWhenPaused()`: all four fields frozen (`next == prev` for each) |
| 4 | `threadInfo == prev.threadInfo` + `validateDetailsWhenPending()` (zero counters) | `threadInfo == prev.threadInfo` only; drop structural re-validation |
| 5 | `inputAssets == outputAssets` (UTxO tokens unchanged) | Identical |
| 6 | Primary asset identity change logic (complex branching) | Not allowed: `next.primaryAssetMph == prev`, `next.primaryAssetName == prev` (via `saleAssets` frozen) |
| 7 | `primaryAssetTargetCount == totalSaleLots × lotSize` consistency | Not needed (entire `saleAssets` struct frozen) |
| 8 | VxfDestination validation if present | Identical |
| 9 | `settings.validateDetailsWhenPending()` (bounds checks) | Identical (function name misleading — checks are state-independent sane bounds) |

#### Design decision: No automatic pricing adjustments on Resume

Pausing a sale causes two pricing effects when it resumes:

1. **Progress pricing**: `elapsedSaleHours` includes pause duration, making `overallPace` drop → deeper progress discounts. **Mitigation**: admin can manually extend `targetedSellingTime` via `UpdatingPausedSale`.

2. **Dynamic pricing**: `hoursSinceLastPurchase` includes pause duration, crashing `inferredPace` and triggering heavy idle-decay → first buyers after resume get prices near `minPrice`. **No mitigation** other than keeping pauses short.

Automatic adjustments were considered (auto-extending `targetedSellingTime`, shifting `lastPurchaseAt`/`prevPurchaseAt` forward on Resume, `Paused { pausedAt }` data variant) but scoped out as future enhancement. The partial fix (auto-extend only) was rejected — it adds on-chain complexity without solving the more visible dynamic pace drop.

**Front-end requirement**: Before executing Stop, the UI MUST display a warning: **"Dynamic price discounts accumulate while paused — Keep the pause duration short!"**

**Future enhancement**: `Paused { pausedAt }` variant + automatic adjustment of `targetedSellingTime`, `lastPurchaseAt`, and `prevPurchaseAt` on Resume to fully neutralize pause duration effects on both pricing factors.

#### Design decision: Child chunks must not sell while root is Paused

When chunk-splitting is implemented, child chunks MUST NOT sell while the root sale is in Paused state. Stopping the root effectively halts the entire sale across all chunks, without requiring each chunk to be stopped individually.

**Mechanism** (future, when splitting is implemented): `SellingTokens` validation on child chunks must require the root sale's UTxO as a reference input and verify the root's state is Active.

**Current status**: Splitting is fully stubbed — no child chunks exist. An IMPORTANT policy comment has been placed in `MarketSalePolicy.hl` at the `SellingTokens` handler to guide future implementation. No reqts docs exist to record this formally.

#### Pricing Impact Analysis: `startAt` and `targetedSellingTime` while Paused

`startAt` feeds directly into all pacing/pricing calculations via `elapsedSaleHours()`:
```
elapsedSaleHours = (purchaseTime - startAt) / HOUR
actualSellingPace = (lotsSold + lotsPurchased) / elapsedSaleHours
overallPace = actualSellingPace / targetSellingPace
```
where `targetSellingPace = lotCount / (targetedSellingTime in hours)`.

The `overallPace` drives the progress pricing discount (when pace < 1.0) and expansion (when > 1.0). Changing `startAt` while real purchase history exists would corrupt elapsed-time calculations; changing `targetedSellingTime` reframes the expected pace without altering history.

##### Representative scenarios

Using defaults: `targetPrice=1.0 ADA`, `minPrice=0.5`, `lotCount=1000`, `targetedSellingTime=108h (4.5d)`, `discountFloorPoint=0.2`, `discountWhenSlow=0.25`.

| Scenario | Sold | Elapsed | targetedSellingTime | overallPace | Progress Discount | Est. Price | Notes |
|----------|------|---------|---------------------|-------------|-------------------|------------|-------|
| **A1**: 5% left, on time | 950 | 108h | 108h | 0.951 | ~1.5% | ~0.97 | Healthy, near target |
| **A2**: 5% left, 2× time | 950 | 216h | 108h | 0.475 | ~16% | ~0.72 | Moderate discount + pace decay |
| **B1**: 50% left, on time | 500 | 108h | 108h | 0.501 | ~16% | ~0.72 | Significant slowdown |
| **B2**: 50% left, 2× time | 500 | 216h | 108h | 0.251 | ~23% | ~0.60 | Approaching floor zone |
| **B3**: 50% left, 4× time | 500 | 432h | 108h | 0.125 | 25% (max) | ~0.50 | Floored — hits minPrice |
| **C1**: 50% left, time extended | 500 | 108h | **216h** | 1.002 | 0% | ~1.00 | Extended time reframes pace — no discount |

##### Dynamic pace drop on resume

Separately from the progress pricing factor, the **dynamic pace** crashes on resume because `hoursSinceLastPurchase` includes the pause duration. This causes `inferredPace` to be near-zero and triggers heavy idle-decay weighting.

Using same defaults, `prevSalePace = 9.0 lots/hr`, first buyer purchases 1 lot after resume:

| Pause Duration | hoursSinceLastPurchase | inferredPace | nextDynamicPace | dynamicPriceFactor | Est. Price (with progress ~1.0) |
|---------------|----------------------|--------------|-----------------|--------------------|---------------------------------|
| 1h | 1.17h | 0.855 | 5.20 | 0.73 | ~0.73 |
| 6h | 6.17h | 0.162 | 2.33 | 0.54 | ~0.54 |
| 24h | 24.17h | 0.041 | 0.73 | 0.44 | 0.50 (floor) |
| 72h | 72.17h | 0.014 | 0.25 | 0.40 | 0.50 (floor) |

The dynamic pace recovers over subsequent purchases (each purchase pulls the weighted average back up), but the first 3-5 buyers after a long pause receive prices near `minPrice`.

This behavior is **accepted** and mitigated by:
- Front-end warning before stopping: "Dynamic price discounts accumulate while paused — Keep the pause duration short!"
- Admin can adjust pricing `settings` (e.g., increase `targetPrice`, reduce `dynaPaceIdleDecayRate`) while paused to partially compensate

##### Conclusions

- **`startAt` must be frozen while Paused** — it's the time anchor for all pacing math. Moving it forward would collapse `elapsedSaleHours` toward zero, spiking `actualSellingPace` to infinity and corrupting pricing.
- **`targetedSellingTime` is safely editable while Paused** — it reframes pace expectations without altering history. This is the designed governance lever for "we're not behind schedule, we just have a longer timeline."
- **Dynamic pace drops on resume** — first buyers get discounted prices proportional to pause duration. Accepted behavior; mitigated by keeping pauses short and front-end warning.
- **Pricing degrades gracefully** when time runs out — no cliff behavior. Progress discount maxes at 25% (`discountWhenSlow`), and `minPrice` (0.50) is the absolute floor.
- **No hard sale end date exists** — the sale sells until tokens are physically depleted from the UTxO. There is no on-chain `lotsSold + lotsPurchased <= lotCount` guard (the transaction simply fails when output value would go negative).

### Pre-Work Collaborative Review (2026-02-18)

#### Architect leads — findings

##### Finding F1: Retiring token handling underspecified — blocks implementation

**Observation**: The plan (Phase 1, item 7) says "Token withdrawal/burning details (to be further specified)" and REQT/je621r06f7 says "Retiring MUST handle withdrawal/burning of remaining tokens from the sale UTxO. Specific mechanism to be further specified during implementation." This is a requirements/plan ambiguity. The coder has three possible interpretations: (a) Retiring only transitions state, tokens stay in UTxO for future CleanupRetired; (b) Retiring withdraws tokens back to gov authority; (c) Retiring burns tokens. Without explicit scoping, the coder must guess. The existing `CleanupRetired` burning activity (FUTURE/REQT-kr9rseqaxf) suggests option (a) is intended, but the requirement text ("MUST handle") contradicts deferral.

> **Resolution**: Stakeholder confirmed option (a). REQT/je621r06f7 revised to state-transition-only: tokens remain locked, disposed later by CleanupRetired (FUTURE). New REQT/dtpwzjqn9p added for UTxO value unchanged. Plan item 7, acceptance criteria, and test plan updated. Retiring is now structurally parallel to Stopping (state change + unchanged datum + unchanged value).

##### Finding F2: Off-chain plan omits UpdatingPausedSale transaction builder

**Observation**: Phase 2 lists three new off-chain transaction builders: `mkTxnStopMarketSale`, `mkTxnResumeMarketSale`, `mkTxnRetireMarketSale`. But the acceptance criteria state "Off-chain transaction builders exist for Stop, Resume, **UpdatingPausedSale**, and Retire." The `UpdatingPausedSale` builder is missing from the plan. The existing `mkTxnUpdateRecord` + `UpdatingPausedSale` activity redeemer may suffice (mirroring how `updatePendingMarketSale` works in the test helper), but the plan should explicitly address this — either as a dedicated convenience method or as guidance for using the generic update path.

> **Resolution**: Added Phase 2 items 4-5. Item 4: UpdatingPausedSale uses generic `mkTxnUpdateRecord` + activity redeemer (no dedicated convenience method); test helper gets `updatePausedMarketSale`. Item 5: `beforeUpdate()` gets explicit Paused branch — passthrough with comment, no implicit fall-through.

#### Code Whisperer — sequenced follow-up

##### Finding F3: Shared validation duplication risk between validateUpdatePendingSale and new validateUpdatePausedSale

**Observation**: `validateUpdatePendingSale()` in MarketSaleData.hl is ~80 lines. The new `validateUpdatePausedSale()` will share substantial validation code: UTxO token value unchanged check, VxfDestination validation (if present), `validate()` call, and threadInfo equality. Without shared helpers, fixing a bug in one validator requires remembering to fix the other — classic shotgun surgery risk. The Advisory Notes' validation check mapping (items 1, 4, 5, 8, 9) shows shared checks. A `validateCommonUpdateChecks()` helper could extract the shared logic, with each state-specific validator calling it plus its own frozen/editable field checks.

> **archie**: The shared checks ARE the structural invariant for "any update to a sale record" — a real concept, not premature abstraction. The divergent checks represent state-specific policy.

> **Resolution**: Promoted to mandatory plan step. Phase 1 item 5 added: extract `validateCommonUpdateChecks` BEFORE adding the Paused validator — refactor first, then extend. Acceptance criterion added. `validateUpdatePendingSale` must be refactored to call the shared helper as the first step, then `validateUpdatePausedSale` builds on the same foundation.

#### Stellar Testing — sequenced follow-up

##### Finding F4: Resume test plan missing defense-in-depth coverage

**Observation**: The test plan for Resuming lists token presence, VxfDestination validation, gov authority, and post-resume selling. But two acceptance criteria with explicit defense-in-depth REQTs lack corresponding test cases: (a) REQT/fkww59zyt3 — "Resuming calls `validate()` for defense-in-depth datum integrity" — needs a negative test showing Resume rejects a record with invalid name (<10 chars) or other validate() failures; (b) REQT/60azhtn9dy — "Resuming verifies all non-editable fields unchanged from input to output" — needs negative tests showing Resume rejects mutations to frozen fields (saleAssets, startAt, progressDetails, threadInfo). Without these, the defense-in-depth validation could be omitted during implementation without test failure.

> **Resolution**: Added 4 negative test cases to the Resume test plan: invalid name rejection (REQT/fkww59zyt3), saleAssets mutation rejection, startAt mutation rejection, progressDetails mutation rejection (all REQT/60azhtn9dy). Each is a separate transaction-level negative test per the expectError pattern.

##### Finding F5: `validateDetailsWhenPending()` naming misleads during shared extraction

**Observation**: The F3 extraction (`validateCommonUpdateChecks`) will call `settings.validateDetailsWhenPending()` — a function whose name says "WhenPending" but whose checks are state-independent bounds validation. A developer reading `validateCommonUpdateChecks` will question why a "WhenPending" function is in code that also serves Paused updates. The Advisory Notes mapping documents this ambiguity but the code won't be self-documenting. The extraction (F3) is the natural moment to rename — both callers are already being touched.

> **Resolution**: Deferred — held for follow-up during implementation. The right rename shape will be clearer once the coder is inside the Helios code. Coder should flag this during the F3 extraction for interactive steering.

##### Finding F6: SellingTokens already rejects Paused via existing `mustBeActive` — no new on-chain code needed

**Observation**: The existing `SellingTokens` handler in MarketSalePolicy.hl already calls `mustBeActive` for both previous and next state. Adding `Paused` to the `MarketSaleState` enum automatically makes selling-while-Paused fail — REQT/jdepn901ag (No Selling While Paused) requires NO new on-chain code. Without explicit guidance, the coder might add a redundant Paused-specific guard to `SellingTokens`. The test sketch already has the right test case (`sell-while-paused-rejected`) confirming existing behavior against the new state.

> **Resolution**: Added Phase 1 item 3: explicit guidance that no new on-chain code is needed for REQT/jdepn901ag — existing `mustBeActive` covers it. Coder must not add redundant guards.

##### Finding F7: Front-end advisory acceptance criterion is unverifiable by this work unit's implementers

**Observation**: The acceptance criterion "Front-end advisory: Stop action MUST display warning..." is a UI concern in an on-chain/off-chain/test work unit. The coder cannot mark it done. The same content already exists in Advisory Notes (design decision: "No automatic pricing adjustments on Resume" → Front-end requirement). It should be removed from acceptance criteria and kept only as advisory.

> **Resolution**: Reworded the acceptance criterion — the deliverable is the advisory documentation itself (already present in Advisory Notes), not the UI implementation. The coder can verify and mark this done.

#### Stellar Testing — test sketch (evolved — see Stellar Testing Interview below)

Test sketch placed directly in the test file and helper per stakeholder preference. **Originally**: 24 `it()` blocks. **Current**: 31 `it()` blocks after interview-driven additions (VxfDestination negative, 2 UTxO value tests, count correction from original mis-tally).

- **`MarketSale.test.ts`**: 4 `describe` blocks (Stopping, Resuming, UpdatingPausedSale, Retiring) with 29 `it()` blocks — each with stable slug, REQT reference, and TODO-commented body showing real helper calls, assertions, and expectError patterns. Happy-path tests consolidate assertions into single transactions. UpdatingPausedSale happy path includes `assertEnforcedReqts` wiring proof. Frozen-field tests use `rawUpdate` option. Gov-rejection tests use `txnAddGovAuthority` mock pattern.
- **`MarketSaleTestHelper.ts`**: Snapshot chain (`firstMarketSalePaused` → parent `firstMarketSaleActivated`, `firstMarketSaleResumed` → parent `firstMarketSalePaused`) plus 4 helper methods. `updatePausedMarketSale` evolved to dual-mode interface (editable-fields guard + `rawUpdate` bypass). `assertEnforcedReqts` added for diagnostics wiring proof. Stop/Resume/Retire helpers retain TODO bodies pending off-chain builder delivery.

### Pre-Completion Audit Tasks

#### Gov-authority handling redundancy (tessa)

**Context**: All gov-rejection tests use `vi.spyOn(capo, "txnAddGovAuthority").mockImplementation(async (tcx) => tcx as any)` to strip gov authority and verify on-chain policy rejection. The project expectation is that `mkTxn*` methods add gov authority automatically when needed — test helpers should not add it separately.

**Task**: Before post-work sign-off, review all test helpers (Stop, Resume, UpdatingPausedSale, Retire) and their corresponding `mkTxn*` off-chain builders for gov-authority handling redundancy. If any helper duplicates the gov authority addition that the `mkTxn*` builder already performs, remove the redundancy. Verify that the mock pattern is the only mechanism used for gov-rejection testing.

**Scope**: `MarketSaleTestHelper.ts` helpers (`stopMarketSale`, `resumeMarketSale`, `updatePausedMarketSale`, `retireMarketSale`) and `MarketSaleController.ts` builders (`mkTxnStopMarketSale`, `mkTxnResumeMarketSale`, `mkTxnRetireMarketSale`, `mkTxnUpdateRecord` with `UpdatingPausedSale`).

### Offchain Coder Interview (2026-02-19, in progress)

Structured interview (ingrid protocol) with Code Whisperer advisory. Settled decisions:

#### Gov authority handling
`MarketSaleBundle.requiresGovAuthority = true` means the base class `mkTxnUpdateRecord` already adds gov authority automatically. The three new `mkTxn*` methods do NOT add it explicitly — the base class handles it. (Note: existing `mkTxnAddToMarketSale` has an explicit `txnAddGovAuthority` call that may be redundant — surfaced as suggestion, not fixed.)

#### Three state-transition builders — confirmed shape
All three (`mkTxnStopMarketSale`, `mkTxnResumeMarketSale`, `mkTxnRetireMarketSale`) are simplified wrappers around `mkTxnUpdateRecord`: minimal interface `(mktSale, tcx?)`, copy all datum fields, change only state, no `addedUtxoValue`. Code drafted.

#### UpdatingPausedSale — no controller convenience method
Generic `mkTxnUpdateRecord` + `UpdatingPausedSale` activity redeemer is the path, consistent with how `UpdatingPendingSale` works. The form manager provides the UX. Test helper `updatePausedMarketSale` implemented with clean editable-fields interface (`name?`, `settings?`, `vxfTokensTo?`, `vxfFundsTo?`).

#### Pre-flight validation
State checks only for the three builders, gated on `!environment.isTest` (from `@donecollectively/stellar-contracts`). No additional offchain checks needed — other validations are correct-by-construction or have adequate failure messages from the framework. Code drafted.

#### `beforeUpdate()` — explicit Paused branch
Added branch checking `original.details.V1.saleState.state.Paused` — catches UpdatingPausedSale, Resuming, and Retiring. Returns `updated` unchanged. Design intent: all progress details are frozen while Paused, so no fixups needed. Explicit branch prevents accidental future fixup application. Code drafted.

#### `findMarketSales()` — paused filter removed from scope
Stakeholder override: no specific use-case for a `paused` filter at this time. Paused is a transient admin state, not a query dimension.

#### `requirements()` — entries added
Four new requirement entries added matching test describe labels: Stopping, Resuming, UpdatingPausedSale, Retiring. Each with mech entries matching the test `it()` labels exactly. Top-level "Governs the process..." requirement updated to reference the new groups.

#### Remaining items
- Also update the test helpers for stop/resume/retire to call the controller methods (currently TODO stubs)
- Work unit acceptance criteria update to reflect settled decisions — pending
- Interview not yet complete

### Onchain Coder Interview (2026-02-19, in progress)

Structured interview (ingrid protocol) with Code Whisperer advisory, working through all on-chain implementation considerations before coding.

#### Enum positioning — settled

`MarketSaleState` enum uses explicit tags for terminal states:
```helios
enum MarketSaleState {
    Pending      // tag 0
    Active       // tag 1
    Paused       // tag 2
    65 : Retired
    86 : SoldOut
}
```
- Natural lifecycle progression 0→1→2 for active states
- Terminal states pinned to high explicit tags (65, 86) — stable regardless of future additions
- Tags 3–64 available for future lifecycle states
- Tag gap is itself documentation of the terminal/lifecycle boundary
- **Implemented**: `MarketSaleData.hl:34-39`

#### mustBePaused — parameterized reqtId for traceability

`mustBePaused(which, reqtId)` takes a caller-provided REQT id string, appended into the REQT text. Each call site (Stopping, Resuming, UpdatingPausedSale, Retiring) passes its own activity-specific REQT reference. The helper's own existence traces to REQT/a1c1x495x6.
- **Implemented**: `MarketSaleData.hl` on `OtherSaleStateV1`

#### No switch-block risk from Paused addition — verified

Searched all `.hl` files for `MarketSaleState` usage. All consumption is via equality checks (`== MarketSaleState::Active`, `== MarketSaleState::Pending`), not switch/case. Adding `Paused` cannot silently fall through any existing branch.

#### Stopping/Retiring — "all fields unchanged" enforcement approach — settled

Stakeholder chose field-by-field deep `==` over serialize-and-compare. Rationale: avoids serialize() cost, gives per-field diagnostic on failure. Tradeoff: new fields added to the datum in future won't be automatically covered — but the post-work audit catches this.

**TODO (pattern harvest)**: Document `serialize() vs field-by-field deep ==` as a reusable pattern decision for on-chain "nothing else changed" guards. Key factors: on-chain compute cost of serialize(), diagnostic clarity per-field, future-field coverage tradeoff. Candidate for stellar-contracts patterns library or onchain-coder knowledge base.

Shared helper `validateStateOnlyChange(self, previous, reqtId)` on `MarketSaleData` — datum fields only (REQT-9nsee3zj78):
- `name`, `fixedSaleDetails`, `saleAssets`, `threadInfo` (deep `==` against previous)
- `progressDetails`, `salePace` (within saleState, deep `==`)
- `id`/`type` immutability handled by framework (`mustOutputDelegatedData`) — not re-checked

UTxO value check is NOT in the helper — callers do it inline with their own REQT id. Avoids over-abstracting a one-liner that traces to different REQTs per activity.

**TODO (pattern harvest)**: Document "helper abstraction boundary" anti-pattern — when a helper bundles two checks that trace to different REQTs, the traceability gets muddied. Keep helpers to one REQT-traceable concern.

**TODO (pattern harvest)**: Document "time-sensitive transaction in snapshot" anti-pattern — when a test asserts exact values that depend on `Date.now()` at transaction time (e.g., `startAt = now + 1 day`), snapshotting the *result* of that transaction bakes a stale timestamp into the cached data. On restore, the helper recomputes the expected value from a fresh `Date.now()`, which no longer matches. **Fix**: snapshot only the *precondition* state; run the time-sensitive transaction inline so expected values and actual data share the same clock. Candidate for stellar-testing patterns JSONL.

Used by both Stopping and Retiring. Caller handles state assertions and UTxO value check separately (with per-activity REQT traceability).
- **Implemented**: `MarketSaleData.hl` on `MarketSaleData` struct

#### Stopping activity — implemented

`Stopping { id: ByteArray }` added to `SpendingActivity` enum. Handler in `additionalDelegateValidation`:
- `mustBeActive` on previous state
- `mustBePaused` on updated state (REQT-fx7m3y1ctf)
- `validateStateOnlyChange` for all-fields-unchanged (REQT-nxqq219k4r)
- UTxO token value unchanged (REQT-03ff0mfddc)
- `requiresGovAuthority`
- **Implemented**: `MarketSalePolicy.hl` (enum + handler)

#### Retiring activity — implemented

Replaced stub with live handler. Same pattern as Stopping:
- `mustBePaused` on previous state (REQT-hcagxtdt35)
- State must be Retired (REQT-hcagxtdt35)
- `validateStateOnlyChange` for all-fields-unchanged (REQT-9nsee3zj78 — Retiring-specific)
- UTxO token value unchanged (REQT-dtpwzjqn9p)
- `requiresGovAuthority`
- **Implemented**: `MarketSalePolicy.hl` (handler replaced stub)

#### Resuming activity — implemented

`Resuming { id: ByteArray }` added to `SpendingActivity` enum. Handler in `additionalDelegateValidation`:
- `mustBePaused` on previous state (REQT-3h96mdmn5k)
- `mustBeActive` on updated state
- `validateStateOnlyChange` for non-editable fields unchanged (REQT-60azhtn9dy)
- UTxO token value unchanged (REQT-998waf4mz3)
- Remaining sale tokens present via `contains`: `saleLotAssets * (totalSaleLots - lotsSold)` (REQT-qh3qkk8f92)
- VxfDestination validation for both vxfTokensTo and vxfFundsTo if present (REQT-jkbaba8n7n)
- General `validate()` defense-in-depth (REQT-fkww59zyt3)
- `requiresGovAuthority`
- **Implemented**: `MarketSalePolicy.hl` (enum + handler)

Note: token presence uses `utxoValue.contains(expectedAssets)` not exact equality — allows sale proceeds (ADA) and minUtxo to coexist with sale tokens.

#### Rename: `validateDetailsWhenPending()` → `validateUpdatedDetails()` on DynamicSaleV1Settings

F5 resolved. The settings bounds check is state-independent — applies to any update. Renamed to match `SaleProgressDetailsV1::validateUpdatedDetails` (convergent naming across structs).
- **Implemented**: `DynamicSaleV1Settings.hl`, call sites in `MarketSaleData.hl`

#### `validateCommonUpdateChecks` extraction — implemented

Shared helper on `MarketSaleData` called by both `validateUpdatePendingSale` and `validateUpdatePausedSale`:
- UTxO token assets unchanged (`get_assets()` comparison — allows ADA to change for minUtxo)
- ThreadInfo frozen
- VxfDestination validation if present (both fields)
- General `validate()` call
- Settings bounds validation (`validateUpdatedDetails()`)

`validateUpdatePendingSale` refactored to call shared helper first, then Pending-specific checks (mustBePending, pace == 1.0, primary asset logic, threadInfo structural validation, progressDetails WhenPending).
- **Implemented**: `MarketSaleData.hl`

#### `validateDetailsWhenPaused` on SaleProgressDetailsV1 — implemented

All four fields frozen (`next == prev`): lotsSold, lastPurchaseAt, prevPurchaseAt, lotCount.
- **Implemented**: `SaleProgressDetails.hl`

#### UpdatingPausedSale activity — implemented

`UpdatingPausedSale { id: ByteArray }` added to `SpendingActivity` enum. Validation via `validateUpdatePausedSale`:
- Shared checks via `validateCommonUpdateChecks`
- mustBePaused on both states (REQT-b30wn4bdw2)
- salePace carry forward (REQT-xygjysee4h)
- progressDetails frozen via `validateDetailsWhenPaused` (REQT-xygjysee4h)
- saleAssets frozen (REQT-xygjysee4h)
- startAt frozen (REQT-xygjysee4h)
- Editable: name, settings (with bounds), vxfTokensTo, vxfFundsTo (via shared checks)
- `requiresGovAuthority`
- **Implemented**: `MarketSalePolicy.hl` (enum + handler), `MarketSaleData.hl` (validation)

### Stellar Testing Interview (2026-02-19, in progress)

Structured interview (ingrid protocol) with Code Whisperer advisory, evolving the test sketch into implementation-ready test code.

#### Gov-authority rejection pattern — settled

All 4 gov-rejection tests (Stopping, Resuming, UpdatingPausedSale, Retiring) use `vi.spyOn(h.capo, "txnAddGovAuthority").mockImplementation(async (tcx) => tcx as any)`. Actor-switching (`h.setActor("tom")`) does NOT remove gov authority — `txnAddGovAuthority` references the charter UTxO, which is not actor-specific. Mock pattern is the established convention (matches existing AddTokens and UpdatingPendingSale gov tests). **Updated**: All 4 test sketches in `MarketSale.test.ts`.

#### `updatePausedMarketSale` helper — evolved from coder's implementation

Coder implemented a domain-enforcing `editableFields` interface that structurally prevents callers from passing frozen fields — only `name`, `settings`, `vxfTokensTo`, `vxfFundsTo` are accepted. Frozen fields are carried forward internally. This is better than the original sketch's raw `updatedFields` approach.

**Interface evolution** (tessa owns this helper):
- Dropped `description` parameter — fixed internal log string; test output already has `it()` block name
- 3rd param is now an options bag extending `TestHelperSubmitOptions`:
  - `rawUpdate?: Partial<MarketSaleDataLike>` — bypasses `editableFields` guard, passes raw `updatedFields` directly to `mkTxnUpdateRecord`. For frozen-field policy tests.
  - `addedUtxoValue?: Value` — injects extra token value into UTxO output. For UTxO-value-unchanged tests.
  - `preTcx?: StellarTxnContext` — pre-built transaction context (e.g., with minting). Used instead of creating a fresh tcx.
- Normal mode: `editableFields` interface enforces frozen/editable boundary
- Raw mode: `options.rawUpdate` bypasses for on-chain policy verification

**Updated**: `MarketSaleTestHelper.ts` helper, all UpdatingPausedSale test sketches.

#### Additional negative tests — 3 added (24 → 27 total)

Coverage gaps identified during review:
1. **`update-paused-invalid-vxf/REQT/6z88fg6j2s`** — VxfDestination rejection for UpdatingPausedSale. Even with shared `validateCommonUpdateChecks`, this confirms the wiring is live for the Paused path.
2. **`stop-utxo-value-changed/REQT/tx3fyv3eb2`** — UTxO value unchanged enforcement during Stopping. Manual txn build with injected FISH token.
3. **`retire-utxo-value-changed/REQT/dtpwzjqn9p`** — UTxO value unchanged enforcement during Retiring. Manual txn build with injected FISH token.

Stopping/Retiring UTxO tests stay manual (1 test each) — dedicated builders like `mkTxnStopMarketSale` won't support `addedUtxoValue`; the test needs raw `mkTxnUpdateRecord` by design.

#### Happy-path diagnostics wiring proof — added to `update-paused-editables`

The happy-path UpdatingPausedSale test (`update-paused-editables/REQT/d1967hd11e`) now checks transaction diagnostics via `h.assertEnforcedReqts(tcx, [...])` after successful submission. This proves the shared `validateCommonUpdateChecks` pipeline is wired for UpdatingPausedSale — each REQT check actually ran during the successful transaction. REQT identifiers mapped from requirements doc:
- `REQT-ntdbhc1xss` (UTxO Value Unchanged)
- `REQT-rg5zyhd2gb` (ThreadInfo Frozen)
- `REQT-6z88fg6j2s` (Paused Update Validates VXF If Present)
- `REQT-b731sye0fz` (Settings Bounds Validation When Paused)
- `REQT-y16j4t955c` (Name Length via validate())
- `REQT-egttdcamhg` (Non-Empty Assets via validate())

**New helper**: `assertEnforcedReqts(tcx, REQT-${string}[])` — TODO body, to be wired to transaction diagnostic inspection.

#### Test count summary

| Activity | Happy path | Negative | Total |
|----------|-----------|----------|-------|
| Stopping | 1 | 5 | 6 |
| Resuming | 2 | 7 | 9 |
| UpdatingPausedSale | 1 | 9 | 10 |
| Retiring | 1 | 5 | 6 |
| **Total** | **5** | **26** | **31** |

*(Verified against actual `it()` blocks with REQT/ slugs in test file. Increased from original pre-work sketch of 24 → 31 after interview-driven additions: VxfDestination negative, 2 UTxO value tests, count correction from original mis-tally.)*

#### Helper method source — resolved

Stop/Resume/Retire helpers updated by offchain coder to call dedicated builders (`mkTxnStopMarketSale`, `mkTxnResumeMarketSale`, `mkTxnRetireMarketSale`). However, offchain coder removed `overrideFields` from `resumeMarketSale` — restored by tessa, needed for 4 defense-in-depth tests (REQT/fkww59zyt3, REQT/60azhtn9dy). Dual-path: normal calls dedicated builder, `overrideFields` falls back to `mkTxnUpdateRecord` + `Resuming` activity to inject mutations.

**Lesson**: Test helper code is tessa's domain. Off-chain coder should implement controller methods and leave test helpers for the tester to evolve. When test sketches contain commented-out TODO implementations, they represent approved test design — not stubs to be replaced without coordination.

#### All design issues resolved

1. ~~Gov-authority mock pattern~~ — settled ✅
2. ~~`updatePausedMarketSale` interface~~ — dual-mode (editableFields + rawUpdate) ✅
3. ~~Additional negative tests~~ — 3 added (31 total) ✅
4. ~~Happy-path diagnostics wiring proof~~ — `assertEnforcedReqts` with REQT ids ✅
5. ~~Helper method source~~ — dedicated builders + `overrideFields` restored ✅
6. ~~Happy-path coalescing~~ — verified no redundancy ✅

#### Self-audit — complete

Audited all 31 tests against every entry in `stellar-testing.patterns.jsonl` (7 patterns, 6 anti-patterns):

**Patterns — all compliant:**
- `happy-path-consolidation`: Each activity has one happy-path test with multiple assertions from a single transaction
- `stable-slug-identity`: All 31 tests have kebab-case slugs + REQT UUTs
- `reqt-group-describe`: All 4 describe blocks have `(REQT/<uut>)`
- `negative-test-expect-error`: All negative tests use `rejects.toThrow(regex)`
- `helper-extraction-threshold`: All reusable state extracted to named snapshots

**Anti-patterns — none violated:**
- `snapshot-before-mock`: All 4 gov-mock tests snapshot first, then `vi.spyOn`
- `mock-before-snapshot`: Same — no mock state baked into snapshots
- `repeated-positive-txns`: No redundant positive transactions
- `brittle-exact-match`: No volatile data in assertions
- `test-coupling`: Every test starts with `reusableBootstrap()` + snapshot
- `actor-context-leaking`: `setActor("tom")` only in 2 buyer tests; snapshots reset via decorator
- `missing-edge-cases`: Each activity has negative tests for wrong-state, no-gov, UTxO-value, frozen-fields
- `generic-error-regex`: All regexes specific to the constraint being tested

**Finding during audit**: `retired-no-regression` was paying for `retireMarketSale` inline every run instead of using a cached snapshot. Fixed — added `snapToFirstMarketSaleRetired` (commit `408630d`).

#### Interview complete ✅

All 6 design issues resolved. 31 tests uncommented as live code. `assertEnforcedReqts` helper implemented. Self-audit passed.

### Post-Work Collaborative Review (2026-02-19)

**Audit file**: [post-work-audit.md](./20260218.market-sale-pause-stop.post-work-audit.md)

#### Architect — zero findings

Architectural alignment maintained. State machine, frozen/editable boundaries, no unvetted decisions. Details in audit file.

#### Code Whisperer — 1 finding

##### Finding pw-cw-f1: Incorrect comment claims REQT/fkww59zyt3 is unimplemented

Test file comment at line 1960 claims "Resuming doesn't call validate()" — but on-chain Resuming handler explicitly calls `updated.validate()` with REQT-fkww59zyt3 tracing. Comment contradicts implementation and acceptance criteria.

#### Stellar Testing — sequenced follow-up

##### Finding pw-st-f1: Missing wiring proof for validate() on Resuming

Resuming happy path has no `assertEnforcedReqts` to prove defense-in-depth checks run. REQT-fkww59zyt3 implemented on-chain but has zero test coverage. Test count now 30 (not 31 per Advisory Notes).

## Worker Report: Onchain Coder (osiris)

### Summary

Fixed two Helios compile errors in `MarketSalePolicy.hl` that prevented the MarketSale bundle from compiling. All on-chain implementation was already in place from prior sessions; these were wiring issues in the Resuming activity handler.

### Commit

| Commit | Description |
|--------|-------------|
| `44e01a8` | fix(market-sale): Helios compile errors in Resuming handler |

### Fixes

1. **Missing `bREQTgroup` import** — `bREQTgroup` was used in the Resuming handler's token-presence check but not imported from `StellarHeliosHelpers`. Added to the import block.

2. **`assertREQTgroup` → `bREQTgroup` for VxfDestination checks** — Two VxfDestination validation calls (vxfTokensTo, vxfFundsTo) in the Resuming handler used `assertREQTgroup`, which returns `()`. These appeared in a `&& Bool` chain, causing type errors (`Bool && ()` undefined, then cascading `Any && Bool` undefined). Changed both to `bREQTgroup` (returns `Bool`) with named arguments (`reqt:`, `collapsed:`, `callback:`).

### Scope verification

No other changes made. The fixes are strictly limited to the import list (line 48) and the two `assertREQTgroup` → `bREQTgroup` swaps in the Resuming handler (lines 612, 627). All existing enforcement logic, REQT traceability, and validation behavior are unchanged.

### Build status

- Helios compilation: **clean** — MarketSale bundle compiles and optimizes successfully
- Remaining build failures are **not on-chain**: TypeScript errors in `MarketSaleController.ts` (offchain code references new types not yet in stale `.typeInfo.d.ts`) and a pre-existing `Vesting.generic.hlb.ts` portability issue

## Worker Report: Stellar Testing (tessa)

### Summary

Evolved the pre-work test sketch (24 cases) into 31 implementation-ready test cases across 4 activity groups, with 5 helper methods and 3 named snapshots in the helper chain.

### Commits (chronological, tessa-authored)

| Commit | Description |
|--------|-------------|
| `2858e78` | Initial test sketch — 4 activity groups, 24 test cases, snapshot chain |
| `4d4b570` | F4 — added 4 Resume defense-in-depth tests |
| `a16bcf7` | Pre-work sign-offs approved |
| `89c1faf` | Evolved sketch to 31 cases: gov-mock pattern, dual-mode helper, 3 new negative tests, diagnostics wiring |
| `9dd3210` | Restored `resumeMarketSale` `overrideFields` after offchain coder removed it |
| `fe2e3af` | Uncommented all 31 test implementations — live code |
| `a914a59` | Implemented `assertEnforcedReqts` — inspects `tcx.logger.fullHistory()` for REQT traces |
| `408630d` | Self-audit fix: added `snapToFirstMarketSaleRetired` snapshot |

### Deliverables

**Test file** (`MarketSale.test.ts`): 31 new `it()` blocks in 4 `describe` groups:
- Stopping (6): happy path + wrong-state×2 + gov-rejection + UTxO-value + sell-while-paused
- Resuming (9): happy path + sell-after-resume + wrong-state×2 + gov-rejection + defense-in-depth×4
- UpdatingPausedSale (10): happy path (with `assertEnforcedReqts` wiring proof) + invalid-vxf + frozen-field×6 + UTxO-value + gov-rejection
- Retiring (6): happy path + wrong-state×2 + gov-rejection + UTxO-value + no-regression

**Helper file** (`MarketSaleTestHelper.ts`):
- `stopMarketSale(sale, opts?)` — calls `mkTxnStopMarketSale`
- `resumeMarketSale(sale, opts?, overrideFields?)` — dual-path: normal via `mkTxnResumeMarketSale`, override via `mkTxnUpdateRecord` + `Resuming` activity
- `updatePausedMarketSale(sale, editableFields, opts?)` — dual-mode: `editableFields` interface (structurally safe) or `rawUpdate` bypass (for on-chain policy tests)
- `retireMarketSale(sale, opts?)` — calls `mkTxnRetireMarketSale`
- `assertEnforcedReqts(tcx, reqtIds[])` — searches `tcx.logger.fullHistory()` for REQT ID strings
- `snapToFirstMarketSalePaused` — parent: `firstMarketSaleActivated`
- `snapToFirstMarketSaleResumed` — parent: `firstMarketSalePaused`
- `snapToFirstMarketSaleRetired` — parent: `firstMarketSalePaused`

### Key design decisions

1. **Gov-rejection via mock, not actor-switch** — charter UTxO is not actor-specific
2. **`updatePausedMarketSale` dual-mode** — `editableFields` guard for normal use; `rawUpdate` bypass for on-chain policy verification
3. **`resumeMarketSale` `overrideFields`** — defense-in-depth tests need to inject bad data into a Resuming transaction; dual-path with `mkTxnUpdateRecord` fallback
4. **One UTxO value test per activity** — separate on-chain validation paths need independent wiring confirmation
5. **`assertEnforcedReqts` as wiring proof** — happy-path test proves shared validation pipeline ran each REQT check
6. **All reusable state as named snapshots** — even single-use states, because snapshots persist between runs

### Status

All tests are live code, ready for the test runner. Tests will fail until the on-chain code compiles and the off-chain builders are wired — expected behavior for test-first development. Error regex patterns may need adjustment once actual on-chain error messages are confirmed.
