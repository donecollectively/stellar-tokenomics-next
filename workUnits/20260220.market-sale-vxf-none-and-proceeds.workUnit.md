# Work Unit: 8as6q87tc1

**Title**: MarketSale VXF None-Mode Enforcement & WithdrawingProceeds
**Created**: 2026-02-20
**Source**: ad-hoc

> **Required context**: Load [work-planner.SKILL.md](../../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder, Offchain Coder, Stellar Testing
**ARCH Items**: MarketSale delegate policy, MarketSale spending activities
**REQT Items**:
 - REQT/2vmbpk5xw7 (VXF None-Mode Enforcement)
 - REQT/1h49829nsx (vxfFundsTo Must Be None)
 - REQT/88cfkdj7p2 (vxfTokensTo Must Be None)
 - REQT/wh3kjtwmj9 (Funds Accumulate to Sale UTxO)
 - REQT/nnxpz49srs (Tokens Sent to Buyer)
 - REQT/4z5dkz9p2p (VXF Validation — reworked for None-mode)
 - REQT/adazrztjma (Proceeds Withdrawal)
 - REQT/czp1jhqgdj (WithdrawingProceeds Activity)
 - REQT/ayvw26q6av (Valid States for Withdrawal)
 - REQT/aexkjfxm2k (Gov Authority)
 - REQT/5r79v9b4ht (No Constraint on Withdrawal Amount)
 - REQT/gy6jd9cjkg (Tokens Must Remain)
 - REQT/ykqx9qgh88 (Datum Fields Unchanged)

**Superseded requirements** (DEPRECATED, implementation to be removed/replaced):
 - REQT/x3xkgwp94t (was: Activating Requires vxfFundsTo Some)
 - REQT/d67c29t29w (was: Activating Validates vxfTokensTo If Present)
 - REQT/g563tb3ks1 (was: Pending Update Validates VXF If Present)
 - REQT/0sa1x0aj4z (was: Invalid VXF Destination — activation fails if vxfFundsTo missing)

## Problem / Context

The MarketSale currently has VXF destination fields (`vxfFundsTo`, `vxfTokensTo`) that were implemented with the expectation of full VXF protocol routing — sealing destinations, validating receiver participation, routing funds/tokens per sealed config. That full protocol is P1/FUTURE.

For the current iteration, a simpler model is needed:
1. **Both fields MUST be None** — the on-chain policy rejects any activity where either field is Some.
2. **Funds accumulate** — during SellingTokens, buyer payments stay in the mktSale UTxO (which is already what happens, but wasn't formalized as the intended None-mode behavior).
3. **Tokens go to buyer** — no routing constraint on purchased tokens.
4. **Proceeds withdrawal** — new `WithdrawingProceeds` spending activity lets governance authority extract accumulated ADA from the sale UTxO when the sale is Paused, SoldOut, or Retired. No constraint on withdrawal amount. Tokens must remain locked.

This gives a working end-to-end flow: create → configure → activate → sell (funds accumulate) → pause → withdraw proceeds. The full VXF routing can be layered in later without changing this foundation.

### Impact on existing implementation

The existing code validates VXF destinations during Activating (requires vxfFundsTo Some), UpdatingPendingSale, and UpdatingPausedSale. That validation logic must be replaced with None-mode enforcement (reject if Some). The SellingTokens funds-gathering behavior is already correct for None-mode but has a TODO comment about switching to VXF routing — that TODO stays as a future marker.

## Focus Files

- `src/MarketSale/MarketSalePolicy.hl` — spending activity dispatch, add WithdrawingProceeds enum variant and handler
- `src/MarketSale/MarketSaleData.hl` — VXF validation helpers (currently validate if Some, need to reject if Some)
- `src/MarketSale/MarketSaleController.ts` — offchain transaction builder for WithdrawingProceeds
- `src/MarketSale/tests/MarketSale.test.ts` — tests for None-mode enforcement and WithdrawingProceeds
- `src/MarketSale/tests/MarketSaleTestHelper.ts` — test helper for WithdrawingProceeds scenarios
- `src/MarketSale/MarketSale.onchain.reqts.jsonl` — requirements source of truth

## Plan / Guidance

### Phase 1: VXF None-Mode Enforcement

**Onchain** (osiris):
- Replace VXF validation helpers in MarketSaleData.hl — instead of "validate if Some, ok if None", enforce "MUST be None, reject if Some"
- Update all activities that call VXF validation: Activating, UpdatingPendingSale, UpdatingPausedSale, Resuming, SellingTokens
- Remove or guard the existing `validateVxfDestinations` / `validateVxfWhenActivating` paths
- The existing funds-gathering in SellingTokens is already correct — just add REQT traceability for REQT-wh3kjtwmj9

**Offchain** (freya):
- Change default `vxfFundsTo` in `MarketSaleController.ts` from `{ Anywhere: {} }` to `undefined` (maps to None in Helios) — the current default is a Some value that would be rejected under None-mode
- Ensure no other code path sets vxfFundsTo/vxfTokensTo to anything other than None/undefined
- Remove or guard any offchain code that tries to seal VXF destinations
- Remove vxfFundsTo/vxfTokensTo from the `updatePausedMarketSale` helper's `editableFields` interface — these fields are frozen under None-mode

**Tests** (tessa):
- Rework existing VXF validation tests to test None-mode rejection (reject any Some value, not just NotYetDefined)
- Negative tests: activation with vxfFundsTo = Some should fail, same for vxfTokensTo
- Positive: confirm funds accumulate to UTxO after selling
- Positive: confirm tokens reach buyer

### Phase 2: WithdrawingProceeds Activity

**Onchain** (osiris):
- Add `WithdrawingProceeds { id: ByteArray }` to SpendingActivity enum
- Handler: require gov authority, require state in {Paused, SoldOut, Retired}, verify non-ADA tokens unchanged, verify datum unchanged, no constraint on ADA change
- REQT* traceability for all enforcement points

**Offchain** (freya):
- Add `withdrawProceeds(saleId, amount?)` dAPI method to MarketSaleController
- Transaction building: spend the sale UTxO with WithdrawingProceeds redeemer, produce output with same datum and tokens but less ADA

**Tests** (tessa):
- Happy path: pause sale → withdraw ADA → verify UTxO updated
- Negative: withdraw while Active → rejected
- Negative: withdraw while Pending → rejected
- Happy path: withdraw while Retired
- Happy path: withdraw while SoldOut (if testable)
- Verify tokens remain locked after withdrawal

## Acceptance Criteria

- [ ] All activities reject transaction when vxfFundsTo is Some
- [ ] All activities reject transaction when vxfTokensTo is Some
- [ ] SellingTokens accumulates funds to sale UTxO (existing behavior, now traced)
- [ ] Tokens reach buyer with no routing constraint
- [ ] WithdrawingProceeds enum variant added to SpendingActivity
- [ ] WithdrawingProceeds valid in Paused, SoldOut, Retired only
- [ ] WithdrawingProceeds requires gov authority
- [ ] WithdrawingProceeds leaves datum unchanged
- [ ] WithdrawingProceeds preserves non-ADA tokens
- [ ] No constraint on ADA withdrawal amount
- [ ] All new requirements traced with REQT* / REQT/ annotations
- [ ] Superseded requirements' enforcement logic removed/replaced
- [ ] Tests cover None-mode enforcement and WithdrawingProceeds

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Approved | 2026-02-20 | F1 resolved — creation default + test rework added to plan. Scope well-bounded, REQTs cover all behavioral changes. |
| Code Whisperer | Approved with Notes | 2026-02-20 | Zero structural findings. Suggestion: consolidate VXF validation into single `requireVxfNone()` helper — Coder's judgment. |
| Domain-Fit Tester (Stellar Testing) | Approved | 2026-02-20 | Test sketch in Advisory Notes. Existing VXF tests need rework. New helper `withdrawProceeds` needed. |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

## Advisory Notes

### Pre-Work Collaborative Review (2026-02-20)

#### Architect leads — findings

##### Finding F1: Default creation data uses vxfFundsTo = Anywhere (Some)

**Severity**: Concern

The offchain controller's default creation data (`MarketSaleController.ts:282`) sets `vxfFundsTo: { Anywhere: {} }` — a `Some` value. Under None-mode enforcement, this means every sale created with defaults will fail activation (REQT/1h49829nsx rejects when vxfFundsTo is not None).

**Cascade impact**:
- The test helper's `firstMarketSaleActivated()` inherits this default — `snapToFirstMarketSaleActivated` and all downstream snapshots (paused, resumed, retired) are invalid under None-mode
- All existing tests that create and activate sales will break
- The work unit's plan says "ensure controller doesn't set VXF to anything other than None" but doesn't call out this specific default or the snapshot invalidation cascade

**Proposed remediation**: Add explicit note to Plan section: change default `vxfFundsTo` to `undefined` (maps to None in Helios) in the controller's creation code. Update test helper editableFields interface. Rework existing VXF tests for None-mode.

> **Resolution**: Plan updated with explicit creation-default change, helper interface cleanup, and test rework callouts. Commit 4ac86d6 (initial) + remediation commit below.

> **cwispy**: Agree — the `updatePausedMarketSale` helper also has `vxfFundsTo`/`vxfTokensTo` in its `editableFields` interface (line 421). Under None-mode these fields aren't editable. The interface should be updated to remove them (or guard against setting them). Not structural debt — just cleanup that falls out of this finding.

> **tessa**: Existing VXF tests need rework — the test at line 460 ("won't activate if vxfFundsTo doesn't validate") tests rejection of `NotYetDefined`, but under None-mode, the test should instead verify rejection of any `Some` value (e.g., `Anywhere`). The test at line 1726 ("validates VxfDestination in vxfFundsTo if provided") and 2014 ("can update vxf destinations while Paused") also need rework or removal.

#### Code Whisperer — sequenced follow-up

Zero additional structural findings. The code area is clean for this scope:
- WithdrawingProceeds follows the established SpendingActivity enum + dispatch pattern
- VXF validation helpers in MarketSaleData.hl are self-contained and straightforward to replace
- No scattered heuristics, implicit coupling, or missing seams detected

One suggestion (not a finding): the two VXF validation paths (activation context at ~321 and update context at ~440) both reduce to `requireVxfNone()` under None-mode — opportunity to consolidate into a single helper. Coder's judgment.

#### Stellar Testing — sequenced follow-up

Zero additional findings beyond the test rework noted in F1.

**Test sketch**:

```typescript
// === Phase 1: VXF None-Mode Enforcement ===

describe("VXF None-Mode Enforcement (REQT/2vmbpk5xw7)", () => {
    // Existing test rework: "won't activate if vxfFundsTo is Some"
    // was: rejects NotYetDefined; now: rejects ANY Some value
    it("rejects activation when vxfFundsTo is Some (none-mode-funds-to/REQT/1h49829nsx)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const marketSale = await h.findFirstMarketSale();
        const mktSaleData = marketSale.data!;
        mktSaleData.details.V1.fixedSaleDetails.vxfFundsTo = { Anywhere: {} };
        const submitting = h.activateMarketSale(marketSale, {
            mintTokenName: mktSaleData.details.V1.saleAssets.primaryAssetName,
        });
        await expect(submitting).rejects.toThrow(/vxfFundsTo.*must be None|vxfFundsTo.*not.*None/);
    });

    it("rejects activation when vxfTokensTo is Some (none-mode-tokens-to/REQT/88cfkdj7p2)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const marketSale = await h.findFirstMarketSale();
        const mktSaleData = marketSale.data!;
        mktSaleData.details.V1.fixedSaleDetails.vxfTokensTo = { Anywhere: {} };
        const submitting = h.activateMarketSale(marketSale, {
            mintTokenName: mktSaleData.details.V1.saleAssets.primaryAssetName,
        });
        await expect(submitting).rejects.toThrow(/vxfTokensTo.*must be None|vxfTokensTo.*not.*None/);
    });

    // Rework existing paused-update VXF test: reject setting vxfFundsTo to Some
    it("rejects setting vxfFundsTo to Some while Paused (none-mode-paused-funds/REQT/1h49829nsx)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSalePaused();
        const sale = await h.findFirstMarketSale();
        await expect(
            h.updatePausedMarketSale(sale,
                {},  // no editable fields
                { rawUpdate: { details: { V1: { ...sale.data!.details.V1,
                    fixedSaleDetails: { ...sale.data!.details.V1.fixedSaleDetails,
                        vxfFundsTo: { Anywhere: {} },
                    },
                }}}})
        ).rejects.toThrow(/vxfFundsTo.*must be None/);
    });

    // Happy path: funds accumulate to UTxO after selling
    // (consolidate with existing selling tests — assert UTxO value increased by payment)
    it("accumulates funds to sale UTxO during selling (funds-accumulate/REQT/wh3kjtwmj9)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSaleActivated();
        const saleBefore = await h.findFirstMarketSale();
        const valueBefore = saleBefore.utxo.value;
        // TODO: advance time past maturity window, buy 1 lot
        // const saleAfter = await h.findFirstMarketSale();
        // expect lovelace increased by lot price
    });
});

// === Phase 2: WithdrawingProceeds ===

describe("WithdrawingProceeds (REQT/adazrztjma)", () => {
    // Happy path: withdraw ADA while Paused
    it("allows gov authority to withdraw ADA while Paused (withdraw-paused/REQT/ayvw26q6av)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: activate, sell some lots (accumulate funds), pause
        // await h.snapToFirstMarketSalePaused(); // but with accumulated funds
        // const sale = await h.findFirstMarketSale();
        // TODO: h.withdrawProceeds(sale, amount?)
        // verify ADA decreased, tokens unchanged, datum unchanged
    });

    // Happy path: withdraw while Retired
    it("allows gov authority to withdraw ADA while Retired (withdraw-retired/REQT/ayvw26q6av)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSaleRetired();
        const sale = await h.findFirstMarketSale();
        // TODO: h.withdrawProceeds(sale)
        // verify ADA decreased, tokens unchanged, datum unchanged
    });

    // Negative: reject while Active
    it("rejects withdrawal while Active (withdraw-active-rejected/REQT/ayvw26q6av)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSaleActivated();
        const sale = await h.findFirstMarketSale();
        // TODO: h.withdrawProceeds(sale) — expect rejection
        await expect(
            "TODO: withdrawProceeds call"
        ).rejects.toThrow(/Paused.*SoldOut.*Retired|not.*valid.*state/);
    });

    // Negative: reject while Pending
    it("rejects withdrawal while Pending (withdraw-pending-rejected/REQT/ayvw26q6av)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: h.withdrawProceeds(sale) — expect rejection
    });

    // Verify tokens remain locked
    it("preserves non-ADA tokens after withdrawal (withdraw-tokens-locked/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        // consolidate with withdraw-paused happy path — assert token assets unchanged
    });

    // Verify datum unchanged
    it("leaves datum unchanged after withdrawal (withdraw-datum-unchanged/REQT/ykqx9qgh88)", async (context: STOK_TC) => {
        // consolidate with withdraw-paused happy path — assert datum equals before
    });
});
```

**Notes on sketch**:
- Funds-accumulate test can consolidate with existing selling happy-path tests (one txn, multiple assertions)
- WithdrawingProceeds happy-path tests (tokens locked + datum unchanged) consolidate into the Paused withdrawal test — one transaction, multiple read-only assertions
- SoldOut withdrawal not sketched — state transition not implemented (REQT/0nnrndkzy2 FUTURE)
- New helper needed: `h.withdrawProceeds(sale, amount?)` — Coder fills in during implementation

## Worker Report

### Offchain Coder (freya) — 2026-02-20

**Status**: Complete (blocked on on-chain enum variant for type-check)

#### Changes

| File | Change | REQTs |
|------|--------|-------|
| `src/MarketSale/MarketSaleController.ts` | Changed `exampleData()` default `vxfFundsTo` from `{ Anywhere: {} }` to `undefined` | REQT/1h49829nsx |
| `src/MarketSale/MarketSaleController.ts` | Added `mkTxnWithdrawProceeds()` dAPI method | REQT/adazrztjma, czp1jhqgdj, ayvw26q6av, ykqx9qgh88, 5r79v9b4ht |

#### Design Decisions (resolved during interactive implementation)

| Topic | Resolution |
|-------|------------|
| VXF default fix | Single-line change in `exampleData()` — the choke point for all creation defaults. `vxfTokensTo` was already `undefined`. |
| Transaction shape | Uses `mkTxnUpdateRecord` with empty `updatedFields` and negative `addedUtxoValue` — reuses the standard framework path rather than hand-building. |
| Withdrawal amount | Required `bigint` parameter (lovelace). No magic defaults, no min-UTxO guessing. Caller specifies exactly. |
| Pre-flight validation | State check gated on `!environment.isTest` — Paused, SoldOut, or Retired only. Matches sibling method pattern. |
| Method signature | Positional params matching sibling methods: `(mktSale, withdrawalAmount, tcx?)`. No options bag. |

#### Blockers

| Issue | Owner | Resolution |
|-------|-------|------------|
| `WithdrawingProceeds` enum variant not yet in on-chain SpendingActivity | osiris | `this.activity.SpendingActivities.WithdrawingProceeds(...)` will be a type error until the on-chain enum is added and bridge is regenerated via `pnpm build` |

#### Code Whisperer (cwispy) — inline advisory

Zero structural findings. Confirmed: `exampleData()` is the single choke point for VXF defaults; `mkTxnUpdateRecord` is the correct abstraction for withdrawal (no hand-built transaction); method signature follows sibling pattern consistently.

### Onchain Coder (osiris) — 2026-02-20

**Status**: In progress

#### Topics Resolved

| # | Topic | Resolution | Commit |
|---|-------|------------|--------|
| 1 | Add `WithdrawingProceeds` to SpendingActivity enum | Added at explicit tag 51. Also added explicit tags: `Retiring` (65), `SoldOut` (86) for stable encoding. | b077263 |
| 2 | WithdrawingProceeds handler in `additionalDelegateValidation` | Full handler: state gate via switch (Paused/SoldOut/Retired), non-ADA tokens unchanged, datum unchanged via Data equality, gov authority. REQT traceability for ayvw26q6av, gy6jd9cjkg, ykqx9qgh88, aexkjfxm2k; 5r79v9b4ht by absence of ADA constraint. | b077263 |
| 3-5 | VXF None-mode in validateActivating, validateCommonUpdateChecks, Resuming | Added `requireVxfFieldsNone()` on FixedSaleDetailsV1 — single bREQTgroup with REQT-1h49829nsx,88cfkdj7p2. Replaces 6 inline VXF checks across 3 call sites. Supersedes REQT-x3xkgwp94t, d67c29t29w, g563tb3ks1, 0sa1x0aj4z. | f2a9446 |
| 6 | REQT for funds accumulation in SellingTokens | Added requireVxfFieldsNone() in SellingTokens. Updated TODO for VXF future routing. Comment annotation for REQT-wh3kjtwmj9. | — |
| 7 | REQT-nnxpz49srs (tokens sent to buyer) | Comment annotation — enforced by absence of routing constraint. | — |

#### Remaining Topics

| # | Topic | Status |
|---|-------|--------|
| 3 | VXF None-mode in `validateActivating` | Done |
| 4 | VXF None-mode in `validateCommonUpdateChecks` | Done |
| 5 | VXF None-mode in Resuming | Done |
| 6 | REQT traceability for funds accumulation in SellingTokens | Done |
| 7 | REQT-nnxpz49srs (tokens sent to buyer) annotation | Done |
