# Work Unit: p7k2m9x4q6

**Title**: Non-ADA Pricing: CostToken Enum & Pricing Abstraction
**Created**: 2026-02-24
**Source**: ad-hoc
**Status**: Created

> **Required context**: Load [work-planner.SKILL.md](../../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder, Offchain Coder, Stellar Testing
**ARCH Items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model
**REQT Items**:

New requirements (Area 14: Cost Token Denomination):
 - REQT/90fsr7px0z (Cost Token Denomination) — top-level
 - REQT/nb3v1zg4fv (CostToken Enum Definition) — enum with ADA and Other variants
 - REQT/j7cf4ew85g (ADA Variant) — implicit scale=6, no fields
 - REQT/y5gge63n84 (Other Variant) — mph, tokenName, scale fields
 - REQT/4zkj5q4n38 (CostToken in Settings) — costToken field in DynamicSaleV1Settings

Evolved requirements:
 - REQT/gy6jd9cjkg (Tokens Must Remain) — evolved: only cost token may be withdrawn; sale tokens + UUT must remain
 - REQT/5r79v9b4ht (No Constraint on Withdrawal Amount) — evolved: "ADA" → "cost token"

Implementation-only changes (requirements already token-agnostic):
 - REQT/jdkhmeg463 (Payment Matches Pricing Strategy) — `isRightPayment()` must use costToken helpers
 - REQT/hk93w5zb16 (UTxO Token Assets Unchanged) — sufficient as-is; state-only transitions don't move proceeds
 - REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p (Stopping/Resuming/Retiring UTxO checks) — reference hk93w5zb16, no change needed

## Problem / Context

The MarketSale pricing system is currently hardcoded to ADA throughout. On-chain, `DynamicSaleV1.isRightPayment()` uses `get_lovelace()` and divides by `1_000_000.0` to convert between Value and Real. Off-chain, the controller has already been refactored (commits since a101b) to use `costTokenScale()`, `mkCostTokenValue()`, `costTokenAmount()`, and `costTokenIsADA()` — abstracting the cost token denomination. The on-chain code must now follow suit.

### What needs to change

**1. Data model — CostToken enum:**

Add a `CostToken` enum to the on-chain data model:
```
enum CostToken {
    ADA                                    // implicit scale=6
    Other { mph, tokenName, scale: Int }   // e.g. scale=6 for USDC
}
```
With helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`.

This enum is added to `DynamicSaleV1Settings` as a new field `costToken: CostToken`, defaulting to `ADA`.

**2. Pricing validation — `isRightPayment()`:**

`DynamicSaleV1.isRightPayment()` currently:
- Extracts price via `lotPrice.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Extracts payment via `payment.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Asserts `payment.get_assets().is_zero()` — rejects any non-ADA assets

Must change to use `costToken` helpers for extraction and scale, and adjust the asset check to be cost-token-aware.

**3. Lifecycle transition checks — ADA tolerance vs. cost-token proceeds:**

Stopping, Resuming, and Retiring currently check:
```
UTxO token assets (non-ADA) unchanged
ADA within 1 ADA tolerance (for minUtxo shifts)
```

When the cost token is non-ADA, accumulated sale proceeds ARE non-ADA tokens. The current "non-ADA tokens unchanged" check would block legitimate proceeds accumulation or prevent withdrawal. These checks must distinguish between:
- **Sale tokens** (the tokens being sold — always stay locked)
- **Cost tokens** (the payment token — proceeds accumulate, can be withdrawn)
- **ADA** (always present for minUtxo — may shift within tolerance)

**4. WithdrawingProceeds — cost-token awareness:**

Currently checks "non-ADA tokens must remain in UTxO." When cost token is non-ADA, the proceeds to withdraw ARE non-ADA tokens. Must distinguish between sale tokens (must remain) and cost tokens (may be withdrawn).

### What does NOT change

- The pricing algorithm itself (`lotPriceForSale`, `pricingFactorOverallProgress`, `pricingFactorDynamicPace`, `nextSalePace`) — these operate on `Real` values in abstract units and are already token-agnostic
- Time calculations (`elapsedSaleHours`, `DTS_PurchaseInfo::create` hour math) — `1_000_000` there is Duration arithmetic, not pricing
- Sale creation, activation, token management flows — structurally unchanged
- VXF None-mode enforcement — unaffected

### Off-chain status

The offchain controller (`MarketSaleController.ts`) has already been refactored with:
- `costTokenScale(mktSale)` — returns 6 (ADA), future: reads from sale data
- `costTokenIsADA(mktSale)` — returns true, future: checks costToken enum
- `mkCostTokenValue(mktSale, amount)` — `makeValue(amount)` for ADA, future: token Value
- `costTokenAmount(mktSale, v)` — `v.lovelace` for ADA, future: token quantity
- `salePricePerLot()` and `computeLotsForPurchase()` — use above helpers
- `mkTxnBuyFromMarketSale()` — uses `costTokenAmount` for payment predicate

These offchain stubs are ready to read the `costToken` field from on-chain data once the enum lands.

## Focus Files

- `src/MarketSale/DynamicSaleV1Settings.hl` — add CostToken enum, add costToken field to settings struct
- `src/MarketSale/DynamicSaleV1.hl` — refactor `isRightPayment()` to use costToken helpers
- `src/MarketSale/MarketSalePolicy.hl` — update lifecycle transition checks (Stopping, Resuming, Retiring, WithdrawingProceeds) for cost-token awareness
- `src/MarketSale/MarketSaleData.hl` — may need `costToken` accessor from settings for use in validation helpers
- `src/MarketSale/MarketSaleController.ts` — offchain stubs already done; will need to read costToken from data once enum lands
- `src/MarketSale/MarketSale.onchain.reqts.jsonl` — requirements source of truth
- `src/MarketSale/MarketSale.onchain.reqts.md` — generated requirements doc

## Plan / Guidance

### Phase 1: CostToken Enum & Data Model

**Onchain** (osiris):
- Define `CostToken` enum in `DynamicSaleV1Settings.hl` with `ADA` and `Other{mph, tokenName, scale}` variants
- Add helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` (checks whether an AssetClass is the cost token)
- Add `costToken: CostToken` field to `DynamicSaleV1Settings`
- Update `validateUpdatedDetails()` to validate costToken bounds (e.g., scale > 0, scale <= 19)

### Phase 2: Pricing Validation Refactor

**Onchain** (osiris):
- Refactor `DynamicSaleV1.isRightPayment()` to use `self.settings.costToken` helpers
- Replace `lotPrice.get_lovelace() / 1_000_000.0` with cost-token-aware extraction
- Replace `payment.get_lovelace() / 1_000_000.0` with cost-token-aware extraction
- Replace `payment.get_assets().is_zero()` with cost-token-aware check

### Phase 3: Lifecycle Transition Checks — No Change Needed

Stopping, Resuming, and Retiring UTxO checks (REQT-03ff0mfddc, 998waf4mz3, dtpwzjqn9p) are sufficient as-is. State-only transitions don't move proceeds, so "non-ADA tokens unchanged" is correct regardless of cost token denomination.

### Phase 4: WithdrawingProceeds Update

**Onchain** (osiris):
- Refactor WithdrawingProceeds "non-ADA tokens must remain" to "sale tokens must remain"
- Allow cost-token withdrawal when costToken is non-ADA
- Datum unchanged check is already cost-token-agnostic (Data equality)

### Phase 5: Offchain Integration

**Offchain** (freya):
- Update `costTokenScale()` to read from sale data's `costToken` field
- Update `costTokenIsADA()` to check `costToken` enum variant
- Update `mkCostTokenValue()` and `costTokenAmount()` for Other variant
- Ensure type bridge regeneration picks up new enum

### Phase 6: Testing

**Tests** (tessa):
- Existing ADA-denominated tests should pass unchanged (CostToken::ADA is default)
- New tests for Other cost token pricing
- Lifecycle transition tests with non-ADA cost token
- WithdrawingProceeds with non-ADA cost token

## Acceptance Criteria

- [ ] `CostToken` enum defined on-chain with `ADA` and `Other` variants (REQT-j7cf4ew85g, y5gge63n84)
- [ ] `costToken` field added to `DynamicSaleV1Settings` with scale validation (REQT-4zkj5q4n38)
- [ ] `isRightPayment()` uses cost-token-aware extraction (no hardcoded `get_lovelace()`)
- [ ] WithdrawingProceeds allows cost-token withdrawal; sale tokens + UUT must remain (REQT-gy6jd9cjkg)
- [ ] Existing ADA-denominated tests pass without modification
- [ ] New requirements traced with REQT* / REQT/ annotations
- [ ] Offchain stubs updated to read costToken from on-chain data

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Approved | 2026-02-24 | Clean pass. Scope well-bounded, requirements coverage verified, design approach aligns with established patterns. Value-level `paidValue == expectedPayment` check confirmed correct for non-ADA via algebraic analysis. |
| Code Whisperer | Approved | 2026-02-24 | Clean pass. Zero structural findings. Code area is clean — CostToken helpers create proper choke point. Suggestion: remove `//TODO: add pricing unit` comment when costToken field lands. |
| Domain-Fit Tester (Stellar Testing) | Approved | 2026-02-24 | Clean pass. Test sketch in Advisory Notes: 10 new test cases across 4 areas (settings validation, non-ADA pricing, non-ADA withdrawal, non-ADA lifecycle). Existing ADA tests serve as regression. |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

## Advisory Notes

### Pre-Work Collaborative Review (2026-02-24) — Clean Pass

#### Requirements Clarity (Work Planner gate)

Verified before review began:
- **Area 14 (5 new REQTs)**: Complete — CostToken enum definition, ADA/Other variants, CostToken in Settings with scale validation bounds (1–19)
- **Evolved REQTs**: REQT/gy6jd9cjkg and REQT/5r79v9b4ht correctly updated to "cost token" from "ADA"
- **Implementation-only REQTs**: REQT/jdkhmeg463 (Payment Matches Pricing Strategy) is already token-agnostic — `lotSellPrice × lotsPurchased` as Value equality works for any denomination. Lifecycle transition checks (REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p) reference REQT/hk93w5zb16 (`get_assets()` equality) which passes because state-only transitions don't move proceeds regardless of cost token type
- **No missing REQTs**: CostToken helper methods (`costTokenScale`, `toCostValue`, `costAmountFromValue`, `isCostToken`) are implementation tools for existing requirements, not separate behavioral needs

#### Architect — zero findings

**Examined and confirmed correct:**
- **Scope boundaries**: Tightly bounded to CostToken data model → pricing validation → WithdrawingProceeds. No sprawl across unrelated concerns
- **ARCH-* items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model — all appropriate for the planned changes. No missing items
- **Design alignment**: CostToken enum in DynamicSaleV1Settings follows the established pattern (enum + helpers on struct). Phase 2 refactoring of `isRightPayment()` preserves the existing validation structure. Phase 4 WithdrawingProceeds change from `get_assets()` equality to sale-token-specific check is the correct approach
- **Requirements coverage**: All behavioral changes have driving REQTs. The `paidValue == expectedPayment` Value-level check in SellingTokens handler works correctly for non-ADA cost tokens because `paidValue = newValue - oldValue + purchasedTokens` algebraically equals `addedUtxoValue` regardless of denomination — the framework controls the UTxO value delta precisely
- **Phase 3 (no change needed) verified**: Lifecycle transition checks use `inputValue.get_assets() == outputValue.get_assets()` — when cost token is non-ADA, accumulated proceeds are non-ADA tokens that stay unchanged during state-only transitions. The check passes correctly

#### Code Whisperer — zero findings

**Examined and confirmed correct:**
- **Scattered heuristics**: `get_lovelace() / 1_000_000.0` appears twice in `isRightPayment()` — the CostToken helpers (`costAmountFromValue`, `costTokenScale`) consolidate this into a single extraction pattern. Clean
- **Data flow choke points**: CostToken enum with helper methods creates a proper choke point for denomination logic. All callers (isRightPayment, WithdrawingProceeds, lifecycle checks) route through the same helpers
- **Implicit coupling to ADA**: Currently scattered across `get_lovelace()` calls and the `1_000_000` magic number. The plan correctly replaces these with explicit CostToken-mediated extraction
- **DRY**: The `//TODO: add pricing unit` comment in `DynamicSaleV1Settings.hl` (line 4) is exactly what `costToken: CostToken` addresses — clean resolution of existing TODO debt
- **Naming schema**: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` — internally consistent naming that describes domain operations, not technical mechanisms
- **`validateCommonUpdateChecks` impact**: The shared validation helper calls `validateUpdatedDetails()` on settings, which needs the new costToken bounds check. This is a natural extension of the existing validation pipeline — no structural risk
- **Testability**: CostToken is a pure data type with pure helper methods — no side effects, no hidden state, directly testable
- **No shotgun surgery risk**: Adding CostToken support touches `isRightPayment()`, `WithdrawingProceeds`, and settings validation — three well-defined, localized change sites. The helper methods prevent future cost-token changes from requiring multi-site edits

One suggestion (Coder's judgment): Remove the `//TODO: add pricing unit` and `// pricingUnit: AssetClass` comments in `DynamicSaleV1Settings.hl` when the `costToken: CostToken` field is added — the TODO is being resolved.

#### Domain-Fit Tester (Stellar Testing) — zero findings

**Examined and confirmed correct:**
- **Existing test coverage**: The current MarketSale test suite covers ADA-denominated selling, lifecycle transitions, VXF None-mode, and WithdrawingProceeds. All existing tests should pass unchanged because CostToken::ADA is the default and preserves current behavior
- **Phase 6 testing bullet points**: Appropriate scope — new tests for Other cost token pricing, lifecycle transitions with non-ADA, and WithdrawingProceeds with non-ADA
- **Snapshot implications**: Adding `costToken` field to `DynamicSaleV1Settings` changes CBOR encoding — existing snapshots will auto-invalidate and rebuild (standard stellar-contracts behavior). The off-chain `exampleData()` needs to provide `costToken: { ADA: {} }` as default

**Test sketch:**

```typescript
// === CostToken Settings Validation (REQT/4zkj5q4n38) ===

describe("CostToken Settings Validation (REQT/4zkj5q4n38)", () => {
    // Happy path: CostToken::ADA is implicit default (existing tests cover this)

    it("rejects CostToken::Other with scale=0 (cost-token-scale-zero/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: use updatePendingMarketSale or rawUpdate to set costToken to Other with scale=0
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("rejects CostToken::Other with scale=20 (cost-token-scale-too-high/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=20
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("accepts CostToken::Other with valid scale (cost-token-scale-valid/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=6, valid mph + tokenName
        // Should succeed
    });
});

// === Non-ADA Pricing (REQT/nb3v1zg4fv) ===

describe("Non-ADA Cost Token Pricing (REQT/nb3v1zg4fv)", () => {
    // Requires: test token ("USDC" mock) created via helper
    // Requires: sale configured with CostToken::Other{mph, tokenName, scale: 6}
    // Requires: sale activated with tokens deposited
    // Requires: buyer has sufficient test USDC to purchase

    it("buys lots with non-ADA cost token at correct price (non-ada-buy/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: advance time past maturity window
        // TODO: buy 1 lot with correct USDC payment
        // verify: sale tokens received by buyer
        // verify: USDC accumulated in sale UTxO
        // verify: ADA unchanged in sale UTxO
    });

    it("rejects buy with wrong token (non-ada-wrong-token/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with FISH instead of USDC
        // await expect(submitting).rejects.toThrow(/cost.*token|payment/);
    });

    it("rejects buy with insufficient cost token (non-ada-insufficient/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with less USDC than lot price
        // await expect(submitting).rejects.toThrow(/payment/);
    });
});

// === WithdrawingProceeds with Non-ADA Cost Token (REQT/gy6jd9cjkg) ===

describe("WithdrawingProceeds Non-ADA (REQT/gy6jd9cjkg)", () => {
    it("withdraws non-ADA cost token while Paused (non-ada-withdraw-paused/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASalePausedWithProceeds()
        //   (activate with non-ADA cost token, sell some lots, stop)
        // TODO: h.withdrawProceeds(sale, amount)
        // verify: USDC decreased in sale UTxO
        // verify: sale tokens unchanged
        // verify: datum unchanged
        // verify: UUT still present
    });

    it("preserves sale tokens after non-ADA withdrawal (non-ada-withdraw-tokens-locked/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        // Consolidate with non-ada-withdraw-paused happy path
        // assert: all sale token asset classes unchanged
        // assert: only cost token decreased
    });
});

// === Lifecycle Transitions with Non-ADA Cost Token (REQT/hk93w5zb16) ===

describe("Lifecycle with Non-ADA Cost Token (REQT/hk93w5zb16)", () => {
    it("stops sale with accumulated non-ADA proceeds (non-ada-stop/REQT/03ff0mfddc)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleWithProceeds() (activated, sold some lots)
        // TODO: h.stopMarketSale(sale)
        // verify: non-ADA cost tokens unchanged (still accumulated)
        // verify: sale tokens unchanged
    });

    it("resumes sale with non-ADA proceeds intact (non-ada-resume/REQT/998waf4mz3)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then resume
        // verify: non-ADA cost tokens still present
        // verify: can sell again after resume
    });

    it("retires sale with non-ADA proceeds locked (non-ada-retire/REQT/dtpwzjqn9p)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then retire
        // verify: non-ADA cost tokens locked (unchanged)
        // verify: sale tokens locked
    });
});
```

**Test count summary:**

| Area | Happy path | Negative | Total |
|------|-----------|----------|-------|
| Settings validation | 1 | 2 | 3 |
| Non-ADA pricing | 1 | 2 | 3 |
| WithdrawingProceeds non-ADA | 1 | 0 | 1 |
| Lifecycle non-ADA | 3 | 0 | 3 |
| **Total** | **6** | **4** | **10** |

**Helper evolution needed:**
- Test USDC token creation (mock cost token with known mph, tokenName, scale=6)
- `snapToFirstNonADASaleActivated` — creates sale with `CostToken::Other`, deposits sale tokens, activates
- `snapToFirstNonADASaleWithProceeds` — parent: above snapshot, buys lots to accumulate non-ADA proceeds
- `snapToFirstNonADASalePausedWithProceeds` — parent: above, stops sale

**Notes:**
- WithdrawingProceeds happy-path test consolidates token-locked and datum-unchanged assertions into one transaction
- Existing ADA-denominated tests serve as regression — no explicit duplication needed
- `non-ada-withdraw-tokens-locked` consolidates with the Paused withdrawal happy path (one txn, multiple assertions)

## Worker Report

_Not yet started._
