# Work Unit: p7k2m9x4q6

**Title**: Non-ADA Pricing: CostToken Enum & Pricing Abstraction
**Created**: 2026-02-24
**Source**: ad-hoc
**Status**: Created

> **Required context**: Load [work-planner.SKILL.md](../../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder, Offchain Coder, Stellar Testing
**ARCH Items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model
**REQT Items**:

New requirements (Area 14: Cost Token Denomination):
 - REQT/90fsr7px0z (Cost Token Denomination) — top-level
 - REQT/nb3v1zg4fv (CostToken Enum Definition) — enum with ADA and Other variants
 - REQT/j7cf4ew85g (ADA Variant) — implicit scale=6, no fields
 - REQT/y5gge63n84 (Other Variant) — mph, tokenName, scale fields
 - REQT/4zkj5q4n38 (CostToken in Settings) — costToken field in DynamicSaleV1Settings

Evolved requirements:
 - REQT/gy6jd9cjkg (Tokens Must Remain) — evolved: only cost token may be withdrawn; sale tokens + UUT must remain
 - REQT/5r79v9b4ht (No Constraint on Withdrawal Amount) — evolved: "ADA" → "cost token"

Implementation-only changes (requirements already token-agnostic):
 - REQT/jdkhmeg463 (Payment Matches Pricing Strategy) — `isRightPayment()` must use costToken helpers
 - REQT/hk93w5zb16 (UTxO Token Assets Unchanged) — sufficient as-is; state-only transitions don't move proceeds
 - REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p (Stopping/Resuming/Retiring UTxO checks) — reference hk93w5zb16, no change needed

## Problem / Context

The MarketSale pricing system is currently hardcoded to ADA throughout. On-chain, `DynamicSaleV1.isRightPayment()` uses `get_lovelace()` and divides by `1_000_000.0` to convert between Value and Real. Off-chain, the controller has already been refactored (commits since a101b) to use `costTokenScale()`, `mkCostTokenValue()`, `costTokenAmount()`, and `costTokenIsADA()` — abstracting the cost token denomination. The on-chain code must now follow suit.

### What needs to change

**1. Data model — CostToken enum:**

Add a `CostToken` enum to the on-chain data model:
```
enum CostToken {
    ADA                                    // implicit scale=6
    Other { mph, tokenName, scale: Int }   // e.g. scale=6 for USDC
}
```
With helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`.

This enum is added to `DynamicSaleV1Settings` as a new field `costToken: CostToken`, defaulting to `ADA`.

**2. Pricing validation — `isRightPayment()`:**

`DynamicSaleV1.isRightPayment()` currently:
- Extracts price via `lotPrice.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Extracts payment via `payment.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Asserts `payment.get_assets().is_zero()` — rejects any non-ADA assets

Must change to use `costToken` helpers for extraction and scale, and adjust the asset check to be cost-token-aware.

**3. Lifecycle transition checks — ADA tolerance vs. cost-token proceeds:**

Stopping, Resuming, and Retiring currently check:
```
UTxO token assets (non-ADA) unchanged
ADA within 1 ADA tolerance (for minUtxo shifts)
```

When the cost token is non-ADA, accumulated sale proceeds ARE non-ADA tokens. The current "non-ADA tokens unchanged" check would block legitimate proceeds accumulation or prevent withdrawal. These checks must distinguish between:
- **Sale tokens** (the tokens being sold — always stay locked)
- **Cost tokens** (the payment token — proceeds accumulate, can be withdrawn)
- **ADA** (always present for minUtxo — may shift within tolerance)

**4. WithdrawingProceeds — cost-token awareness:**

Currently checks "non-ADA tokens must remain in UTxO." When cost token is non-ADA, the proceeds to withdraw ARE non-ADA tokens. Must distinguish between sale tokens (must remain) and cost tokens (may be withdrawn).

### What does NOT change

- The pricing algorithm itself (`lotPriceForSale`, `pricingFactorOverallProgress`, `pricingFactorDynamicPace`, `nextSalePace`) — these operate on `Real` values in abstract units and are already token-agnostic
- Time calculations (`elapsedSaleHours`, `DTS_PurchaseInfo::create` hour math) — `1_000_000` there is Duration arithmetic, not pricing
- Sale creation, activation, token management flows — structurally unchanged
- VXF None-mode enforcement — unaffected

### Off-chain status

The offchain controller (`MarketSaleController.ts`) has already been refactored with:
- `costTokenScale(mktSale)` — returns 6 (ADA), future: reads from sale data
- `costTokenIsADA(mktSale)` — returns true, future: checks costToken enum
- `mkCostTokenValue(mktSale, amount)` — `makeValue(amount)` for ADA, future: token Value
- `costTokenAmount(mktSale, v)` — `v.lovelace` for ADA, future: token quantity
- `salePricePerLot()` and `computeLotsForPurchase()` — use above helpers
- `mkTxnBuyFromMarketSale()` — uses `costTokenAmount` for payment predicate

These offchain stubs are ready to read the `costToken` field from on-chain data once the enum lands.

## Focus Files

- `src/MarketSale/DynamicSaleV1Settings.hl` — add CostToken enum, add costToken field to settings struct
- `src/MarketSale/DynamicSaleV1.hl` — refactor `isRightPayment()` to use costToken helpers
- `src/MarketSale/MarketSalePolicy.hl` — update lifecycle transition checks (Stopping, Resuming, Retiring, WithdrawingProceeds) for cost-token awareness
- `src/MarketSale/MarketSaleData.hl` — may need `costToken` accessor from settings for use in validation helpers
- `src/MarketSale/MarketSaleController.ts` — offchain stubs already done; will need to read costToken from data once enum lands
- `src/MarketSale/MarketSale.onchain.reqts.jsonl` — requirements source of truth
- `src/MarketSale/MarketSale.onchain.reqts.md` — generated requirements doc

## Plan / Guidance

### Phase 1: CostToken Enum & Data Model

**Onchain** (osiris):
- Define `CostToken` enum in `DynamicSaleV1Settings.hl` with `ADA` and `Other{mph, tokenName, scale}` variants
- Add helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` (checks whether an AssetClass is the cost token)
- Add `costToken: CostToken` field to `DynamicSaleV1Settings`
- Update `validateUpdatedDetails()` to validate costToken bounds (e.g., scale > 0, scale <= 19)

### Phase 2: Pricing Validation Refactor

**Onchain** (osiris):
- Refactor `DynamicSaleV1.isRightPayment()` to use `self.settings.costToken` helpers
- Replace `lotPrice.get_lovelace() / 1_000_000.0` with cost-token-aware extraction
- Replace `payment.get_lovelace() / 1_000_000.0` with cost-token-aware extraction
- Replace `payment.get_assets().is_zero()` with cost-token-aware check

### Phase 3: Lifecycle Transition Checks — No Change Needed

Stopping, Resuming, and Retiring UTxO checks (REQT-03ff0mfddc, 998waf4mz3, dtpwzjqn9p) are sufficient as-is. State-only transitions don't move proceeds, so "non-ADA tokens unchanged" is correct regardless of cost token denomination.

### Phase 4: WithdrawingProceeds Update

**Onchain** (osiris):
- Refactor WithdrawingProceeds "non-ADA tokens must remain" to "sale tokens must remain"
- Allow cost-token withdrawal when costToken is non-ADA
- Datum unchanged check is already cost-token-agnostic (Data equality)

### Phase 5: Offchain Integration

**Offchain** (freya):
- Update `costTokenScale()` to read from sale data's `costToken` field
- Update `costTokenIsADA()` to check `costToken` enum variant
- Update `mkCostTokenValue()` and `costTokenAmount()` for Other variant
- Ensure type bridge regeneration picks up new enum

### Phase 6: Testing

**Tests** (tessa):
- Existing ADA-denominated tests should pass unchanged (CostToken::ADA is default)
- New tests for Other cost token pricing
- Lifecycle transition tests with non-ADA cost token
- WithdrawingProceeds with non-ADA cost token

## Acceptance Criteria

- [ ] `CostToken` enum defined on-chain with `ADA` and `Other` variants (REQT-j7cf4ew85g, y5gge63n84)
- [ ] `costToken` field added to `DynamicSaleV1Settings` with scale validation (REQT-4zkj5q4n38)
- [ ] `isRightPayment()` uses cost-token-aware extraction (no hardcoded `get_lovelace()`)
- [ ] WithdrawingProceeds allows cost-token withdrawal; sale tokens + UUT must remain (REQT-gy6jd9cjkg)
- [ ] Existing ADA-denominated tests pass without modification
- [ ] New requirements traced with REQT* / REQT/ annotations
- [ ] Offchain stubs updated to read costToken from on-chain data

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | Findings surfaced — see Advisory Notes |
| Code Whisperer | Pending | — | Findings surfaced — see Advisory Notes |
| Domain-Fit Tester (Stellar Testing) | Pending | — | Findings surfaced — see Advisory Notes |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | — | — |
| Code Whisperer | Pending | — | — |
| Domain-Fit Tester (Stellar Testing) | Pending | — | — |

## Advisory Notes

### Pre-Work Collaborative Review (2026-02-24)

#### Requirements Clarity (Work Planner gate)

Verified before review began:
- **Area 14 (5 new REQTs)**: Complete — CostToken enum definition, ADA/Other variants, CostToken in Settings with scale validation bounds (1–19)
- **Evolved REQTs**: REQT/gy6jd9cjkg and REQT/5r79v9b4ht correctly updated to "cost token" from "ADA"
- **Implementation-only REQTs**: REQT/jdkhmeg463 (Payment Matches Pricing Strategy) is already token-agnostic — `lotSellPrice × lotsPurchased` as Value equality works for any denomination. Lifecycle transition checks (REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p) reference REQT/hk93w5zb16 (`get_assets()` equality) which passes because state-only transitions don't move proceeds regardless of cost token type
- **No missing REQTs**: CostToken helper methods (`costTokenScale`, `toCostValue`, `costAmountFromValue`, `isCostToken`) are implementation tools for existing requirements, not separate behavioral needs

#### Architect — examined areas

**Examined:**
- **Scope boundaries**: Tightly bounded to CostToken data model → pricing validation → WithdrawingProceeds. No sprawl across unrelated concerns
- **ARCH-* items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model — all appropriate for the planned changes. No missing items
- **Design alignment**: CostToken enum in DynamicSaleV1Settings follows the established pattern (enum + helpers on struct). Phase 2 refactoring of `isRightPayment()` preserves the existing validation structure. Phase 4 WithdrawingProceeds change from `get_assets()` equality to sale-token-specific check is the correct approach
- **Requirements coverage**: All behavioral changes have driving REQTs. The `paidValue == expectedPayment` Value-level check in SellingTokens handler works correctly for non-ADA cost tokens because `paidValue = newValue - oldValue + purchasedTokens` algebraically equals `addedUtxoValue` regardless of denomination — the framework controls the UTxO value delta precisely
- **Phase 3 (no change needed) verified**: Lifecycle transition checks use `inputValue.get_assets() == outputValue.get_assets()` — when cost token is non-ADA, accumulated proceeds are non-ADA tokens that stay unchanged during state-only transitions. The check passes correctly

#### Code Whisperer — examined areas

**Examined:**
- **Scattered heuristics**: `get_lovelace() / 1_000_000.0` appears twice in `isRightPayment()` — the CostToken helpers (`costAmountFromValue`, `costTokenScale`) consolidate this into a single extraction pattern. Clean
- **Data flow choke points**: CostToken enum with helper methods creates a proper choke point for denomination logic. All callers (isRightPayment, WithdrawingProceeds, lifecycle checks) route through the same helpers
- **Implicit coupling to ADA**: Currently scattered across `get_lovelace()` calls and the `1_000_000` magic number. The plan correctly replaces these with explicit CostToken-mediated extraction
- **DRY**: The `//TODO: add pricing unit` comment in `DynamicSaleV1Settings.hl` (line 4) is exactly what `costToken: CostToken` addresses — clean resolution of existing TODO debt
- **Naming schema**: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` — internally consistent naming that describes domain operations, not technical mechanisms
- **`validateCommonUpdateChecks` impact**: The shared validation helper calls `validateUpdatedDetails()` on settings, which needs the new costToken bounds check. This is a natural extension of the existing validation pipeline — no structural risk
- **Testability**: CostToken is a pure data type with pure helper methods — no side effects, no hidden state, directly testable
- **No shotgun surgery risk**: Adding CostToken support touches `isRightPayment()`, `WithdrawingProceeds`, and settings validation — three well-defined, localized change sites. The helper methods prevent future cost-token changes from requiring multi-site edits

One suggestion (Coder's judgment): Remove the `//TODO: add pricing unit` and `// pricingUnit: AssetClass` comments in `DynamicSaleV1Settings.hl` when the `costToken: CostToken` field is added — the TODO is being resolved.

#### Findings

##### Finding F1: Plan doesn't address the redeemer-payment Value-level match check in SellingTokens handler

**Severity**: Concern
**Reviewer**: Architect

The SellingTokens handler in `MarketSalePolicy.hl` has TWO separate payment checks:

1. **Value-level redeemer match** (~line 563): `paidValue == expectedPayment` where `expectedPayment = lotSellPrice * lotsPurchased` — this is exact Value equality
2. **Real-level pricing validation**: `pricingStrategy.isRightPayment(lotSellPrice, paidValue)` — this verifies price correctness with tolerance

The plan (Phase 2) explicitly covers refactoring `isRightPayment()` in `DynamicSaleV1.hl` but does not mention the Value-level check in `MarketSalePolicy.hl`. For non-ADA cost tokens, the algebraic analysis suggests `paidValue` should equal `addedUtxoValue` exactly (because `newValue - oldValue + purchasedTokens = addedUtxoValue`), which means the check works IF the framework precisely controls the UTxO delta. But this relies on an assumption about framework behavior that isn't stated in the plan and isn't verified by any test.

**Ask**: Should the plan explicitly address this check? Should a test verify the assumption that `paidValue == addedUtxoValue` holds for non-ADA cost tokens?

##### Finding F2: MinUtxo creep for non-ADA cost token sales — operational risk unacknowledged

**Severity**: Concern
**Reviewer**: Architect

For ADA-denominated sales, every purchase adds ADA to the sale UTxO, naturally covering any minUtxo increases from datum CBOR growth (progress details, pace, timestamps change each sale).

For non-ADA cost token sales, the buyer pays in the cost token — **no ADA is added to the sale UTxO during purchases**. If datum growth increases minUtxo over time, the sale UTxO's fixed ADA may eventually be insufficient, causing transaction failures at the Cardano node level. The UTxO's initial ADA deposit must be large enough to absorb ALL possible minUtxo increases across the entire sale lifecycle.

The work unit's Problem/Context and Plan sections don't acknowledge this operational constraint. Front-end and admin guidance may be needed (similar to the "keep pauses short" advisory from the pause-stop work unit).

**Ask**: Should the work unit acknowledge this and add front-end/admin advisory guidance? Should there be an acceptance criterion or REQT for minimum initial ADA deposit when using non-ADA cost tokens?

##### Finding F3: Missing REQT for "payment must be in the designated cost token"

**Severity**: Concern
**Reviewer**: Architect

Currently, `isRightPayment()` has `assert(payment.get_assets().is_zero(), "non-ADA assets not yet supported here")` which implicitly requires ADA payment. There is no explicit REQT for this — it's an implementation guard.

After the CostToken change, the guard is replaced with a "cost-token-aware check" (per the plan). But what behavioral requirement drives this check? The check ensures buyers can't pay with arbitrary tokens — only the designated cost token is accepted. This is a real enforcement behavior but has no driving REQT.

REQT/jdkhmeg463 says "payment matches pricing strategy" (amount correctness). REQT/nb3v1zg4fv says "identifies which token buyers pay with" (enum definition). Neither explicitly says "SellingTokens MUST reject payment in any token other than the designated cost token."

**Ask**: Should there be a REQT explicitly requiring payment denomination enforcement? Or is this adequately covered by the combination of existing REQTs?

##### Finding F4: `assert(payment.get_assets().is_zero())` removal is a behavioral change but REQT-jdkhmeg463 stays at COMPLETED

**Severity**: Concern
**Reviewer**: Architect

Currently, any attempt to buy with non-ADA tokens is rejected on-chain by `assert(payment.get_assets().is_zero())`. After this work unit, non-ADA cost token payments ARE accepted (when the sale is configured for that cost token). This is a behavioral change at the on-chain policy level.

The work unit categorizes REQT/jdkhmeg463 (Payment Matches Pricing Strategy) as "Implementation-only changes (requirements already token-agnostic)" and leaves it at COMPLETED. But the observable behavior of the SellingTokens activity changes: it goes from "rejects all non-ADA payment" to "accepts designated non-ADA cost token payment."

The Work Planner protocol says "No REQT whose behavior is being modified may remain at COMPLETED when pre-work exits."

**Ask**: Does REQT/jdkhmeg463 need status transition? Or is the behavioral change driven entirely by the new Area 14 REQTs (making jdkhmeg463 truly unchanged)?

##### Finding F5: Problem/Context section conflates "proceeds accumulation" and "proceeds withdrawal"

**Severity**: Suggestion
**Reviewer**: Architect

Problem/Context section 3 says: "When the cost token is non-ADA, accumulated sale proceeds ARE non-ADA tokens. The current 'non-ADA tokens unchanged' check would block legitimate proceeds accumulation or prevent withdrawal."

"Block legitimate proceeds accumulation" is misleading — the SellingTokens handler doesn't have a "non-ADA unchanged" check, so accumulation is never blocked. The issue is only with WithdrawingProceeds (and potentially lifecycle transitions). This could confuse the coder about which code paths actually need changes.

**Ask**: Should the wording be corrected to say "prevent withdrawal" only?

##### Finding F6: Plan Phase 4 says "sale tokens must remain" but doesn't define "sale tokens" or the check mechanism

**Severity**: Concern
**Reviewer**: Code Whisperer

Phase 4 says: "Refactor WithdrawingProceeds 'non-ADA tokens must remain' to 'sale tokens must remain'." The plan mentions `isCostToken(ac)` as a helper, but doesn't specify how the check works:

- Does it iterate over all asset classes in the UTxO and verify non-cost-token assets are unchanged?
- Does it check specific known sale token asset classes from `saleLotAssets`?
- How does it handle the UUT (which is neither a sale token nor a cost token)?

The current check is a simple one-liner (`inputAssets == outputAssets`). The replacement needs to be more nuanced. Without guidance, the coder may implement an approach that misses edge cases.

**Ask**: Should the plan specify the check approach? At minimum: "for each AssetClass in input that is NOT the cost token (per `isCostToken(ac)`), verify output has the same amount. UUT is handled by the framework's `mustOutputDelegatedData`."

##### Finding F7: `isRightPayment` "cost-token-aware check" for the asset assertion is underspecified

**Severity**: Concern
**Reviewer**: Code Whisperer

Phase 2 says "Replace `payment.get_assets().is_zero()` with cost-token-aware check" but doesn't specify what that check looks like for each variant:

- **ADA cost token**: `payment.get_assets().is_zero()` (same as current — only ADA in payment)
- **Other cost token**: What exactly? "Payment should contain ONLY the cost token"? But `paidValue` is a Value delta — does it ever contain unexpected assets?

The two variants need different enforcement logic. Without specification, the coder may write something that passes tests but has a logical gap.

**Ask**: Should the plan specify the per-variant check? Or is this implementation detail the coder should work out during the interview?

##### Finding F8: `paidValue == expectedPayment` depends on framework behavior that could change

**Severity**: Concern
**Reviewer**: Code Whisperer

The algebraic analysis showing `paidValue == addedUtxoValue` depends on the framework's `mkTxnUpdateRecord` adding EXACTLY `addedUtxoValue` to the UTxO — no more, no less ADA for minUtxo adjustment. If the framework ever changes to auto-pad ADA for minUtxo, this check breaks for non-ADA cost tokens (paidValue would include unexpected ADA).

This is an implicit coupling between the on-chain policy's exact Value equality check and the off-chain framework's transaction construction behavior. Currently there's no documentation or test that makes this coupling explicit.

**Ask**: Should a test explicitly verify that `paidValue == addedUtxoValue` for non-ADA cost tokens? Should this assumption be documented in the plan as a design constraint?

##### Finding F9: Existing ADA tests may break from struct layout change — not called out in plan

**Severity**: Suggestion
**Reviewer**: Domain-Fit Tester (Stellar Testing)

Adding `costToken: CostToken` to `DynamicSaleV1Settings` changes the struct's CBOR encoding. All existing cached test snapshots will need to be invalidated and rebuilt. The off-chain `exampleData()` in `MarketSaleController.ts` must provide the new field with a default (`{ ADA: {} }`).

The work unit says "Existing ADA-denominated tests should pass unchanged (CostToken::ADA is default)" but doesn't mention the snapshot invalidation or the `exampleData()` update needed to make this true.

**Ask**: Should the plan explicitly note that snapshot invalidation and `exampleData()` update are prerequisites for existing tests to pass?

#### Domain-Fit Tester (Stellar Testing) — examined areas

**Examined:**
- **Existing test coverage**: The current MarketSale test suite covers ADA-denominated selling, lifecycle transitions, VXF None-mode, and WithdrawingProceeds. All existing tests should pass unchanged because CostToken::ADA is the default and preserves current behavior
- **Phase 6 testing bullet points**: Appropriate scope — new tests for Other cost token pricing, lifecycle transitions with non-ADA, and WithdrawingProceeds with non-ADA
- **Snapshot implications**: Adding `costToken` field to `DynamicSaleV1Settings` changes CBOR encoding — existing snapshots will auto-invalidate and rebuild (standard stellar-contracts behavior). The off-chain `exampleData()` needs to provide `costToken: { ADA: {} }` as default

**Test sketch:**

```typescript
// === CostToken Settings Validation (REQT/4zkj5q4n38) ===

describe("CostToken Settings Validation (REQT/4zkj5q4n38)", () => {
    // Happy path: CostToken::ADA is implicit default (existing tests cover this)

    it("rejects CostToken::Other with scale=0 (cost-token-scale-zero/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: use updatePendingMarketSale or rawUpdate to set costToken to Other with scale=0
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("rejects CostToken::Other with scale=20 (cost-token-scale-too-high/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=20
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("accepts CostToken::Other with valid scale (cost-token-scale-valid/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=6, valid mph + tokenName
        // Should succeed
    });
});

// === Non-ADA Pricing (REQT/nb3v1zg4fv) ===

describe("Non-ADA Cost Token Pricing (REQT/nb3v1zg4fv)", () => {
    // Requires: test token ("USDC" mock) created via helper
    // Requires: sale configured with CostToken::Other{mph, tokenName, scale: 6}
    // Requires: sale activated with tokens deposited
    // Requires: buyer has sufficient test USDC to purchase

    it("buys lots with non-ADA cost token at correct price (non-ada-buy/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: advance time past maturity window
        // TODO: buy 1 lot with correct USDC payment
        // verify: sale tokens received by buyer
        // verify: USDC accumulated in sale UTxO
        // verify: ADA unchanged in sale UTxO
    });

    it("rejects buy with wrong token (non-ada-wrong-token/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with FISH instead of USDC
        // await expect(submitting).rejects.toThrow(/cost.*token|payment/);
    });

    it("rejects buy with insufficient cost token (non-ada-insufficient/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with less USDC than lot price
        // await expect(submitting).rejects.toThrow(/payment/);
    });
});

// === WithdrawingProceeds with Non-ADA Cost Token (REQT/gy6jd9cjkg) ===

describe("WithdrawingProceeds Non-ADA (REQT/gy6jd9cjkg)", () => {
    it("withdraws non-ADA cost token while Paused (non-ada-withdraw-paused/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASalePausedWithProceeds()
        //   (activate with non-ADA cost token, sell some lots, stop)
        // TODO: h.withdrawProceeds(sale, amount)
        // verify: USDC decreased in sale UTxO
        // verify: sale tokens unchanged
        // verify: datum unchanged
        // verify: UUT still present
    });

    it("preserves sale tokens after non-ADA withdrawal (non-ada-withdraw-tokens-locked/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        // Consolidate with non-ada-withdraw-paused happy path
        // assert: all sale token asset classes unchanged
        // assert: only cost token decreased
    });
});

// === Lifecycle Transitions with Non-ADA Cost Token (REQT/hk93w5zb16) ===

describe("Lifecycle with Non-ADA Cost Token (REQT/hk93w5zb16)", () => {
    it("stops sale with accumulated non-ADA proceeds (non-ada-stop/REQT/03ff0mfddc)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleWithProceeds() (activated, sold some lots)
        // TODO: h.stopMarketSale(sale)
        // verify: non-ADA cost tokens unchanged (still accumulated)
        // verify: sale tokens unchanged
    });

    it("resumes sale with non-ADA proceeds intact (non-ada-resume/REQT/998waf4mz3)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then resume
        // verify: non-ADA cost tokens still present
        // verify: can sell again after resume
    });

    it("retires sale with non-ADA proceeds locked (non-ada-retire/REQT/dtpwzjqn9p)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then retire
        // verify: non-ADA cost tokens locked (unchanged)
        // verify: sale tokens locked
    });
});
```

**Test count summary:**

| Area | Happy path | Negative | Total |
|------|-----------|----------|-------|
| Settings validation | 1 | 2 | 3 |
| Non-ADA pricing | 1 | 2 | 3 |
| WithdrawingProceeds non-ADA | 1 | 0 | 1 |
| Lifecycle non-ADA | 3 | 0 | 3 |
| **Total** | **6** | **4** | **10** |

**Helper evolution needed:**
- Test USDC token creation (mock cost token with known mph, tokenName, scale=6)
- `snapToFirstNonADASaleActivated` — creates sale with `CostToken::Other`, deposits sale tokens, activates
- `snapToFirstNonADASaleWithProceeds` — parent: above snapshot, buys lots to accumulate non-ADA proceeds
- `snapToFirstNonADASalePausedWithProceeds` — parent: above, stops sale

**Notes:**
- WithdrawingProceeds happy-path test consolidates token-locked and datum-unchanged assertions into one transaction
- Existing ADA-denominated tests serve as regression — no explicit duplication needed
- `non-ada-withdraw-tokens-locked` consolidates with the Paused withdrawal happy path (one txn, multiple assertions)

## Worker Report

_Not yet started._
