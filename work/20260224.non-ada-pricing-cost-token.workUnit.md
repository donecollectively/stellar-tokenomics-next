# Work Unit: p7k2m9x4q6

**Title**: Non-ADA Pricing: CostToken Enum & Pricing Abstraction
**Created**: 2026-02-24
**Source**: ad-hoc
**Status**: Created

> **Required context**: Load [work-planner.SKILL.md](../../skillz/work-planner/work-planner.SKILL.md) for lifecycle protocol, team composition, and sign-off procedures before operating on this work unit.

## Scope

**Required Skills**: Onchain Coder, Offchain Coder, Stellar Testing
**ARCH Items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model
**REQT Items**:

New requirements (Area 14: Cost Token Denomination):
 - REQT/90fsr7px0z (Cost Token Denomination) — top-level
 - REQT/nb3v1zg4fv (CostToken Enum Definition) — enum with ADA and Other variants
 - REQT/j7cf4ew85g (ADA Variant) — implicit scale=6, no fields
 - REQT/y5gge63n84 (Other Variant) — mph, tokenName, scale fields
 - REQT/4zkj5q4n38 (CostToken in Settings) — costToken field in DynamicSaleV1Settings

Evolved requirements:
 - REQT/gy6jd9cjkg (Tokens Must Remain) — evolved: only cost token may be withdrawn; sale tokens + UUT must remain
 - REQT/5r79v9b4ht (No Constraint on Withdrawal Amount) — evolved: "ADA" → "cost token"

New requirement (Area 8: Pricing Model Validation):
 - REQT/jxdnb3dxmx (Payment Denomination Enforcement) — reject payment in wrong token; spam/shitcoin protection

Implementation-only changes (requirements already token-agnostic):
 - REQT/jdkhmeg463 (Payment Matches Pricing Strategy) — `isRightPayment()` must use costToken helpers
 - REQT/hk93w5zb16 (UTxO Token Assets Unchanged) — sufficient as-is; state-only transitions don't move proceeds
 - REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p (Stopping/Resuming/Retiring UTxO checks) — reference hk93w5zb16, no change needed

## Problem / Context

The MarketSale pricing system is currently hardcoded to ADA throughout. On-chain, `DynamicSaleV1.isRightPayment()` uses `get_lovelace()` and divides by `1_000_000.0` to convert between Value and Real. Off-chain, the controller has already been refactored (commits since a101b) to use `costTokenScale()`, `mkCostTokenValue()`, `costTokenAmount()`, and `costTokenIsADA()` — abstracting the cost token denomination. The on-chain code must now follow suit.

### What needs to change

**1. Data model — CostToken enum:**

Add a `CostToken` enum to the on-chain data model:
```
enum CostToken {
    ADA                                    // implicit scale=6
    Other { mph, tokenName, scale: Int }   // e.g. scale=6 for USDC
}
```
With helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`.

This enum is added to `DynamicSaleV1Settings` as a new field `costToken: CostToken`, defaulting to `ADA`.

**2. Pricing validation — `isRightPayment()`:**

`DynamicSaleV1.isRightPayment()` currently:
- Extracts price via `lotPrice.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Extracts payment via `payment.get_lovelace() / 1_000_000.0` — hardcoded ADA
- Asserts `payment.get_assets().is_zero()` — rejects any non-ADA assets

Must change to use `costToken` helpers for extraction and scale, and adjust the asset check to be cost-token-aware.

**3. Lifecycle transition checks — ADA tolerance vs. cost-token proceeds:**

Stopping, Resuming, and Retiring currently check:
```
UTxO token assets (non-ADA) unchanged
ADA within 1 ADA tolerance (for minUtxo shifts)
```

When the cost token is non-ADA, accumulated sale proceeds ARE non-ADA tokens. The current "non-ADA tokens unchanged" check would block legitimate proceeds accumulation or prevent withdrawal. These checks must distinguish between:
- **Sale tokens** (the tokens being sold — always stay locked)
- **Cost tokens** (the payment token — proceeds accumulate, can be withdrawn)
- **ADA** (always present for minUtxo — may shift within tolerance)

**4. WithdrawingProceeds — cost-token awareness:**

Currently checks "non-ADA tokens must remain in UTxO." When cost token is non-ADA, the proceeds to withdraw ARE non-ADA tokens. Must distinguish between sale tokens (must remain) and cost tokens (may be withdrawn).

### What does NOT change

- The pricing algorithm itself (`lotPriceForSale`, `pricingFactorOverallProgress`, `pricingFactorDynamicPace`, `nextSalePace`) — these operate on `Real` values in abstract units and are already token-agnostic
- Time calculations (`elapsedSaleHours`, `DTS_PurchaseInfo::create` hour math) — `1_000_000` there is Duration arithmetic, not pricing
- Sale creation, activation, token management flows — structurally unchanged
- VXF None-mode enforcement — unaffected

### Off-chain status

The offchain controller (`MarketSaleController.ts`) has already been refactored with:
- `costTokenScale(mktSale)` — returns 6 (ADA), future: reads from sale data
- `costTokenIsADA(mktSale)` — returns true, future: checks costToken enum
- `mkCostTokenValue(mktSale, amount)` — `makeValue(amount)` for ADA, future: token Value
- `costTokenAmount(mktSale, v)` — `v.lovelace` for ADA, future: token quantity
- `salePricePerLot()` and `computeLotsForPurchase()` — use above helpers
- `mkTxnBuyFromMarketSale()` — uses `costTokenAmount` for payment predicate

These offchain stubs are ready to read the `costToken` field from on-chain data once the enum lands.

## Focus Files

- `src/MarketSale/DynamicSaleV1Settings.hl` — add CostToken enum, add costToken field to settings struct
- `src/MarketSale/DynamicSaleV1.hl` — refactor `isRightPayment()` to use costToken helpers
- `src/MarketSale/MarketSalePolicy.hl` — update lifecycle transition checks (Stopping, Resuming, Retiring, WithdrawingProceeds) for cost-token awareness
- `src/MarketSale/MarketSaleData.hl` — may need `costToken` accessor from settings for use in validation helpers
- `src/MarketSale/MarketSaleController.ts` — offchain stubs already done; will need to read costToken from data once enum lands
- `src/MarketSale/MarketSale.onchain.reqts.jsonl` — requirements source of truth
- `src/MarketSale/MarketSale.onchain.reqts.md` — generated requirements doc

## Plan / Guidance

### Phase 1: CostToken Enum & Data Model

**Onchain** (osiris):
- Define `CostToken` enum in `DynamicSaleV1Settings.hl` with `ADA` and `Other{mph, tokenName, scale}` variants
- Add helper methods: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` (checks whether an AssetClass is the cost token)
- Add `costToken: CostToken` field to `DynamicSaleV1Settings`
- Update `validateUpdatedDetails()` to validate costToken bounds (e.g., scale > 0, scale <= 19)

### Phase 2: Pricing Validation Refactor

**Onchain** (osiris):

Two checks in the SellingTokens flow must become cost-token-aware. Both stay — they serve different purposes:

**Check A — Policy-level redeemer honesty** (`MarketSalePolicy.hl`, SellingTokens handler, `paidValue == expectedPayment`):
- Change from exact Value equality to cost-token-amount comparison: extract the cost token amount from both `paidValue` and `lotSellPrice * lotsPurchased` using `costAmountFromValue()`, compare those
- This isolates the cost-token dimension — ADA variance from minUtxo doesn't pollute the comparison when cost token is non-ADA; when cost token IS ADA, the tolerance in Check B covers minUtxo

**Check B — `DynamicSaleV1.isRightPayment()`** (accessed via `self.settings.costToken`):
- Replace `lotPrice.get_lovelace() / 1_000_000.0` with `costToken.costAmountFromValue(lotPrice)` / scale
- Replace `payment.get_lovelace() / 1_000_000.0` with `costToken.costAmountFromValue(payment)` / scale
- **Spam rejection**: Replace `payment.get_assets().is_zero()` with cost-token-aware check — paidValue's non-ADA assets must be ONLY the cost token (if non-ADA) or zero (if ADA). Rejects shitcoins/spam tokens injected into the sale UTxO output
- **Overpayment tolerance**: Uniform cap of 0.02 cost-token-units overpayment (covers minUtxo ADA shifts when cost token is ADA; practically exact for non-ADA)

### Phase 3: Lifecycle Transition Checks — No Change Needed

Stopping, Resuming, and Retiring UTxO checks (REQT-03ff0mfddc, 998waf4mz3, dtpwzjqn9p) are sufficient as-is. State-only transitions don't move proceeds, so "non-ADA tokens unchanged" is correct regardless of cost token denomination.

### Phase 4: WithdrawingProceeds Update

**Onchain** (osiris):
- Refactor WithdrawingProceeds "non-ADA tokens must remain" to "sale tokens must remain"
- Allow cost-token withdrawal when costToken is non-ADA
- Datum unchanged check is already cost-token-agnostic (Data equality)

### Phase 5: Offchain Integration

**Offchain** (freya):
- Update `costTokenScale()` to read from sale data's `costToken` field
- Update `costTokenIsADA()` to check `costToken` enum variant
- Update `mkCostTokenValue()` and `costTokenAmount()` for Other variant
- Ensure type bridge regeneration picks up new enum

### Phase 6: Testing

**Tests** (tessa):
- Existing ADA-denominated tests should pass unchanged (CostToken::ADA is default)
- New tests for Other cost token pricing
- Lifecycle transition tests with non-ADA cost token
- WithdrawingProceeds with non-ADA cost token

## Acceptance Criteria

- [ ] `CostToken` enum defined on-chain with `ADA` and `Other` variants (REQT-j7cf4ew85g, y5gge63n84)
- [ ] `costToken` field added to `DynamicSaleV1Settings` with scale validation (REQT-4zkj5q4n38)
- [ ] `isRightPayment()` uses cost-token-aware extraction (no hardcoded `get_lovelace()`)
- [ ] Payment denomination enforcement: reject payment in wrong token; spam/shitcoin protection (REQT-jxdnb3dxmx)
- [ ] WithdrawingProceeds allows cost-token withdrawal; sale tokens + UUT must remain (REQT-gy6jd9cjkg)
- [ ] Existing ADA-denominated tests pass without modification
- [ ] New requirements traced with REQT* / REQT/ annotations
- [ ] Offchain stubs updated to read costToken from on-chain data

## Sign-Offs

### Pre-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Approved with Notes | 2026-02-24 | F1: Phase 2 rewritten (both checks, cost-token-aware). F2: minUtxo auto-handled. F3: REQT/jxdnb3dxmx added. F4: jdkhmeg463 stays COMPLETED. F5: withdrawn. |
| Code Whisperer | Approved with Notes | 2026-02-24 | F6: coder interview detail. F7: covered by F1. F8: highlighted for Tessa. |
| Domain-Fit Tester (Stellar Testing) | Approved with Notes | 2026-02-24 | F9: snapshot invalidation automatic. F8 test highlight added to sketch. |

### Post-Work
| Reviewer | Status | Date | Notes / References |
|----------|--------|------|--------------------|
| Architect | Pending | 2026-02-25 | Zero findings — see post-work audit file |
| Code Whisperer | Pending | 2026-02-25 | pw-F1, pw-F2 — see post-work audit file |
| Domain-Fit Tester (Stellar Testing) | Pending | 2026-02-25 | pw-F3 — see post-work audit file |

## Advisory Notes

### Pre-Work Collaborative Review (2026-02-24)

#### Requirements Clarity (Work Planner gate)

Verified before review began:
- **Area 14 (5 new REQTs)**: Complete — CostToken enum definition, ADA/Other variants, CostToken in Settings with scale validation bounds (1–19)
- **Evolved REQTs**: REQT/gy6jd9cjkg and REQT/5r79v9b4ht correctly updated to "cost token" from "ADA"
- **Implementation-only REQTs**: REQT/jdkhmeg463 (Payment Matches Pricing Strategy) is already token-agnostic — `lotSellPrice × lotsPurchased` as Value equality works for any denomination. Lifecycle transition checks (REQT/03ff0mfddc, 998waf4mz3, dtpwzjqn9p) reference REQT/hk93w5zb16 (`get_assets()` equality) which passes because state-only transitions don't move proceeds regardless of cost token type
- **No missing REQTs**: CostToken helper methods (`costTokenScale`, `toCostValue`, `costAmountFromValue`, `isCostToken`) are implementation tools for existing requirements, not separate behavioral needs

#### Architect — examined areas

**Examined:**
- **Scope boundaries**: Tightly bounded to CostToken data model → pricing validation → WithdrawingProceeds. No sprawl across unrelated concerns
- **ARCH-* items**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings data model — all appropriate for the planned changes. No missing items
- **Design alignment**: CostToken enum in DynamicSaleV1Settings follows the established pattern (enum + helpers on struct). Phase 2 refactoring of `isRightPayment()` preserves the existing validation structure. Phase 4 WithdrawingProceeds change from `get_assets()` equality to sale-token-specific check is the correct approach
- **Requirements coverage**: All behavioral changes have driving REQTs. The `paidValue == expectedPayment` Value-level check in SellingTokens handler works correctly for non-ADA cost tokens because `paidValue = newValue - oldValue + purchasedTokens` algebraically equals `addedUtxoValue` regardless of denomination — the framework controls the UTxO value delta precisely
- **Phase 3 (no change needed) verified**: Lifecycle transition checks use `inputValue.get_assets() == outputValue.get_assets()` — when cost token is non-ADA, accumulated proceeds are non-ADA tokens that stay unchanged during state-only transitions. The check passes correctly

#### Code Whisperer — examined areas

**Examined:**
- **Scattered heuristics**: `get_lovelace() / 1_000_000.0` appears twice in `isRightPayment()` — the CostToken helpers (`costAmountFromValue`, `costTokenScale`) consolidate this into a single extraction pattern. Clean
- **Data flow choke points**: CostToken enum with helper methods creates a proper choke point for denomination logic. All callers (isRightPayment, WithdrawingProceeds, lifecycle checks) route through the same helpers
- **Implicit coupling to ADA**: Currently scattered across `get_lovelace()` calls and the `1_000_000` magic number. The plan correctly replaces these with explicit CostToken-mediated extraction
- **DRY**: The `//TODO: add pricing unit` comment in `DynamicSaleV1Settings.hl` (line 4) is exactly what `costToken: CostToken` addresses — clean resolution of existing TODO debt
- **Naming schema**: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)` — internally consistent naming that describes domain operations, not technical mechanisms
- **`validateCommonUpdateChecks` impact**: The shared validation helper calls `validateUpdatedDetails()` on settings, which needs the new costToken bounds check. This is a natural extension of the existing validation pipeline — no structural risk
- **Testability**: CostToken is a pure data type with pure helper methods — no side effects, no hidden state, directly testable
- **No shotgun surgery risk**: Adding CostToken support touches `isRightPayment()`, `WithdrawingProceeds`, and settings validation — three well-defined, localized change sites. The helper methods prevent future cost-token changes from requiring multi-site edits

One suggestion (Coder's judgment): Remove the `//TODO: add pricing unit` and `// pricingUnit: AssetClass` comments in `DynamicSaleV1Settings.hl` when the `costToken: CostToken` field is added — the TODO is being resolved.

#### Findings

##### Finding F1: Plan doesn't address the redeemer-payment Value-level match check in SellingTokens handler

**Severity**: Concern
**Reviewer**: Architect

The SellingTokens handler in `MarketSalePolicy.hl` has TWO separate payment checks:

1. **Value-level redeemer match** (~line 563): `paidValue == expectedPayment` where `expectedPayment = lotSellPrice * lotsPurchased` — this is exact Value equality
2. **Real-level pricing validation**: `pricingStrategy.isRightPayment(lotSellPrice, paidValue)` — this verifies price correctness with tolerance

The plan (Phase 2) explicitly covers refactoring `isRightPayment()` in `DynamicSaleV1.hl` but does not mention the Value-level check in `MarketSalePolicy.hl`. For non-ADA cost tokens, the algebraic analysis suggests `paidValue` should equal `addedUtxoValue` exactly (because `newValue - oldValue + purchasedTokens = addedUtxoValue`), which means the check works IF the framework precisely controls the UTxO delta. But this relies on an assumption about framework behavior that isn't stated in the plan and isn't verified by any test.

**Ask**: Should the plan explicitly address this check? Should a test verify the assumption that `paidValue == addedUtxoValue` holds for non-ADA cost tokens?

> **Resolution**: Plan Phase 2 rewritten with both checks explicitly addressed. Check A (policy-level redeemer honesty) changes from exact Value equality to cost-token-amount extraction and comparison via `costAmountFromValue()`. Check B (`isRightPayment`) uses costToken helpers for price extraction, adds spam/shitcoin rejection (paidValue's non-ADA assets must be ONLY the designated cost token or zero), and adds uniform 0.02 cost-token-unit overpayment tolerance (covers minUtxo ADA shifts). `isRightPayment` accesses costToken via `self.settings.costToken`.

##### Finding F2: MinUtxo creep for non-ADA cost token sales — operational risk unacknowledged

**Severity**: Concern
**Reviewer**: Architect

For ADA-denominated sales, every purchase adds ADA to the sale UTxO, naturally covering any minUtxo increases from datum CBOR growth (progress details, pace, timestamps change each sale).

For non-ADA cost token sales, the buyer pays in the cost token — **no ADA is added to the sale UTxO during purchases**. If datum growth increases minUtxo over time, the sale UTxO's fixed ADA may eventually be insufficient, causing transaction failures at the Cardano node level. The UTxO's initial ADA deposit must be large enough to absorb ALL possible minUtxo increases across the entire sale lifecycle.

The work unit's Problem/Context and Plan sections don't acknowledge this operational constraint. Front-end and admin guidance may be needed (similar to the "keep pauses short" advisory from the pause-stop work unit).

**Ask**: Should the work unit acknowledge this and add front-end/admin advisory guidance? Should there be an acceptance criterion or REQT for minimum initial ADA deposit when using non-ADA cost tokens?

> **Resolution**: Not an operational risk. The transaction builder automatically adds sufficient ADA to cover minUtxo in the sale UTxO output — the buyer contributes the ADA delta as part of the transaction. This is standard Cardano transaction building behavior, not something the sale admin or front-end needs to manage. No plan change needed.

##### Finding F3: Missing REQT for "payment must be in the designated cost token"

**Severity**: Concern
**Reviewer**: Architect

Currently, `isRightPayment()` has `assert(payment.get_assets().is_zero(), "non-ADA assets not yet supported here")` which implicitly requires ADA payment. There is no explicit REQT for this — it's an implementation guard.

After the CostToken change, the guard is replaced with a "cost-token-aware check" (per the plan). But what behavioral requirement drives this check? The check ensures buyers can't pay with arbitrary tokens — only the designated cost token is accepted. This is a real enforcement behavior but has no driving REQT.

REQT/jdkhmeg463 says "payment matches pricing strategy" (amount correctness). REQT/nb3v1zg4fv says "identifies which token buyers pay with" (enum definition). Neither explicitly says "SellingTokens MUST reject payment in any token other than the designated cost token."

**Ask**: Should there be a REQT explicitly requiring payment denomination enforcement? Or is this adequately covered by the combination of existing REQTs?

> **Resolution**: New REQT/jxdnb3dxmx (Payment Denomination Enforcement) added at 8.3.3 under Pricing Model Validation. Statement: "SellingTokens MUST reject payment in any token other than the designated cost token. When costToken is ADA, paidValue MUST contain no non-ADA assets. When costToken is Other, paidValue's non-ADA assets MUST be only the designated cost token — no other tokens accepted." Added to work unit scope.

##### Finding F4: `assert(payment.get_assets().is_zero())` removal is a behavioral change but REQT-jdkhmeg463 stays at COMPLETED

**Severity**: Concern
**Reviewer**: Architect

Currently, any attempt to buy with non-ADA tokens is rejected on-chain by `assert(payment.get_assets().is_zero())`. After this work unit, non-ADA cost token payments ARE accepted (when the sale is configured for that cost token). This is a behavioral change at the on-chain policy level.

The work unit categorizes REQT/jdkhmeg463 (Payment Matches Pricing Strategy) as "Implementation-only changes (requirements already token-agnostic)" and leaves it at COMPLETED. But the observable behavior of the SellingTokens activity changes: it goes from "rejects all non-ADA payment" to "accepts designated non-ADA cost token payment."

The Work Planner protocol says "No REQT whose behavior is being modified may remain at COMPLETED when pre-work exits."

**Ask**: Does REQT/jdkhmeg463 need status transition? Or is the behavioral change driven entirely by the new Area 14 REQTs (making jdkhmeg463 truly unchanged)?

> **Resolution**: REQT/jdkhmeg463 stays at COMPLETED. Its statement ("payment matches lotSellPrice × lotsPurchased") is about amount correctness — that doesn't change. The denomination enforcement behavior is now captured by REQT/jxdnb3dxmx (F3). The implementation of amount extraction changes (lovelace → costToken helpers) but the behavioral requirement is the same.

##### Finding F5: Problem/Context section conflates "proceeds accumulation" and "proceeds withdrawal"

**Severity**: Suggestion
**Reviewer**: Architect

Problem/Context section 3 says: "When the cost token is non-ADA, accumulated sale proceeds ARE non-ADA tokens. The current 'non-ADA tokens unchanged' check would block legitimate proceeds accumulation or prevent withdrawal."

"Block legitimate proceeds accumulation" is misleading — the SellingTokens handler doesn't have a "non-ADA unchanged" check, so accumulation is never blocked. The issue is only with WithdrawingProceeds (and potentially lifecycle transitions). This could confuse the coder about which code paths actually need changes.

**Ask**: Should the wording be corrected to say "prevent withdrawal" only?

> **Resolution**: Finding withdrawn — the wording is accurate. `isRightPayment`'s `assert(payment.get_assets().is_zero())` is in the SellingTokens flow and WOULD block non-ADA payment, which IS proceeds accumulation when cost token is non-ADA. Both "block proceeds accumulation" and "prevent withdrawal" are correct.

##### Finding F6: Plan Phase 4 says "sale tokens must remain" but doesn't define "sale tokens" or the check mechanism

**Severity**: Concern
**Reviewer**: Code Whisperer

Phase 4 says: "Refactor WithdrawingProceeds 'non-ADA tokens must remain' to 'sale tokens must remain'." The plan mentions `isCostToken(ac)` as a helper, but doesn't specify how the check works:

- Does it iterate over all asset classes in the UTxO and verify non-cost-token assets are unchanged?
- Does it check specific known sale token asset classes from `saleLotAssets`?
- How does it handle the UUT (which is neither a sale token nor a cost token)?

The current check is a simple one-liner (`inputAssets == outputAssets`). The replacement needs to be more nuanced. Without guidance, the coder may implement an approach that misses edge cases.

**Ask**: Should the plan specify the check approach? At minimum: "for each AssetClass in input that is NOT the cost token (per `isCostToken(ac)`), verify output has the same amount. UUT is handled by the framework's `mustOutputDelegatedData`."

> **Resolution**: Implementation detail worked out interactively during the coder interview. Plan guidance is sufficient.

##### Finding F7: `isRightPayment` "cost-token-aware check" for the asset assertion is underspecified

**Severity**: Concern
**Reviewer**: Code Whisperer

Phase 2 says "Replace `payment.get_assets().is_zero()` with cost-token-aware check" but doesn't specify what that check looks like for each variant:

- **ADA cost token**: `payment.get_assets().is_zero()` (same as current — only ADA in payment)
- **Other cost token**: What exactly? "Payment should contain ONLY the cost token"? But `paidValue` is a Value delta — does it ever contain unexpected assets?

The two variants need different enforcement logic. Without specification, the coder may write something that passes tests but has a logical gap.

**Ask**: Should the plan specify the per-variant check? Or is this implementation detail the coder should work out during the interview?

> **Resolution**: Resolved by F1 plan update. Phase 2 now specifies: "paidValue's non-ADA assets must be ONLY the cost token (if non-ADA) or zero (if ADA). Rejects shitcoins/spam tokens injected into the sale UTxO output." Implementation mechanism left to coder's judgment.

##### Finding F8: `paidValue == expectedPayment` depends on framework behavior that could change

**Severity**: Concern
**Reviewer**: Code Whisperer

The algebraic analysis showing `paidValue == addedUtxoValue` depends on the framework's `mkTxnUpdateRecord` adding EXACTLY `addedUtxoValue` to the UTxO — no more, no less ADA for minUtxo adjustment. If the framework ever changes to auto-pad ADA for minUtxo, this check breaks for non-ADA cost tokens (paidValue would include unexpected ADA).

This is an implicit coupling between the on-chain policy's exact Value equality check and the off-chain framework's transaction construction behavior. Currently there's no documentation or test that makes this coupling explicit.

**Ask**: Should a test explicitly verify that `paidValue == addedUtxoValue` for non-ADA cost tokens? Should this assumption be documented in the plan as a design constraint?

> **Resolution**: F1's resolution (cost-token-amount extraction instead of Value equality) neutralizes the exact-match coupling. However, the buyer contributes ADA for minUtxo (F2), meaning paidValue DOES include ADA beyond the cost token payment. Tests for non-ADA cost token buying must verify that the cost-token-amount extraction correctly ignores the ADA component. Highlighted for Tessa — see test sketch notes.

##### Finding F9: Existing ADA tests may break from struct layout change — not called out in plan

**Severity**: Suggestion
**Reviewer**: Domain-Fit Tester (Stellar Testing)

Adding `costToken: CostToken` to `DynamicSaleV1Settings` changes the struct's CBOR encoding. All existing cached test snapshots will need to be invalidated and rebuilt. The off-chain `exampleData()` in `MarketSaleController.ts` must provide the new field with a default (`{ ADA: {} }`).

The work unit says "Existing ADA-denominated tests should pass unchanged (CostToken::ADA is default)" but doesn't mention the snapshot invalidation or the `exampleData()` update needed to make this true.

**Ask**: Should the plan explicitly note that snapshot invalidation and `exampleData()` update are prerequisites for existing tests to pass?

> **Resolution**: Snapshot invalidation is automatic due to code changes — no manual cache invalidation needed or wanted. The `exampleData()` update for the new field is part of Phase 5 (offchain integration). No plan change needed.

#### Domain-Fit Tester (Stellar Testing) — examined areas

**Examined:**
- **Existing test coverage**: The current MarketSale test suite covers ADA-denominated selling, lifecycle transitions, VXF None-mode, and WithdrawingProceeds. All existing tests should pass unchanged because CostToken::ADA is the default and preserves current behavior
- **Phase 6 testing bullet points**: Appropriate scope — new tests for Other cost token pricing, lifecycle transitions with non-ADA, and WithdrawingProceeds with non-ADA
- **Snapshot implications**: Adding `costToken` field to `DynamicSaleV1Settings` changes CBOR encoding — existing snapshots will auto-invalidate and rebuild (standard stellar-contracts behavior). The off-chain `exampleData()` needs to provide `costToken: { ADA: {} }` as default

**Test sketch:**

```typescript
// === CostToken Settings Validation (REQT/4zkj5q4n38) ===

describe("CostToken Settings Validation (REQT/4zkj5q4n38)", () => {
    // Happy path: CostToken::ADA is implicit default (existing tests cover this)

    it("rejects CostToken::Other with scale=0 (cost-token-scale-zero/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: use updatePendingMarketSale or rawUpdate to set costToken to Other with scale=0
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("rejects CostToken::Other with scale=20 (cost-token-scale-too-high/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=20
        // await expect(submitting).rejects.toThrow(/scale/);
    });

    it("accepts CostToken::Other with valid scale (cost-token-scale-valid/REQT/4zkj5q4n38)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        await h.snapToFirstMarketSale();
        const sale = await h.findFirstMarketSale();
        // TODO: set costToken to Other with scale=6, valid mph + tokenName
        // Should succeed
    });
});

// === Non-ADA Pricing (REQT/nb3v1zg4fv) ===

describe("Non-ADA Cost Token Pricing (REQT/nb3v1zg4fv)", () => {
    // Requires: test token ("USDC" mock) created via helper
    // Requires: sale configured with CostToken::Other{mph, tokenName, scale: 6}
    // Requires: sale activated with tokens deposited
    // Requires: buyer has sufficient test USDC to purchase

    it("buys lots with non-ADA cost token at correct price (non-ada-buy/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: advance time past maturity window
        // TODO: buy 1 lot with correct USDC payment
        // verify: sale tokens received by buyer
        // verify: USDC accumulated in sale UTxO
        // verify: ADA unchanged in sale UTxO
    });

    it("rejects buy with wrong token (non-ada-wrong-token/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with FISH instead of USDC
        // await expect(submitting).rejects.toThrow(/cost.*token|payment/);
    });

    it("rejects buy with insufficient cost token (non-ada-insufficient/REQT/jdkhmeg463)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleActivated()
        // TODO: attempt to buy with less USDC than lot price
        // await expect(submitting).rejects.toThrow(/payment/);
    });
});

// === WithdrawingProceeds with Non-ADA Cost Token (REQT/gy6jd9cjkg) ===

describe("WithdrawingProceeds Non-ADA (REQT/gy6jd9cjkg)", () => {
    it("withdraws non-ADA cost token while Paused (non-ada-withdraw-paused/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASalePausedWithProceeds()
        //   (activate with non-ADA cost token, sell some lots, stop)
        // TODO: h.withdrawProceeds(sale, amount)
        // verify: USDC decreased in sale UTxO
        // verify: sale tokens unchanged
        // verify: datum unchanged
        // verify: UUT still present
    });

    it("preserves sale tokens after non-ADA withdrawal (non-ada-withdraw-tokens-locked/REQT/gy6jd9cjkg)", async (context: STOK_TC) => {
        // Consolidate with non-ada-withdraw-paused happy path
        // assert: all sale token asset classes unchanged
        // assert: only cost token decreased
    });
});

// === Lifecycle Transitions with Non-ADA Cost Token (REQT/hk93w5zb16) ===

describe("Lifecycle with Non-ADA Cost Token (REQT/hk93w5zb16)", () => {
    it("stops sale with accumulated non-ADA proceeds (non-ada-stop/REQT/03ff0mfddc)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: h.snapToFirstNonADASaleWithProceeds() (activated, sold some lots)
        // TODO: h.stopMarketSale(sale)
        // verify: non-ADA cost tokens unchanged (still accumulated)
        // verify: sale tokens unchanged
    });

    it("resumes sale with non-ADA proceeds intact (non-ada-resume/REQT/998waf4mz3)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then resume
        // verify: non-ADA cost tokens still present
        // verify: can sell again after resume
    });

    it("retires sale with non-ADA proceeds locked (non-ada-retire/REQT/dtpwzjqn9p)", async (context: STOK_TC) => {
        const { h } = context;
        await h.reusableBootstrap();
        // TODO: stop then retire
        // verify: non-ADA cost tokens locked (unchanged)
        // verify: sale tokens locked
    });
});
```

**Test count summary:**

| Area | Happy path | Negative | Total |
|------|-----------|----------|-------|
| Settings validation | 1 | 2 | 3 |
| Non-ADA pricing | 1 | 2 | 3 |
| WithdrawingProceeds non-ADA | 1 | 0 | 1 |
| Lifecycle non-ADA | 3 | 0 | 3 |
| **Total** | **6** | **4** | **10** |

**Helper evolution needed:**
- Test USDC token creation (mock cost token with known mph, tokenName, scale=6)
- `snapToFirstNonADASaleActivated` — creates sale with `CostToken::Other`, deposits sale tokens, activates
- `snapToFirstNonADASaleWithProceeds` — parent: above snapshot, buys lots to accumulate non-ADA proceeds
- `snapToFirstNonADASalePausedWithProceeds` — parent: above, stops sale

**Notes:**
- WithdrawingProceeds happy-path test consolidates token-locked and datum-unchanged assertions into one transaction
- Existing ADA-denominated tests serve as regression — no explicit duplication needed
- `non-ada-withdraw-tokens-locked` consolidates with the Paused withdrawal happy path (one txn, multiple assertions)
- **F8 highlight for Tessa**: The non-ADA buy happy-path test (`non-ada-buy`) must verify that paidValue includes an ADA component (buyer's minUtxo contribution) AND that the cost-token-amount extraction in Check A and isRightPayment correctly ignores it. This is the key coupling point — if the on-chain extraction accidentally includes ADA, non-ADA purchases fail

## Implementation Decisions

### D1: `scale` field stores multiplier, not decimal-place count (2026-02-24)

**Original design**: `CostToken::Other.scale` stored a decimal-place count (e.g., `6` for USDC → `10^6` base units per token). `costTokenScale()` returned this count; callers would need to compute `10^scale` at runtime.

**Changed to**: `scale` stores the multiplier directly (e.g., `1_000_000` for USDC). `costTokenScale()` returns the multiplier. ADA's implicit multiplier is `1_000_000`.

**Rationale**: Avoids on-chain exponentiation overhead. Multiplier is used directly in division/multiplication — no `10^n` computation needed at runtime. Bounds validation updated from `1–19` to `1–10^19`.

**Impact**: REQT-4zkj5q4n38 statement updated (scale range), REQT-y5gge63n84 statement updated (field description). Offchain stubs that read `scale` must interpret it as multiplier.

## Worker Report

### Onchain Implementation — Osiris (2026-02-24)

#### Summary

All four change sites implemented across 8 commits. The implementation evolved from the original plan in two significant ways: the `scale` field semantics changed (D1 above), and the pricing validation was rewritten to work entirely in `Int` micro-token arithmetic rather than `Real`.

#### Evolved Approach: Micro-Token Int Arithmetic

**Original plan**: `isRightPayment()` (Check B) would replace `get_lovelace() / 1_000_000.0` with `costToken.costAmountFromValue(v)` returning `Real`, preserving the existing Real-based comparison logic.

**What was implemented**: A single Real→Int conversion boundary at the top of `isRightPayment()`:
```
expectedPriceMicro : Int = (self.lotPriceForSale() * scale).floor()
```
After this, all comparisons — price matching, payment validation, overpayment tolerance — operate on `Int` micro-token amounts. The helper is named `microTokensFromValue` (not `costAmountFromValue`) to reflect that it returns base-unit Int, not macro-token Real.

**Rationale**: Real in Helios has 6-decimal precision. Working in Int avoids compounding precision loss across multiply/divide chains. The micro-token approach is also more efficient on-chain (Int arithmetic vs Real).

**Consequence**: Check A (policy-level) also uses `microTokensFromValue` for Int comparison. The original plan's `costAmountFromValue` returning Real was never implemented — `microTokensFromValue` returning Int serves all call sites.

#### Helper Method Evolution

Original plan called for: `costTokenScale()`, `toCostValue(amount)`, `costAmountFromValue(v)`, `isCostToken(ac)`.

Implemented: `costTokenScale()`, `microTokensFromValue(v)`, `toCostValue(microTokens)`, `isCostToken(ac)`.

The rename from `costAmountFromValue` → `microTokensFromValue` reflects the Int return type. A `macroTokensFromValue` returning Real was considered but deemed unnecessary — no call site needs it.

#### Change Site Details

**1. Data model** (`DynamicSaleV1Settings.hl`):
- CostToken enum with ADA (tag 0) and Other{mph, tokenName, scale} (tag 1)
- Four helper methods on the enum
- `costToken: CostToken` field added to DynamicSaleV1Settings after `targetPrice`
- Scale bounds validation in `validateUpdatedDetails()`: multiplier range 1–10^19

**2. Check A — SellingTokens policy** (`MarketSalePolicy.hl` ~line 558):
- Replaced `paidValue == expectedPayment` (Value equality) with micro-token Int comparison
- Extracts `costToken` from settings, uses `microTokensFromValue` on both sides
- Traces REQT-90fsr7px0z

**3. Check B — isRightPayment** (`DynamicSaleV1.hl`):
- All Real arithmetic eliminated except the single `lotPriceForSale() * scale` boundary
- Price tolerance: ±2 micro-tokens (covers Real 6-decimal rounding)
- Spam rejection via `bREQTgroup` (REQT-jxdnb3dxmx): ADA → no non-ADA assets; Other → assets must be exactly the cost token
- Overpayment tolerance: `scale / 50` micro-tokens (0.02 macro-tokens); underpayment rejected
- Traces REQT-jdkhmeg463

**4. WithdrawingProceeds** (`MarketSalePolicy.hl` ~line 755):
- ADA: unchanged (`inputAssets == outputAssets`)
- Other: strips cost token from both sides via `Value::new(costAc, amount)` subtraction, then compares
- Traces REQT-gy6jd9cjkg and REQT-5r79v9b4ht

#### Cross-Boundary Impacts

- **Offchain** (Freya): `scale` field is now a multiplier, not a decimal count. `costTokenScale()` returns `1_000_000` for ADA (was `6` in the original plan). Bridge files need regeneration. Offchain stubs must interpret `scale` as multiplier.
- **Testing** (Tessa): All existing ADA tests should pass unchanged — `CostToken::ADA` preserves prior behavior (lovelace extraction, same tolerance semantics). New non-ADA test paths needed per the test sketch. Key coupling: non-ADA buy test must verify ADA component in paidValue is correctly ignored by micro-token extraction.

### Offchain Integration — Freya (2026-02-24)

#### Summary

Aligned offchain cost-token helpers with on-chain implementation. One commit on `non-ada-pricing` branch (040f7d3).

#### Changes

**1. `costTokenScale()` — multiplier semantics** (`MarketSaleController.ts`):
- Was returning `6` (exponent); now returns `1_000_000` (multiplier) matching on-chain `CostToken::costTokenScale()`
- Removed `10 **` from both call sites (`salePricePerLot`, `computeLotsForPurchase`) — scale is used directly as multiplier
- TODO comments show the path to reading from `mktSale.data.details.V1.fixedSaleDetails.settings.costToken`

**2. `exampleData()` settings** (`MarketSaleController.ts`):
- Added `costToken: { ADA: {} }` — required after CostToken enum landed in `DynamicSaleV1SettingsLike`

**3. Type error fix** (`MarketSaleDataWrapper.ts` — committed by osiris):
- `progressPricingDiscountDepth()` and `priceExpansion()` parameter types changed from `DynamicSaleV1Settings` to `ErgoDynamicSaleV1Settings`
- The `costToken` field caused type incompatibility: ergo form uses `ErgoCostToken` (intersected/partial enum) vs strict `CostToken` (discriminated union)
- Neither method uses `costToken` — they only read pricing fields, so ergo type is correct

#### Remaining Phase 5 Work

The cost-token helpers are still stubbed for ADA-only. Once wired to read from sale data:
- `costTokenScale()` → read `costToken.Other?.scale` or return `1_000_000` for ADA
- `costTokenIsADA()` → check `costToken.ADA` variant presence
- `mkCostTokenValue()` → use `makeValue(mph, tokenName, amount)` for Other variant
- `costTokenAmount()` → extract token quantity from Value assets for Other variant

These are mechanical — the helper signatures and call sites are already correct.

### Testing — Stellar Tester (2026-02-24)

#### Summary

10 new tests in `MarketSale.costToken.test.ts` covering all four Phase 6 areas: CostToken settings validation (3), non-ADA pricing (3), WithdrawingProceeds with non-ADA (1), and lifecycle transitions with non-ADA (3). All passing. Existing ADA test suite (83 tests) verified green after regression fixes.

#### Test File & Helpers

- **New file**: `src/MarketSale/tests/MarketSale.costToken.test.ts` — separate from the 2237-line existing test file
- **Test token**: TUNA (minted under `capo.mph` with `scale: 1_000n`), not a mock external token
- **Module constants**: `TUNA_TOKEN_NAME`, `TUNA_SCALE` for consistent reference
- **New helpers**: `exampleDataWithTuna()`, `fundActorWithTuna()` in `MarketSaleTestHelper.ts`
- **Two-snapshot chain**: `saleNativeTokenCost` (create+activate with TUNA pricing) → `saleNativeTokenPaused` (fund buyer, buy, stop)
- **`withdrawProceeds` interface**: Changed from `macroAmount: bigint` to `macroAmount: number` to support fractional amounts (e.g., `2.0` ADA, `1.9` TUNA, `42.8` TUNA)

#### Runtime Issues Discovered During Testing

Testing surfaced three off-chain bugs that were fixed in separate commits by other agents:

1. **Non-ADA payment UTxO lookup** (`MarketSaleController.ts`): `mkTxnBuyFromMarketSale` needed `mkTokenPredicate(totalSalePrice)` for non-ADA cost tokens — was only looking for lovelace
2. **`priceExpansion` formula** (`MarketSaleDataWrapper.ts`): Off-chain was missing `1.0 +` around `progressPricingExpansionWhenFast` — on-chain always had it correct (confirmed via Google Sheet comment at line 453). Pre-existing since initial commit `7710a8f`
3. **Rounding alignment** (`MarketSaleController.ts`): Off-chain `salePricePerLot` used `Math.round()` and rounded total independently; on-chain uses `.floor()` and derives total as `lotPriceMicro * lotsPurchased`. Changed to `Math.floor()` + `lotPriceMicro * BigInt(lotsPurchased)`

#### ADA Regression Fixes

The upstream `tcx.txnTime` fix (using network tip time instead of wall-clock) and the `withdrawProceeds` macro-token interface change broke existing ADA tests:

- **`firstMarketSalePaused` builder**: Added `travelToFuture` with `Math.max(startAt + 11min, nowMs + 1sec)` pattern — same fix applied to TUNA builder. Bumped `builderVersion` 2→3
- **`withdrawProceeds` callers**: `2_000_000n` → `2.0` at all 5 ADA call sites (bigint→number interface)
- **`funds-must-accumulate` error regex**: Updated to match new Check A message (`extracts cost-token micro-units...`)

#### Final State

- `MarketSale.costToken.test.ts`: **10/10 passing**
- `MarketSale.test.ts`: **83/83 passing** (12 todo, 0 failed)

### Post-Work Collaborative Review (2026-02-25)

**Audit file**: [`20260224.non-ada-pricing-cost-token.post-work-audit.md`](./20260224.non-ada-pricing-cost-token.post-work-audit.md)

#### Architect — zero findings

**Examined:**
- **Scope boundaries**: Implementation stayed tightly bounded to CostToken data model → pricing validation → WithdrawingProceeds. No sprawl.
- **ARCH-* alignment**: MarketSale delegate policy, DynamicSaleV1 pricing model, DynamicSaleV1Settings — all changes within correct architectural boundaries. No ownership violations.
- **Implementation evolutions assessed**: D1 (scale as multiplier) — structurally sound, avoids on-chain exponentiation. Micro-token Int arithmetic — better precision than Real, stays within DynamicSaleV1's existing responsibility. Neither evolution crosses architectural boundaries.
- **priceExpansion bug fix**: Pre-existing off-chain bug (`1.0 +` missing), aligns off-chain with already-correct on-chain formula. Not an unvetted architectural decision — it's a correctness fix within the off-chain controller's existing responsibility.
- **No unvetted architectural decisions introduced**: CostToken helpers follow established Helios enum-with-methods pattern. WithdrawingProceeds branching (ADA vs Other) is the correct approach per pre-work F1 resolution.

#### Code Whisperer — 2 findings

##### Finding pw-F1: Uncommitted test/helper changes — checkpoint incomplete

**Severity**: Concern

The working tree has uncommitted changes to `MarketSaleTestHelper.ts`, `MarketSale.test.ts`, and `MarketSale.costToken.test.ts` beyond the latest commit (`0b549ce`). These include: the `withdrawProceeds` interface change (`bigint` → `number`), `builderVersion` bump (2→3), `travelToFuture` additions, error regex update for Check A, and call-site updates (`2_000_000n` → `2.0`, `1n` → `1.0`). The committed test code likely doesn't pass.

> **Resolution**: Stakeholder committed outstanding changes (7af7e1f, 3ee03c8, c4ef7e1). Checkpoint complete.

##### Finding pw-F2: reqts.md not regenerated from JSONL after status updates

**Severity**: Concern

Area 14 REQTs show `NEXT` in reqts.md but `IMPLEMENTED/NEEDS VERIFICATION` in the JSONL source of truth. REQT-4zkj5q4n38 statement still says "scale outside the range 1–19" instead of "scale multiplier outside the range 1–10^19" per D1.

> **Resolution**: Regenerated reqts.md from JSONL via `generate-reqts.mjs`. Commit aecb95d.

#### Domain-Fit Tester (Stellar Testing) — 1 finding

##### Finding pw-F3: REQT-jxdnb3dxmx spam rejection code path not exercised

**Severity**: Concern

The `non-ada-wrong-token` test carries `REQT/jxdnb3dxmx` attribution but fails at Check A (`microTokensFromValue` key-not-found) rather than at the spam rejection logic in `isRightPayment()`. No test exercises REQT-jxdnb3dxmx's actual code path: payment containing correct cost token PLUS unexpected additional tokens.
