import { makeSource } from '@helios-lang/compiler-utils';

const VestingPolicy_hl = makeSource(
  "module VestingPolicy\n\n// specialized to ...\n//   -   NOT YET SPECIALIZED (replace with your specialization notes here) - \n// original notes about (un)specialization follow:\n\n\n//  //! provides a basic version, not yet specialized,\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    mkUutTnFactory\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    VestingData,\n    VestingState\n} from VestingData\n\nimport {\n    CapoCtx,\n    mkCapoCtx,\n    DgDataDetails,\n    mkTv,\n    AnyData \n} from CapoHelpers\n\nimport {\n    TODO,\n    REQT,\n    bREQT\n} from StellarHeliosHelpers\n\n// import {\n//     TierLookupResult\n// } from TieredScale\n//\n// import {\n//     PriceNeeded,\n//     validateRequiredValue,\n//     ValueValidator\n// } from PriceValidator\n\n\n\nenum DelegateDatum {\n    // we only have to use this if we decide Constr#0 is essential for practical CIP-68 compat\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data\n        // otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: VestingData\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, settings: ProtocolSettings) -> Bool{\n    // ... get the settings object from the contract manifest via cctx\n    //     assert(false, \"not valid (stubbed)\");\n    //     settings.serialize() != self.serialize() &&\n    //     true\n    // }\n}\n\n\nenum MintingActivity {\n    CreatingRecord{\n        seed: TxOutputId\n    }\n}\n\n//! The minting delegate can also be used as a general spending \n// delegate (this is the default arrangement during the Capo \n// charter mint).  These activities are required by the Capo when\n// spending utxos having DelegatedDatum type.\nenum SpendingActivity {\n    UpdatingRecord {\n        id: ByteArray\n    }\n    SwitchToVerifying {\n        id: ByteArray\n    }\n    VerifyingBeneficiary {\n        id: ByteArray\n    }\n    Activating {\n        id: ByteArray\n    }\n    Withdrawing {\n        id: ByteArray\n        // ???\n        value: Value\n    }\n    Pausing {\n        id: ByteArray\n    }\n    Resuming {\n        id: ByteArray\n    }\n    Closing {\n        id: ByteArray\n    }\n}\n\nfunc ensureConstrainedTxValidity() -> () {\n    assert(\n        tx.time_range.end - tx.time_range.start \n            <= Duration::HOUR,\n        \"txn duration err\"\n    )\n}\n\nfunc daysInFuture(nowPlusDays: Int) -> TimeRange {\n    ensureConstrainedTxValidity();\n    expiryDuration : Duration = Duration::DAY * nowPlusDays;\n    leeway : Duration = 1 * Duration::HOUR;\n    latestAcceptable : Time = tx.time_range.end + expiryDuration + leeway;\n    \n    TimeRange::new(\n        tx.time_range.start + expiryDuration,\n        latestAcceptable\n    )\n}\n\nenum BurningActivity {\n    DeletingRecord {\n        id: ByteArray\n    }\n}\n\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        activity: BurningActivity\n    }\n    \n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // record id created from seed\n    }\n\n    UpdatingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n        activities: []Data // actually a DelegateActivity\n    }\n\n    OtherActivities {\n        activity: Data // specialized activities can be added here\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, sTxId, sIdx, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seedTxId: sTxId, \n    //         seedIdx: sIdx, \n    //         purposes: purposes,\n    //         // otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation,\n        cctx: CapoCtx\n    ) -> Bool {\n        print(\"  -- addl dgt val \");\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            CapoLifecycleActivities => {\n                // only mint/spend delegates answer to CapoLifecycleActivities\n                error(\"unreachable in a dgDataPolicy\")\n            },\n            MintingActivities{ma} => ma.switch {\n                CreatingRecord{seed} => {\n                    print(\"registering a new vesting instance...\");\n\n                    REQT(\"the operator must provide a valid minting seed\");\n                    mkTn : (String) -> String = mkUutTnFactory(seed);\n\n                    // mints a vest-* UUT\n                    mintingOk : Bool = validateUutMinting(\n                        mph: priorMddd.dd.mph,\n                        seed: seed,\n                        purposes: []String{\"vest\"},\n                        // otherMintedValue: ()\n                        mkTokenName: mkTn,\n                        // WE ARE the mint delegate.\n                        needsMintDelegateApproval: false \n                    );\n\n                    assert(cctx.withCharterRef().orFail(), \"no charter ref\");\n\n                    newRecData : DgDataDetails = cctx.creatingDgData(mkTn(\"vest\"));\n                    _newDataOut : TxOutput = newRecData.output();\n\n                    rec: VestingData = VestingData::from_data(\n                        newRecData.outputData()\n                    );\n\n                    assert(\n                        tx.time_range.end - tx.time_range.start \n                            <= Duration::HOUR,\n                        \"txn duration err\"\n                    );\n\n                    // has the owner-token reference\n                    ownerToken = rec.ownerToken;\n                    ownerTokenAc : AssetClass = AssetClass::new(\n                        priorMddd.dd.mph, ownerToken\n                    );\n                    \n                    REQT(\"verifies the owner-token's presence in the txn\");\n                    // has the owner-token in the txn\n                    tx.inputs.find_safe((i: TxInput) -> Bool {\n                        i.value.get_safe(ownerTokenAc) == 1\n                    }).switch {\n                        None => error(\"missing owner token\"),\n                        Some => true\n                    } &&\n                    bREQT(\"verifies creation-details\") && \n                    rec.validateCreated().trace(\"creation ok? \") &&\n                    bREQT(\"verifies the vesting instance's overall validity\") &&\n                    rec.validate().trace(\"verify ok? \") &&\n                    mintingOk\n                }\n            },\n            SpendingActivities{x} => {\n                assert(cctx.withCharterRef().orFail(), \"no charter ref\");\n\n                x.switch {                    \n                    UpdatingRecord{recId} => {\n                        print(\"updating the details for a vesting instance...\");\n\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        hasRecInput : (TxInput) -> Bool = \n                            cctx.mkDelegatedDataPredicate(\"vest\", recId);\n\n                            hasRecOutput : (TxOutput) -> Bool = \n                            cctx.mkDelegatedDataOutputPredicate(\"vest\", recId);\n                        \n                        tx.inputs.filter(hasRecInput).for_each( (utxo : TxInput) -> () {\n                            // they're all vesting instances, because of the above.\n                            inputData = \n                                VestingData::from_data(utxo.datum.inline);\n                            assert(inputData.state == VestingState::Initializing, \"update requires state=Initializing\");\n\n                            updatedUtxo : TxOutput = tx.outputs.find(hasRecOutput);\n                            updatedData = \n                                VestingData::from_data(updatedUtxo.datum.inline);\n\n                            assert(updatedData.validate(), \"<-- that throws; this can't.\"); // throws if invalid\n                            ()\n                        });\n\n                        true\n                    },\n                    SwitchToVerifying{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n                      \n                        REQT(\"switches the vesting instance to verifying mode\")\n                        REQT(\"requires the owner-token's presence in the txn\")\n                        REQT(\"doesn't change any details of the vesting data\")\n                        TODO(\"^^^\")\n                        false\n                    },\n                    VerifyingBeneficiary{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"verifies the beneficiary-token's presence in the txn\")\n                        // beneficiaryToken = rec.beneficiaryToken;\n                        TODO(\"^^^\")\n                        REQT(\"requires that the beneficiary-token is not changed\")\n                        // assert(rec.beneficiaryToken == updated.beneficiaryToken, \"beneficiary token changed\");\n\n                        // _beneficiaryTokenAc = AssetClass::new(\n                        //     priorMddd.dd.mph, \n                        //     beneficiaryToken                            \n                        // )\n\n                        TODO(\"implement this!\")\n                        false\n                    },\n                    Activating{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"activates the vesting instance\")\n                        REQT(\"verifies the owner-token's presence in the txn\")\n                        REQT(\"doesn't change any details of the vesting data\")\n                        REQT(\"requires that the indicated totalAmount is deposited\")\n                        TODO(\"verifies the beneficiary-token's presence in the txn\")\n                        // beneficiaryToken = rec.beneficiaryToken\n\n                        // _beneficiaryTokenAc : AssetClass = AssetClass::new(\n                        //     priorMddd.dd.mph, beneficiaryToken\n                        // )\n    \n                        TODO(\"implement this!\")\n                        false\n                    },\n                    Withdrawing{recId, _value} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"StraighLine is supported\");\n                        REQT(\"Once is NOT supported\");\n                        REQT(\"SimpleContingency is NOT supported\");\n                        \n                        REQT(\"withdraws the vesting instance\")\n                        REQT(\"fails if the vesting instance is not Active\")\n                        REQT(\"requires the beneficiary-token's presence in the txn\")\n                        REQT(\"requires that the correct funds are withdrawn\")\n                        REQT(\"doesn't change any details of the vesting data\")\n                        REQT(\"updates the lastPartialMaturity to fit the configured vesting frequency\")\n\n                        REQT(\"... on the last vesting period:\")\n                        REQT(\"   -- last vesting: no funds may remain\")\n                        REQT(\"   -- last vesting: the state must be Closed 'complete'\")\n\n                        TODO(\"implement this!\")\n                        false\n                    },\n                    Pausing{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"pauses the vesting instance\")\n                        REQT(\"requires the owner-token's presence in the txn\")\n                        REQT(\"requires a Pause reason\")\n                        REQT(\"doesn't change any details of the vesting data\")\n\n                        TODO(\"implement this!\")\n                        false\n                    },\n                    Resuming{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"resumes the vesting instance\")\n                        REQT(\"requires the owner-token's presence in the txn\")\n                        REQT(\"doesn't change any details of the vesting data\")\n\n                        TODO(\"implement this!\")\n                        false\n                    },\n                    Closing{recId} => {\n                        vestingDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                        _rec : VestingData = VestingData::previous(vestingDD);\n                        _updated : VestingData = VestingData::updated(vestingDD);\n\n                        REQT(\"closes the vesting instance\");\n                        REQT(\"requires the owner-token's presence in the txn\")\n                        REQT(\"requires a Close reason\")\n                        REQT(\"doesn't change any details of the vesting data\")\n                        REQT(\"withdraws any remaining funds to a destination specified by the owner\")\n\n                        TODO(\"implement this!\")\n                        false\n                    }\n                }\n            },\n            BurningActivities => error(\"no burn activity here yet\"),\n            OtherActivities => error(\n                \"no other activities exist in this delegate\"\n            ),\n            _ => false\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way\" );\n        []String{ /* \"nothingHereYet\", */ }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation(self,\n        _priorMdd: DelegateDatum\n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/Vesting/VestingPolicy.hl", // source filename
    moduleName:  "VestingPolicy",
});

const VestingData_hl = makeSource(
  "module VestingData\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    DgDataDetails,\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport { \n    VxfDestination\n} from VxfProtocol\n\nenum VestingState {\n    Initializing\n    VerifyingBeneficiary\n    Active\n    Paused {\n        reason: String\n        infoRef: Option[AssetClass]\n    }\n    Closed {\n        reason: String\n        infoRef: Option[AssetClass]\n    }\n\n    func validate(self) -> Bool {\n        self.switch {\n            Initializing => true,\n            VerifyingBeneficiary => true,\n            Active => true,\n            Paused{reason, infoRef} => {\n                REQT(\"... for pausing\");\n                self.validateReason(reason, infoRef)\n            },\n            Closed{reason, infoRef} => {\n                REQT(\"... for closing\");\n                self.validateReason(reason, infoRef)\n            }\n        }\n    }\n\n    func validateReason(self, reason: String, infoRef: Option[AssetClass]) -> Bool {\n        assert(true || /*never executed*/ self == self, \"prevent unused var error\");\n\n        REQT(\"the reason must be at least 12 characters\");\n        assert(reason.encode_utf8().length >= 12, \"reason < 12 - too short\");\n        infoRef.switch {\n            Some{_infoRef} => {\n                TODO(\"the InfoRef token must be referenced in the txn\");\n                assert(false, \"InfoRef not yet supported\");\n                false\n            },\n            None => true\n        }\n    }\n}\n\nenum VestingFrequency {\n    Interval {\n        interval: Duration\n        count: Int\n    }\n    Continuous\n}\n\nfunc valueTimesReal(v: Value, units: Real) -> Value {\n    Value::from_map(v\n        // .get_assets()\n        .to_map().map(\n            (policyId: MintingPolicyHash, assets: Map[ByteArray]Int) -> (MintingPolicyHash, Map[ByteArray]Int) {\n                (policyId, assets.map(\n                    (asset: ByteArray, quantity: Int) -> (ByteArray, Int) {\n                        (asset, (quantity * units).floor())\n                    }\n                ))\n            }\n        ))\n    // TBD: separate lovelace treatment only if needed\n    // +Value::lovelace(\n    //     (v.get_lovelace() * units) \n    // ).floor())\n}\n\nfunc assertIntegralUnits(units: Real) -> () {\n    assert(units == units.floor(), \"units not an integer value: \"+units.show())\n}\n\n\nstruct VestingProgress {\n    lastPartialMaturity: Time\n    vestedValue: Value\n    vestedFreqUnits: Real\n\n    func isEmpty(self) -> Bool {\n        self.lastPartialMaturity == Time::new(0) &&\n        self.vestedValue.is_zero() &&\n        self.vestedFreqUnits == 0.0\n    }\n}\n\nenum VestingDetails {\n    Once {\n        totalValue: Value\n        fullMaturity: Time\n    }\n\n    StraightLine {\n        totalValue: Value\n        fullMaturity: Time\n        vestingStart: Time \n        frequency: VestingFrequency\n        vestingProgress: VestingProgress\n    }\n\n    // stubby shorthand for later Requirements integration\n    SimpleContingency {\n        totalValue: Value\n        fullMaturity: Option[Time]\n        contingencyDescription: String\n        usesReqts: Bool\n    }    \n\n    func nextPartialMaturity(self, now: Time, frequencyUnits: Real) -> Time {\n        self.switch {\n            Once{_total, _maturity} => {\n                REQT(\"Once vesting: no partial-maturity; withdrawing now, so partial-maturity is now\");\n                now\n            },\n            SimpleContingency{_total, _fullMaturity, _description, _usesReqts} => {\n                REQT(\"SimpleContingency vesting: no partial-maturity; withdrawing now, so partial-maturity is now\");\n                now\n            },\n            StraightLine{_start, _totalValue, _fullMaturity, frequency, progress} => {\n                frequency.switch {\n                    Interval{interval, _count} => {\n                        REQT(\"Interval vesting: extends the last-partial-maturity by a integer-multiple of the interval\");\n                        assertIntegralUnits(frequencyUnits)\n\n                        progress.lastPartialMaturity + (interval * frequencyUnits.floor())\n                    },\n                    Continuous => {                        \n                        REQT(\"Continuous vesting: extends the last-partial-maturity by exactly the amount of elapsed time\");\n                        // lastPartialMaturity + ( interval * 1_000_000 * frequencyUnits) / 1_000_000\n                        now\n                    }\n                }\n            }\n        }\n    }\n\n    func vestableUnits(self, now: Time) -> Real {\n        self.switch {\n            Once{_total, maturity} => {\n                if (now < maturity) {\n                    0.0\n                } else {\n                    1.0\n                }\n            },\n            StraightLine{_totalValue, fullMaturity, start, frequency, progress} => {\n                totalVestingDuration = fullMaturity - start\n                if (now < start) {\n                    0.0\n                } else {\n                    recentInterval = now - progress.lastPartialMaturity\n                    realUnits = (recentInterval * 1_000_000 / totalVestingDuration) / 1_000_000.0\n                    frequency.switch {\n                        Interval{interval, _count} => {\n                            if (recentInterval < interval) {\n                                0.0\n                            } else {\n                                intUnits = realUnits.floor() // truncate to integer units\n                                intUnitsAsReal = 0.0 + intUnits // convert to real\n                                intUnitsAsReal\n                            }\n                        },\n\n                        Continuous => {\n                            realUnits\n                        }\n                    }\n                }\n            },\n            SimpleContingency{_total, fullMaturity, _description, _usesReqts} => {\n                fullMaturity.switch {\n                    Some{m} => {\n                        if (now < m) {\n                            print(\"SimpleContingency: maturity date not yet reached\")\n                            0.0\n                        } else {\n                            print(\"SimpleContingency: maturity has passed; vesting 100% (if conditions are met)\");\n                            1.0\n                        }\n                    },\n                    None => {\n                        print(\"SimpleContingency vesting: no maturity; vesting = 100% (if conditions are met)\");\n                        1.0\n                    }\n                }\n            }\n        }\n            \n    }\n    func isEmpty(self) -> Bool {\n        self.switch {\n            Once{_total, _maturity} => true,\n            SimpleContingency{_total, _fullMaturity, _description, _usesReqts} => true,\n            StraightLine{_totalValue, _fullMaturity, _start, _frequency, vestingProgress} => {\n                bREQT(\"Straight-line: the vesting-progress must be empty\") &&\n\n                vestingProgress.isEmpty()\n            }\n        }\n    }\n\n    func vestableValue(self, frequencyUnitsElapsed: Real) -> Value {\n        self.switch {\n            Once{totalValue, _} => {\n                valueTimesReal(totalValue, frequencyUnitsElapsed)\n            },\n            SimpleContingency{totalValue, _fullMaturity, _description, _usesReqts} => {\n                assert(frequencyUnitsElapsed == 1.0, \"frequencyUnitsElapsed not 1.0 for SimpleContingency\");\n                totalValue\n            },\n            StraightLine{totalValue, _fullMaturity, _start, frequency, _progress} => {\n                frequency.switch {\n                    Interval{_interval, _count} => {\n                        assertIntegralUnits(frequencyUnitsElapsed)\n                    }\n                }\n\n                valueTimesReal(totalValue, frequencyUnitsElapsed)\n            }\n        }\n    }\n}\n\nstruct VestingData {\n    id : ByteArray \"@id\" // = \"vest-XXXXyyyyZZZZ\"\n    type : String \"tpe\" // = \"vest\"\n\n    ownerToken: ByteArray \"onrTkn\"\n    beneficiary: VxfDestination \"vxDst\"\n    state: VestingState \"state\"\n    vestingDetails: VestingDetails \"dtls\"\n\n    func validate(self) -> Bool {\n        assert(true || /*never executed*/ self == self, \"no way\");\n        // assert(self.memberToken != null, \"memberToken is null\");\n        true\n    }\n\n    func validateCreated(self) -> Bool {\n        REQT(\"the vesting instance is created in Initializing state\");\n        assert(self.state == VestingState::Initializing, \"vesting instance is not in Initializing state\");\n\n        bREQT(\"the vesting-progress must be empty\") &&\n        self.vestingDetails.switch {\n            Once => true,\n            SimpleContingency => true,\n            StraightLine{_totalValue, _fullMaturity, _start, _frequency, vestingProgress} => {\n                vestingProgress.isEmpty().trace(\"empty vestingProgress? \")\n            }\n        }\n    }\n\n    func previous(ddd : DgDataDetails) -> VestingData {\n        VestingData::from_data(ddd.inputData())    \n    }\n\n    func updated(ddd : DgDataDetails) -> VestingData {\n        VestingData::from_data(ddd.outputData())\n    }\n\n    func validateVerifyingBeneficiary(self, nextRec: VestingData) -> Bool {\n        REQT(\"the current vesting instance must have the Initializing state\");\n        assert(self.state == VestingState::Initializing, \"vesting instance is not in Initializing state\");\n\n        REQT(\"the next vesting instance must have VerifyingBeneficiary state\");\n        assert(nextRec.state == VestingState::VerifyingBeneficiary, \"next vesting instance is not in VerifyingBeneficiary state\");\n\n        self.vestingDetails.isEmpty().trace(\"empty vestingProgress? \") &&\n\n        bREQT(\"the beneficiary is valid\") &&\n        self.beneficiary.validate(\"beneficiary\").trace(\"valid beneficiary? \") &&\n\n        true\n    }\n    \n    func validateActivating(self, tx: Tx) -> Bool {\n        REQT(\"... for Activating a vesting instance\");\n        REQT(\"the vesting instance is in VerifyingBeneficiary state\");\n        assert(self.state == VestingState::VerifyingBeneficiary, \"vesting instance is not in VerifyingBeneficiary state\");\n\n        bREQT(\"the beneficiary is valid\") &&\n        self.beneficiary.validate(\"beneficiary\").trace(\"valid beneficiary? \") &&\n\n        bREQT(\"the beneficiary is verified\") &&\n        self.beneficiary.verifyDestination(tx).trace(\"verified beneficiary? \") &&\n\n        true\n    }\n\n    func validatePausing(self, nextRec: VestingData) -> Bool {\n        REQT(\"the current vesting instance must have the Active state\");\n        assert(self.state == VestingState::Active, \"vesting instance is not in Active state\");\n\n        REQT(\"the next vesting instance must have the Paused state\");\n        assert(nextRec.state.switch {\n            p : Paused{reason, infoRef} => {\n                p.validateReason(reason, infoRef)\n            },\n            _ => false\n        }, \"next vesting instance is not in Paused state\");\n\n        REQT(\"the beneficiary must be unchanged\");\n        REQT(\"the vesting-details must be unchanged\");\n\n        \n        false\n    }\n\n}", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/Vesting/VestingData.hl", // source filename
    moduleName:  "VestingData",
});

export { VestingPolicy_hl as V, VestingData_hl as a };
//# sourceMappingURL=VestingData.mjs.map
