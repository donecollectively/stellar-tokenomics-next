import { DelegatedDataBundle, CapoHeliosBundle } from '@donecollectively/stellar-contracts';
import { makeSource } from '@helios-lang/compiler-utils';
import { V as VxfProtocol_hl } from '../VxfProtocol.mjs';

const MarketSalePolicy_hl = makeSource(
  "module MarketSalePolicy\n\n\n// this is a Helios smart contract module for managing a market sale of assets.\n// Reference Value.md for the Value type and its operations.\n\n\n\n// specialized to ...\n//   -  support MarketSale custom-data\n// original notes about (un)specialization follow:\n\n//  //! provides a basic version, ~~not yet specialized~~\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\nimport {tx, get_current_input} from ScriptContext\n\nimport {\n    TODO,\n    REQT,\n    bREQT,\n    AnyData,\n    getTimeRange,\n    endsBefore\n} from StellarHeliosHelpers\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    mkUutTnFactory\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    DgDataDetails,\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    MarketSaleData,\n    MarketSaleState,\n    SaleAssetsV1,\n    OtherSaleStateV1,\n    FixedSaleDetailsV1,\n    ThreadInfoV1,\n    MktSaleDetails\n} from MarketSaleData\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    DynamicSaleV1,\n    DTS_PurchaseInfo\n} from DynamicSaleV1\n\nenum DelegateDatum {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: MarketSaleData\n        version: Int\n        otherDetails: Data \n    }\n\n    func validateSettings(self, settings: AnyData) -> Bool {\n        assert(false, \"not valid (stubbed)\");\n        assert(settings.serialize() != self.serialize(), \"no\");\n\n        true\n    }\n}\n\nenum MintingActivity {\n    CreatingRecord {\n        seed: TxOutputId\n    }\n    SplittingSaleChunkAndBuying {\n        seed: TxOutputId\n        parentChunkId: String\n        buyingUnitQuantity: Int\n    }\n}\n\nenum SpendingActivity {\n    UpdatingRecord {\n        id: ByteArray\n    }\n\n    AddingToSale {\n        id: ByteArray\n        mph: MintingPolicyHash\n        tn: ByteArray\n    }\n    Activating {\n        id: ByteArray\n    }\n    SellingTokens {\n        id: ByteArray\n        sellingUnitQuantity: Int\n        salePrice: Value\n    }\n    MergingChildChunk {\n        id: ByteArray\n        childChunkId: String\n    }\n    Retiring {\n        id: ByteArray \n    }\n}\n\nenum BurningActivity {\n    DeletingRecord {\n        id: ByteArray\n    }\n\n    JoiningWithParentChunk {\n        // burns the indicated chunk UUT\n        // requires the parent-chunk to be updated with MergingChildChunk\n        id: String\n        parentChunkId: String\n    }\n    CleanupRetired {\n        id: String\n    }\n}\n\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        activity: BurningActivity\n    }\n    \n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // record id created from seed\n    }\n\n    UpdatingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n        activities: []Data // actually a DelegateActivity\n    }\n\n    OtherActivities {\n        activity: Data // specialized activities can be added here\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, sTxId, sIdx, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seedTxId: sTxId, \n    //         seedIdx: sIdx, \n    //         purposes: purposes,\n    //         // otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation,\n        cctx: CapoCtx\n    ) -> Bool {\n        print(\"  -- mktSalePolicy: checking additional delegate validation\");\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            CapoLifecycleActivities => {\n                // CapoLifecycleActivites are always rejected except for MINTING delegates.\n                error(\"unreachable\")\n            },\n            MintingActivities{ma} => {\n                ma.switch {\n                    SplittingSaleChunkAndBuying => { //{_,_,_/*seed, parentChunkId, buyingQuanityt*/} => {\n                        // mint of new UUT already checked\n                        \n                        //!!! it should spend the parent-chunk UUT \n                        // ... with activity-indicator SpendingActivity::SplittingToChildChunk\n                        //  ^^^ requires that the DelegatedData activities are structured \n                        //   ... with tight binding to delegate activities from this module\n                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                        error(\"SplittingSaleChunk: Implement the above details\") // ^^^\n\n                        // it should return the parent-chunk UUT to the Capo\n                        // the new chunk should have saleId pointing to the parent chunk\n                        // the new chunk should validate\n                        // the new chunk's token value should be withdrawn from the parent chunk\n                        // the new chunk's totalTokenCount should equal the withdrawn token value                        \n                    },\n                    CreatingRecord {seed} => {\n                        // mint of new UUT already checked\n                        assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                        mktSaleId : String = mkUutTnFactory(seed)(\"mktSale\");\n                        mktSaleDD : DgDataDetails = cctx.creatingDgData(mktSaleId);\n\n                        // gets the new MarketSaleData record\n                        mktSale : MarketSaleData = MarketSaleData::from_data(\n                            mktSaleDD.outputData()\n                        );\n\n                        true\n                        // validates it (general)\n                        && mktSale.validate()\n                        // validates creation details\n                        && mktSale.validateCreatedDetails()\n                        && mktSale.validatePendingDetails()\n                        && true\n                    }\n                }\n            },\n            SpendingActivities{x} => x.switch {\n                UpdatingRecord => error(\"use more specific spending activity\"),\n                AddingToSale {saleId, mph, tn} => {\n                    TODO(\"AddingToSale mktSale: test this code path\");\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    // mktSale = cctx.updatingDgData(mktSaleId)\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);\n                    \n                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);\n                    \n                    true\n                    && previous.validateAdding(mktSaleDD, mph, tn)\n                    && cctx.requiresGovAuthority().orFail()\n                },\n                Activating {saleId} => {\n                    TODO(\"Activating mktSale: test this code path\");\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    // mktSale = cctx.updatingDgData(mktSaleId)\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);\n\n                    // gets the previous MarketSaleData record\n                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);\n                    // gets the new MarketSaleData record\n                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);\n\n                    prevState = previous.v1details().saleState\n                    nextState = updated.v1details().saleState\n\n                    newValue : Value = mktSaleDD.output().value;\n                    true\n                    && cctx.requiresGovAuthority().orFail()\n                    && prevState.mustBePending(\"old\").trace(\"sale was Pending? \")\n                    && nextState.mustBeActive(\"new\").trace(\"Pending -> Active ok: \")\n                    // // validates updated record\n                    && updated.validate()\n                    && updated.validateActivating(newValue, mktSaleDD).trace(\"valid for activation: \")\n                    && true\n\n                }, \n                SellingTokens { recId, sellingUnitQuantity, unitSellPrice : Value } => {\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                    // print(\"SellingTokens: x\" + sellingUnitQuantity.show() );\n                    // print(\"               ^^\"+  recId.show());\n\n                    // gets the previous MarketSaleData record\n                    previous = MarketSaleData::previous(mktSaleDD);\n\n                    // gets the new MarketSaleData record\n                    updated = MarketSaleData::updated(mktSaleDD);\n\n                    correctActiveState = true\n                    && previous.v1details().saleState.mustBeActive(\"old\").trace(\"sale was Active? \")\n                    && updated.v1details().saleState.mustBeActive(\"new\").trace(\"sale is still Active? \")\n\n                    REQT(\"doesn't sell before the start date\")\n                    nowRange = getTimeRange(5*Duration::MINUTE);\n                    print(\"   --- now start: \" + nowRange.start.show());\n                    print(\"   --- startAt:   \" + previous.v1details().fixedSaleDetails.startAt.show());\n                    print(\"   --- now end:   \" + nowRange.end.show());\n\n                    assert(\n                        nowRange.is_after(\n                            previous.v1details().fixedSaleDetails.startAt\n                        ), \n                        \"sale not yet started\"\n                    );\n\n                    assert(sellingUnitQuantity > 0, \"must sell at least one unit\");\n                    assert(sellingUnitQuantity <= previous.v1details().saleAssets.singleBuyMaxUnits, \n                        \"attempted to buy too many units\"\n                    );\n                    prevProgress = previous.v1details().saleState.progressDetails;\n                    nextProgress = updated.v1details().saleState.progressDetails;\n\n                    TODO(\"don't gather the payments to the mktSale, but follow the VxfDestination instead\");\n                    oldValue : Value = mktSaleDD.input().value;\n                    newValue : Value = mktSaleDD.output().value;\n\n                    purchasedTokens : Value = previous.v1details().saleAssets.saleUnitAssets * sellingUnitQuantity;\n\n                    totalProgress = SaleProgressDetailsV1{\n                        lastPurchaseAt: nowRange.start,\n                        prevPurchaseAt: prevProgress.lastPurchaseAt,\n                        chunkUnitCount: nextProgress.chunkUnitCount,\n                        chunkUnitsSold: prevProgress.chunkUnitsSold + sellingUnitQuantity\n                    };\n\n                    pricingStrategy = DynamicSaleV1{\n                        settings: previous.v1details().fixedSaleDetails.settings,\n                        purchase: DTS_PurchaseInfo::create(\n                            unitsPurchased: sellingUnitQuantity,\n                            purchaseTime: nowRange.start,\n                            prevPurchaseTime: prevProgress.lastPurchaseAt,\n                            prevSalePace: previous.v1details().saleState.salePace,\n                            totalProgress: totalProgress\n                        ),\n                        sale: previous,\n                        updatedSale: Option[MarketSaleData]::Some{updated}\n                        // prevSalePace: previous.v1details().saleState.salePace,\n                        // updatedSettings: Option[DynamicSaleV1Settings]::None\n                    };\n                    \n                    // print(\"ok pricing strategy\");\n                    // unitPrice : Real = pricingStrategy.getUnitPrice();\n                    // print(\"  -- unitPrice: \" + unitPrice.show());\n\n                    // costForPurchase : Value = Value::lovelace( \n                    //     (\n                    //         // delegate this to the selected pricing strategy!\n                    //         unitPrice * sellingUnitQuantity\n                    //         * 1_000_000\n                    //     ).floor()\n                    // );\n\n                    paidValue : Value = newValue - oldValue + purchasedTokens;\n                    \n                    // print(\"  -- costForPurchase: \" + costForPurchase.show());\n                    print(\"  -- paidValue: \");\n                    print(paidValue.show());\n                    // if (!paidValue.contains(costForPurchase)) {\n                    //     error( \"insufficient payment\")\n                    // };\n                    // if (!costForPurchase.contains(paidValue)) {\n                    //     error( \"overpayment or wrong distribution of purchased tokens\")\n                    // };\n                    // print(\"  -- payment ok\");\n\n                    // todo: the purchased tokens are distributed to a\n                    //   configured sale-distribution contract (e.g. vesting/escrow/yield-farm)\n                    \n                    REQT(\"Matches redeemer payment with paid value\")\n                    assert(\n                        (\n                            paidValue == unitSellPrice * sellingUnitQuantity\n                        ).trace(\" -- found payment matching redeemer details? \"),\n                        \"actual payment/redeemer mismatch\"\n                    );\n\n                    true\n                    && correctActiveState\n                    && bREQT(\"ensures the sale record is updated with sale-progress details\")\n                    && nextProgress.validateUpdatedDetails(\n                        prevProgress, \n                        nowRange.start, \n                        sellingUnitQuantity\n                    ).trace(\"details updated correctly? \")\n                    && bREQT(\"ensures the sale record is updated with dynamic sale details\")\n                    && pricingStrategy.validateUpdatedDetails()\n                    && bREQT(\"Requires payment according to the dynamic pricing strategy\")\n                    && pricingStrategy.isRightPayment(paidValue).trace(\"  -- right payment? \")\n                    && true                    \n                    // && costForPurchase.contains(paidValue).trace(\"payment correct and tokens distributed? \")\n                    && true\n                },\n                MergingChildChunk => { //{_, _ /* recId, childChunkId */} => {\n                    error(\"todo: MergingChildChunk\")\n                },\n                Retiring => { //{_ /* recId */} => {                    \n                    error(\"todo: Retiring\")\n                    // Must not have active child chunks:\n                    // ...  previous.retiredThreads must be === previous.nestedThreads\n\n                    // updated \n                    // updated.state must be retired\n                }                \n            },\n            BurningActivities{ba} => {\n                ba.switch {\n                    DeletingRecord => error(\"use more specific burning activity\"),\n                    JoiningWithParentChunk => { //{_, _, _/* recId, parentChunkId */} => {\n                        // burns the indicated chunk UUT\n                        // requires the parent-chunk to be updated with MergingChildChunk\n                        //  ^^^ requires that the DelegatedData activities are structured \n                        //   ... with tight binding to delegate activities from this module\n                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                        error(\"todo: JoinWithParent: Implement the above details\") // ^^^\n                    },\n                    CleanupRetired => {//{_/* recId */} => {\n                        // burns the indicated chunk UUT\n\n                        error(\"todo: CleanupRetired\")\n                        // requires that the chunk is retired\n\n                        // burns the remaining previous.totalTokenCount\n\n                        // !!! todo: more details to account positively for the number of tokens actually sold\n                        //   ... by this chunk\n                        //   ... and in aggregate (this chunk and its children)\n\n                    }\n                }\n            },\n            OtherActivities => error(\n                \"no other activities exist in this delegate\"\n            ),\n            _ => false\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way\" );\n         []String{\n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation( self,\n        _priorMdd: DelegateDatum        \n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n\n// func getUnitPrice(mktSale: OutputDatum::Inline, now: Time, sellingUnitQuantity: Int) -> Real {\n//     mkPricingStrategy(\n//         MarketSaleData::from_data(mktSale.data), \n//         now, \n//         sellingUnitQuantity\n//     ).getUnitPrice()\n// }\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/MarketSalePolicy.hl", // source filename
    moduleName:  "MarketSalePolicy",
});

const MarketSaleData_hl = makeSource(
  "module MarketSaleData\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    DgDataDetails,\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\nimport {\n    VxfDestination\n} from VxfProtocol\n\nenum MarketSaleState {\n    Pending\n    Active\n    Retired\n    SoldOut\n}\n\nstruct SaleAssetsV1 {\n    saleUnitAssets: Value\n    singleBuyMaxUnits: Int\n    primaryAssetMph: MintingPolicyHash\n    primaryAssetName: ByteArray\n    primaryAssetTargetCount: Int \n    totalSaleUnits: Int\n}\n\nstruct FixedSaleDetailsV1 {\n    settings: DynamicSaleV1Settings\n    // ^ was saleStrategy: AnySaleStrategy \"strat\" \n    startAt: Time\n\n    // these details about the sale should always be sync'd to nested chunks\n    vxfTokensTo: Option[VxfDestination]\n    vxfFundsTo: Option[VxfDestination] \n}\n\nstruct OtherSaleStateV1 {\n    progressDetails: SaleProgressDetailsV1\n    salePace: Real\n    state: MarketSaleState \n    // ^ was saleStrategyState: AnySaleState \"stratState\" \n\n    func mustBeActive(self, which : String) -> Bool {\n        if (self.state == MarketSaleState::Active) {\n            true\n        } else {\n            error(which + \": state must be Active\")\n        }\n    }\n\n    func mustBePending(self, which : String) -> Bool {\n        if (self.state == MarketSaleState::Pending) {\n            true\n        } else {\n            error(which + \": state must be Pending\")\n        }\n    }\n}\n\nstruct ThreadInfoV1 {\n    // These details will always start with zero values.  \n    // They act as reference-counters, and they increment during split/join transactions\n    nestedThreads: Int\n    retiredThreads: Int\n    \n    // Each chunk should point to the chunk it was split from.  Level 1 chunks will have parentChunkId == saleId\n    parentChunkId: ByteArray \n    chunkForkedAt: Time \n\n    // saleId is empty in the root MarketSale.\n    // each split chunk should point to the root MarketSale \n    saleId: ByteArray \n}\n\nenum MktSaleDetails {\n    4000: V1 {\n        saleState: OtherSaleStateV1\n        fixedSaleDetails: FixedSaleDetailsV1\n        saleAssets: SaleAssetsV1\n        threadInfo: ThreadInfoV1 \n    }\n}\n\nstruct MarketSaleData {\n    id: ByteArray  \"@id\"\n    type: String \"tpe\"\n    name: String\n    details: MktSaleDetails \"dtl\"\n\n    // func totalSaleSize(self) -> Value {\n    //     self.moreFields.saleAssets.saleUnitAssets * self.moreFields.saleAssets.totalSaleUnits\n    // }\n\n    func v1details(self) -> MktSaleDetails::V1 {\n        self.details.switch {\n            v1: V1 => v1\n            // _ => error(\"expected V1 details\")\n        }\n    }\n\n    func validate(self) -> Bool {\n        print(\"mktSale: validate()\");\n        assert(self.type == \"mktSale\", \"wrong type\");\n        assert(self.name.serialize().length > 10, \"name must be at least 10 characters\");\n        saleAssets = self.v1details().saleAssets;\n        assert(\n            saleAssets.totalSaleUnits *\n            saleAssets.saleUnitAssets\n            .get_assets()\n                .get_policy(saleAssets.primaryAssetMph)\n                .get(saleAssets.primaryAssetName) \n            == saleAssets.primaryAssetTargetCount, \n            \"saleUnitAssets' primary-token value must divide the target-count over the sale-unit count\"\n        );\n\n        // assert(self.currentUnitPrice > 0, \"currentUnitPrice must be greater than zero\");\n\n        assert(saleAssets.saleUnitAssets.get_assets().to_map().length > 0, \"saleUnitAssets must not be empty\");\n        assert(saleAssets.totalSaleUnits > 0, \"totalSaleUnits must be greater than zero\");\n        assert(saleAssets.singleBuyMaxUnits > 0, \"singleBuyMaxUnits must be greater than zero\");\n        assert(saleAssets.singleBuyMaxUnits < saleAssets.totalSaleUnits, \"singleBuyMaxUnits must be less than totalSaleUnits\");\n\n        true\n    }\n\n    func validatePendingDetails(self) -> Bool {\n        print(\"mktSale: validatePendingDetails()\");\n        threadInfo = self.v1details().threadInfo;\n        assert(threadInfo.parentChunkId == #, \"parentChunkId must be empty\");\n        assert(threadInfo.saleId == self.id, \"saleId must be equal to id\");\n        assert(threadInfo.nestedThreads == 0, \"nestedThreads must be zero\");\n        assert(threadInfo.retiredThreads == 0, \"retiredThreads must be zero\");\n\n        true\n    }\n\n    func validateCreatedDetails(self) -> Bool {\n        print(\"mktSale: validateCreatedDetails()\");\n        saleState = self.v1details().saleState;\n        assert(saleState.salePace == 1.0, \"salePace must be initialized to 1.0\");\n        // assert(self.weightedPace == 0 * Duration::SECOND, \"weightedPace must be zero\");\n        saleDetails = self.v1details().fixedSaleDetails;\n        saleAssets = self.v1details().saleAssets;\n        true\n        && saleState.mustBePending(\"created\").trace(\"must be Pending? \")\n        && saleDetails.settings.validateCreatedDetails()\n        && saleState.progressDetails.validateCreatedDetails(\n            saleDetails.startAt, \n            saleAssets.totalSaleUnits\n        ).trace(\"progress details OK? \")\n        && true\n    }\n\n    func validateActivating(self, utxoValue: Value, DDdetails : DgDataDetails ) -> Bool {\n        print(\"mktSale: validateActivating()\");\n        prevMktSale : MarketSaleData = MarketSaleData::from_data(\n            DDdetails.inputData()\n        );\n        // expectedDatum : ByteArray = prevMktSale.copy(\n        //     state: MarketSaleState::Active\n        // ).serialize();\n        // print(\"expectedDatum: \");\n        // print(expectedDatum.show());\n        // print(\"actualDatum: \");\n        // print(self.serialize().show());\n        // assert(expectedDatum == self.serialize(), \"Activating a sale may only change the state to Active\");\n\n        assert(self.name == prevMktSale.name, \"name must not change\");\n        assert(\n            prevMktSale.v1details().saleState.mustBePending(\"old\"), \n            \"previous sale not Pending\"\n        );\n        assert(self.v1details().saleState.state == MarketSaleState::Active, \"state must be Active\");\n        // ok to change the sale start time\n        // assert(self.startAt == prevMktSale.startAt, \"startAt must not change\");\n\n        // assert(self.lastPurchaseAt == prevMktSale.lastPurchaseAt, \"lastPurchaseAt must not change\");\n        // assert(self.prevPurchaseAt == prevMktSale.prevPurchaseAt, \"prevPurchaseAt must not change\");\n\n        // assert(self.weightedPace == prevMktSale.weightedPace, \"weightedPace must not change\");\n        // ok to change the assets & sale units, as long as everthing else checks out\n        //    assert(self.saleUnitAssets == prevMktSale.saleUnitAssets, \"saleUnitAssets must not change\");\n        //    assert(self.totalSaleUnits == prevMktSale.totalSaleUnits, \"totalSaleUnits must not change\");\n        //    assert(self.singleBuyMaxUnits == prevMktSale.singleBuyMaxUnits, \"singleBuyMaxUnits must not change\");\n        //    assert(self.currentUnitPrice == prevMktSale.currentUnitPrice, \"currentUnitPrice must not change\");\n\n        assets : Value = utxoValue.get_assets() - DDdetails.uutValue();\n        print(\"expected assets: \");\n        print(assets.show());\n\n        assert(self.v1details().saleAssets.saleUnitAssets * self.v1details().saleAssets.totalSaleUnits == assets, \"utxo must contain the supply of tokens to be sold\");\n\n        REQT(\"validates VxfDestination in vxfTokensTo field\");\n        self.v1details().fixedSaleDetails.vxfTokensTo.switch {\n            Some{vxf} => {\n                assert(vxf.validate(\"vxfTokensTo\"), \"<-- that fails; this can't\");\n            },\n            None => {\n                print(\"  -- vxfTokensTo is not restricted\");\n            }\n        }\n\n        REQT(\"validates VxfDestination in vxfFundsTo field\");\n        assert(\n            (\n                self.v1details().fixedSaleDetails.vxfFundsTo.unwrap().validate(\"vxfFundsTo\")\n            ).trace(\"  -- vxfFundsTo ok? \"), \n            \"^^^ that fails; this can't\"\n        );\n\n\n        true\n        && self.validatePendingDetails() \n        && true\n    }\n\n    func previous(ddd : DgDataDetails) -> MarketSaleData {\n        MarketSaleData::from_data(ddd.inputData())    \n    }\n\n    func updated(ddd : DgDataDetails) -> MarketSaleData {\n        MarketSaleData::from_data(ddd.outputData())\n    }\n\n   func validateAdding(self, ddd : DgDataDetails, mph : MintingPolicyHash, tn: ByteArray) -> Bool {\n        updated : MarketSaleData = MarketSaleData::updated(ddd);\n        outValue : Value = ddd.output().value;\n \n        updatedAssetCount : Int = outValue.get_policy(mph).get(tn);\n                // print(\"primary tn\" + self.primaryAssetName.decode_utf8());\n                // print(\"this tn: \" + tn.decode_utf8());\n                // print(\"primary mph\" + self.primaryAssetMph.show());\n                // print(\"this mph: \" + mph.show());\n\n        currentAssets = self.v1details().saleAssets;\n        currentState = self.v1details().saleState;\n        nextAssets = updated.v1details().saleAssets;\n        nextState = updated.v1details().saleState;\n        isPrimary : Bool = ( true\n            && ( mph == currentAssets.primaryAssetMph )\n                .trace(\"    -- is primary mph? \")\n            && ( tn == currentAssets.primaryAssetName )\n                .trace(\"    -- is primary tn? \")\n        ).trace(\"  -- isPrimary? \");\n            \n        print(\"vvv ... for added tn: \"+ tn.show());\n        updatedAssetChunkSize : Int = nextAssets.saleUnitAssets.get_policy(mph).get(tn);\n        expectedAssetCount : Int = if (isPrimary) {\n            existingAssetChunkSize : Int = currentAssets.saleUnitAssets.get_policy(mph).get(tn);\n            if (updatedAssetChunkSize < existingAssetChunkSize) {\n                error(\"primary asset chunk size shouldn't decrease\")\n            };\n            print(\"    ... each sale-unit has \" + updatedAssetChunkSize.show());\n            print(\"    ... sale now supplied with \" + updatedAssetCount.show());\n            print(\"    ... ^ / saleUnits  \"+ nextAssets.totalSaleUnits.show());\n            percentSupplied = 100.0 * updatedAssetCount / nextAssets.primaryAssetTargetCount;\n            print(\"Now supplied with \"+ percentSupplied.show() +\"% of the primary token\");\n    \n            // allows that the primary tokens can be progressively funded,\n            // without disturbing the sale-unit chunk size for that primary token\n            updatedAssetCount\n        } else {            \n            isEvenChunk : Bool = updatedAssetCount % nextAssets.totalSaleUnits == 0;\n            print(\"got \"+ updatedAssetCount.show());\n            print(\"Expected chunks of \"+ nextAssets.totalSaleUnits.show());\n            if (!isEvenChunk) {\n                error(\"new non-primary asset must have an even distribution for each unit of sale\")\n            };\n\n            print(\"    ... each sale-unit has \" + updatedAssetChunkSize.show());\n            print(\"    ... ^ times sale-units  \"+ nextAssets.totalSaleUnits.show());\n\n            // non-primary tokens must have the sale-unit sync'd with the deposited value\n            expected : Int = updatedAssetChunkSize * nextAssets.totalSaleUnits;\n            print(\"Expecting the value to be = \"+ expected.show() + \" (= current Value/this-tn)\");\n            \n            expected\n        };\n        // check that the deposited assets don't exceed the number of tokens implied by the saleUnitAssets * totalSaleUnits \n        print(\"    ... updated value has \"+ updatedAssetCount.show() + \" \" + tn.show());\n        hasMatchyValue : Bool = if (updatedAssetCount != expectedAssetCount) {\n            if (isPrimary) {\n                error(\"no way\") // unreachable\n            };\n            error(\"The updated sale-units * sale-unit-count / this-tn must match the updated deposit-value / this-tn\")\n        } else { true };\n\n        true\n        && hasMatchyValue\n        && currentState.mustBePending(\"old: AddTokens\").trace(\"input sale must be Pending: \")\n        && nextState.mustBePending(\"new:AddTokens\").trace(\"updated sale must be Pending: \")\n        && updated.validate()\n        && updated.validateCreatedDetails()\n        && updated.validatePendingDetails()\n        && true\n    }\n}", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/MarketSaleData.hl", // source filename
    moduleName:  "MarketSaleData",
});

const SaleProgressDetails_hl = makeSource(
  "module SaleProgressDetails\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nstruct SaleProgressDetailsV1 {\n    lastPurchaseAt: Time \n    prevPurchaseAt: Time \n\n    chunkUnitCount: Int \n    chunkUnitsSold: Int \n\n    func validateCreatedDetails(self, \n        saleStartTime : Time, \n        totalSaleUnits : Int\n     ) -> Bool {\n        print(\"progDtls: validate\");\n        assert(self.lastPurchaseAt == saleStartTime, \"lastPurchaseAt must be equal to startAt\");\n        assert(self.prevPurchaseAt == saleStartTime, \"prevPurchaseAt must be equal to startAt\");\n        assert(self.chunkUnitCount == totalSaleUnits, \"chunkUnitCount must be equal to totalSaleUnits\");\n        assert(self.chunkUnitsSold == 0, \"chunkUnitsSold must be zero\");\n        // assert(self.lastPurchaseAt >= self.prevPurchaseAt, \"lastPurchaseAt must be greater than or equal to prevPurchaseAt\");\n        true    \n    }\n\n    func validateUpdatedDetails(\n        self, \n        prevProgress: SaleProgressDetailsV1, \n        now: Time,\n        unitsSold: Int\n    ) -> Bool {\n        print(\"SaleProgressDetails: validating update\");\n\n        REQT(\"Updates last-purchase-time to the current tx time\");\n        print(\"   ----  lastPurchaseAt: \" + self.lastPurchaseAt.show());\n        print(\"   ----  now: \" + now.show());\n        assert(\n            (self.lastPurchaseAt == now).trace(\"  -- updated lastPurchaseAt ok? \"),\n            \"lastPurchaseAt not updated correctly\"\n        );\n\n        REQT(\"Keeps a record of the prior purchase time for dynamic pacing\");\n        prevNow : Time = prevProgress.lastPurchaseAt;\n        assert(self.prevPurchaseAt == prevNow,\n            \"must update prevPurchaseAt to prev lastPurchaseAt \" + prevNow.show() + \n            \", got \" + self.prevPurchaseAt.show()\n        );\n\n        REQT(\"Updates total-sale-units to include the new units being purchased\");\n        print(\"   ----  prev unitsSold: \" + prevProgress.chunkUnitsSold.show());\n        print(\"   ----  unitsSold: \" + self.chunkUnitsSold.show());\n        assert(\n            (\n                self.chunkUnitsSold == prevProgress.chunkUnitsSold + unitsSold\n            ).trace(\"  -- updated chunkUnitsSold ok? \"),\n            \"must update progress units sold\"\n        );\n\n        REQT(\"Ensures the total number of units available for purchase is unchanged\");\n        assert(\n            (\n                self.chunkUnitCount == prevProgress.chunkUnitCount\n            ).trace(\"  -- chunkUnitCount unchanged? \"),\n            \"must not change chunk unit count\"\n        );\n        print(\"✔ progress details updated OK\");\n\n        true\n    }\n}", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/SaleProgressDetails.hl", // source filename
    moduleName:  "SaleProgressDetails",
});

const DynamicSaleV1_hl = makeSource(
  "module DynamicSaleV1\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    MarketSaleData\n} from MarketSaleData\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\n// struct DynamicSaleV1State {\n//     dynamicPace: Real \"dynaPace\"\n    \n//     func validateCreatedDetails(self) -> Bool {\n//         assert(self.dynamicPace == 1.0, \"dynamic pace must be initialized to 1.0\");\n//         true\n//     }\n// }\n\nfunc maxReal(a: Real, b: Real) -> Real {\n    // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way\");\n    if (a > b)  { a } else { b }\n}\n\nfunc minReal(a: Real, b: Real) -> Real {\n    // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way\");\n    if (a < b) { a } else { b }\n}\n\n// information about a specific, single purchase\nstruct DTS_PurchaseInfo {\n    inferredPace: Real\n    hoursSinceLastPurchase: Real\n\n    unitsPurchased: Int\n    purchaseTime: Time\n    // previousPurchaseTime: Time\n    \n    // dynamicPace: Real\n    prevSalePace: Real\n\n    totalProgress: SaleProgressDetailsV1\n\n    // func inferredPace(self) -> Real {\n    //      p : Real = \n    //      self.unitsPurchased / self.hoursSinceLastPurchase()\n    //      ;print (\"    ---- inferredPace \" + p.show());\n    //      p\n    // }\n\n    // // probably can optimize\n    // func hoursSinceLastPurchase(self) -> Real {\n    //     h : Real = \n    //      (   \n    //         (\n    //             self.purchaseTime - self.previousPurchaseTime\n    //         ) / Duration::new(1) * 1_000_000.0\n    //         / 3_600_000.0\n    //     ) / 1_000_000.0\n    //     ; print(\"    ---- hoursSinceLastPurchase \" + h.show());\n    //     h\n    // }\n    func create(\n        unitsPurchased: Int, \n        purchaseTime: Time, \n        prevPurchaseTime: Time,\n        prevSalePace: Real,\n        totalProgress: SaleProgressDetailsV1\n    ) -> DTS_PurchaseInfo {\n        // using Ratio adds some library size to the bundle\n        // hoursSinceLastPurchase  = Ratio::new(\n        //     (purchaseTime - prevPurchaseTime) / Duration::MINUTE,\n        //     60\n        // )\n        hoursSinceLastPurchase : Real = (\n            (purchaseTime - prevPurchaseTime) / Duration::new(1)* 1_000_000.0/ \n            3_600_000.0\n        ) / 1_000_000.0;\n        REQT(\"Infers the pace of the current purchase\")\n        print(\"      ---- unitsPurchased \" + unitsPurchased.show());\n        print(\"      ---- hoursSinceLastPurchase \" + hoursSinceLastPurchase.show());\n        // inferredPace = Ratio::new(\n        //     unitsPurchased, 1\n        // ) / hoursSinceLastPurchase;\n        inferredPace : Real = unitsPurchased / hoursSinceLastPurchase;\n        print(\"  -- inferredPace \" + inferredPace.show());\n        DTS_PurchaseInfo{\n            inferredPace: inferredPace,\n            hoursSinceLastPurchase: hoursSinceLastPurchase,\n            unitsPurchased: unitsPurchased,\n            purchaseTime: purchaseTime,\n            // previousPurchaseTime: prevPurchaseTime,\n            prevSalePace: prevSalePace,\n            totalProgress: totalProgress\n        }\n    }\n}\n\nstruct DynamicSaleV1 {\n    settings: DynamicSaleV1Settings\n    purchase: DTS_PurchaseInfo\n\n    sale: MarketSaleData\n    updatedSale: Option[MarketSaleData]\n    \n    // prevSalePace: Real\n    // updatedSettings: Option[DynamicSaleV1Settings]\n    // updatedState: DynamicSaleV1State\n\n    func isRightPayment(self, payment: Value) -> Bool {\n        expected : Real = self.unitPriceForSale() * self.purchase.unitsPurchased;\n        actual : Real = payment.get_lovelace() / 1_000_000.0;\n        \n        print(\"    ---- expected payment \" + expected.show());\n        print(\"    ---- actual payment \" + actual.show() + \" +/- 0.000002\");\n        assert(payment.get_assets().is_zero(), \"non-ADA assets not yet supported here\");\n\n    if ( (actual - expected).abs() > 0.000002) {\n            error(\"payment amount is not correct\")\n        };\n        true\n    }\n\n    // func updatedSettings(self) -> DynamicSaleV1Settings {\n    //     self.updatedSale.switch {\n    //         None => error(\"must have updatedSale during tx validation\"),\n    //         Some{sale} => {\n    //             AnySaleStrategy::from_data(sale.saleStrategy).switch {\n    //                 DynamicSaleV1{settings /* DynamicSaleV1Settings */ } => settings,\n    //                 _ => error(\"no way\") // should never happen\n    //             }\n    //         }\n    //     }\n    // }\n\n    func unitPriceForSale(self) -> Real {\n        // paceThisPurchase : Real = self.purchase.inferredPace(); // units / hours-since-last-purchase\n        print(\"    ---- target price \" + self.settings.targetPrice.show());\n        targetPrice = self.settings.targetPrice\n        price: Real = targetPrice\n            * self.pricingFactorOverallProgress()\n            * self.pricingFactorDynamicPace();\n            print(\"    ---- unitPriceForSale - unclamped \" + price.show());\n\n        // clamp the price to min/max limits\n        clamped : Real = minReal(\n            maxReal(price, self.settings.minPrice),\n            self.settings.maxPrice\n        );\n        print(\"    -- unitPriceForSale: clamped = \" + clamped.show());\n        clamped\n    }\n\n    func validateUpdatedDetails(self) -> Bool {\n        print(\"DynamicSaleV1: validating updated details\");\n        upd : MarketSaleData = self.updatedSale.switch {\n            None => error(\"must have updatedSale during tx validation\"),\n            Some{s} => s\n        };\n        REQT(\"EXPECTS the basic SaleProgressDetails to be validated separately\")\n\n        REQT(\"The sale settings must not be changed\");\n        prevSettings : DynamicSaleV1Settings = self.settings;\n        nextSettings = upd.v1details().fixedSaleDetails.settings;\n        assert(\n            (\n                prevSettings == nextSettings\n            ).trace(\"  -- settings unchanged? \"), \n            \"settings were changed\"\n        );\n\n        expectedPace : Real = self.nextSalePace();\n        nextPace : Real = upd.v1details().saleState.salePace;\n\n        // prevState : SaleProgressDetails = self.purchase.totalProgress;\n\n        REQT(\"Updates the nextPace to reflect the ongoing dynamic sale progress\");\n        print(\"  ---- updated salePace: \" + nextPace.show());\n        assert(\n            (\n                (nextPace - expectedPace).abs() < 0.000005\n            ).trace(\"  -- nextPace ok? \"),\n            \"wrong next salePace in updated sale, expected \" + expectedPace.show()\n        );\n\n        REQT(\"Guards against underflow in dynamic pace calculations, by enforcing a minimum chunk age\");\n        chunkAge : Duration = upd.v1details().saleState.progressDetails.lastPurchaseAt\n            - self.sale.v1details().saleState.progressDetails.lastPurchaseAt;\n\n        print(\"  ---- chunkAge: \" + chunkAge.show());\n        assert(\n            (chunkAge >= 10 * Duration::MINUTE).trace(\"  -- chunkAge ok? \"),\n            \"sale chunk too fresh (less than 10 minutes)\"\n        );\n\n        true\n    }\n\n    func actualSellingPace(self) -> Real {\n        t : Real = (\n            self.purchase.unitsPurchased\n            + self.sale.v1details().saleState.progressDetails.chunkUnitsSold \n        ) / self.elapsedSaleHours();\n        print(\"    ---- actualSellingPace \" + t.show());\n        t\n    }\n\n    func targetSellingPace(self) -> Real {\n        // print(\"selling time \" + self.settings.targetedSellingTime.show());\n        // print(\"  -- in hours\" + (100 *  self.settings.targetedSellingTime / Duration::HOUR / 100.0).show());\n        chunkUnitCount : Int = self.purchase.totalProgress.chunkUnitCount;\n        // print(\"chunkUnitCount\"+ self.purchase.totalProgress.chunkUnitCount.show());\n        t : Real = \n         (chunkUnitCount + 0.0) / (\n             self.settings.targetedSellingTime * 100 / Duration::HOUR / 100.0\n        ) \n\n        ; print( \"    ---- targetSellingPace \" + t.show());\n        t\n\n        // returns the CHUNK-RELATIVE selling pace\n        // ^^^ distinct from sale-aggregate pace vvv\n        // return self.sale.totalSaleUnits / self.settings.targetedSellingTime\n    }\n\n    func elapsedSaleHours(self) -> Real {\n        h : Real = \n        ( self.purchase.purchaseTime - self.sale.v1details().fixedSaleDetails.startAt ) * 1_000_000 / Duration::HOUR / 1_000_000.0\n        ;print(\"    ---- elapsedSaleHours \" + h.show());\n        h\n    }\n\n    // 5000 hours = 208.3333333333333 days\n   // = 5000 * 3600 * 1000 = 18_000_000_000 ms\n   // 5 minutes = 60 * 5 * 1000 = 300_000 ms\n    // at the 5 minute mark, the total pace would be  300 / 18_000_000 = 0.000017\n    // this is okay, though it's near the lower limit of Helios fixed-point precision\n\n    // using elapsedSaleHours in actualSellingPace helps avoid underflow that could otherwise\n    // arise when using elapsed time MS / targetSellingTime, when the target time is very large\n\n    // if the actual selling pace is near 0, then the overall pace will also be near 0\n    //   ... or worst case, actually 0 due to underflow.\n\n    func overallPaceIncludingThisPurchase(self) -> Real {\n        op : Real = \n        self.actualSellingPace() / self.targetSellingPace()\n        ;print(\"    ---- overallPaceIncludingThisPurchase \" + op.show());\n        op\n        \n        // // fraction of time elapsed can be by hours, but it can just as easily use milliseconds; \n        // // ... the HOURs (or ms) cancel each other out in the division.\n        // timeProgress: Real  = self.elapsedTime() / self.settings.targetedSellingTime\n\n        // saleProgress : SaleProgressDetails = self.purchase.totalProgress;\n        // unitsProgress : Real = saleProgress.chunkUnitsSold / saleProgress.chunkUnitCount;\n\n        // // net overall pacing is the portion of units sold vs the portion of time elapsed\n        // unitsProgress / timeProgress\n    }\n\n    func pricingFactorDynamicPace(self) -> Real {\n        // from Google Sheet:\n        // =max(0.5,(\n        //     LET(prevWeight, 1\n        //    ,LET(prevPace, recent_pace_in\n        //    ,LET(nextPace, recent_pace_out\n        //    ,LET(nextWeight, weightNextDynaPace,\n        //     ( \n        //         IF(prevPace=0,1,\n        //           prevPace / targetSellingPace\n        //         ) * prevWeight\n        //       + IF(nextPace=0,1,\n        //          nextPace / targetSellingPace\n        //         ) * nextWeight \n        //     ) / ( prevWeight +nextWeight )\n        //   ))))\n        //   ))\n\n        // the weight of the previous dyanamic pace\n        prevWeight : Real = 1.0;\n        nextPace : Real = self.nextSalePace();\n        prevPace : Real = self.purchase.prevSalePace;\n        // the weight of the next dynamic pace is variable\n        nextWeight : Real = self.settings.pricingWeightDynaPace;\n        targetSellingPace : Real = self.targetSellingPace();\n        r : Real = \n        ( \n            if (prevPace == 0) { 1.0 } else { \n                prevPace / targetSellingPace\n            } * prevWeight\n            + if (nextPace == 0) { 1.0 } else { \n                nextPace / targetSellingPace\n            } * nextWeight\n        ) / (prevWeight + nextWeight)\n\n        ;print(\"  -- pricingFactorDynamicPace \" + r.show());\n        r\n    }\n\n    func nextSalePace(self) -> Real {\n        // from Google Sheet:\n        // = LET(nextWeight, \n        //     if(purchase_inferred_pace > prev_dyna_pace,\n        //         dynaPaceFasterSaleWeight,\n        //         if (purchase_inferred_pace/targetSellingPace > 1,\n        //           purchase_inferred_pace/targetSellingPace,\n        //           max(1,time_lag * dynaPaceIdleDecayRate)\n        //         )\n        //       ),\n        //      ( purchase_inferred_pace*nextWeight\n        //        + prev_dyna_pace\n        //      ) / (1+nextWeight)\n        //   )\n        purchase : DTS_PurchaseInfo = self.purchase;\n        settings : DynamicSaleV1Settings = self.settings;\n        // sale : MarketSaleData = self.sale;\n        \n        REQT(\"Computes the next sale pace, escalating when the pace increases or decaying when the pace below the target pace\");\n        inferredPace : Real = purchase.inferredPace;\n        print(\"    ---- inferredPace \" + inferredPace.show());\n        nextPaceWeight : Real = if (inferredPace > purchase.prevSalePace) {\n            // this buyer is buying faster than the previous pace,\n            //  ... indicating strong demand and likely opportunity to get a higher price\n            //  ... or at least for that higher price to make space for easing buyer exuberance\n            print(\"    ---- nextPaceWeight: dynaPaceFasterSaleWeight (sale is speeding up)\");\n            settings.dynaPaceFasterSaleWeight\n        } else {\n            if (inferredPace > self.targetSellingPace()) {\n                // the pace is slowing down some, but still selling faster than the target pace\n                //   ... so it's not necessary to soften the price for this buyer or apply an idle-decay\n                // this lets the dynamic pace evolve gently downward to reflect\n                //   ... that the \"recent pace\" isn't quite as fast as it was.\n                // This works in opposition to the escalation effect of the increasing pace.\n                // The current buy will be at higher price than the previous one,\n                //   ... but if the next buy is \"at target pace\", then it will be at a lower price,\n                //   ... reflecting the lower demand pressure.\n                //   ... This creates a small window for a single buyer to game a slightly\n                //   ... lower price, but other people can slip in and buy at that price too. \n                print(\"    ---- nextPaceWeight: 1.0 (sale is proceeding faster than target pace)\");\n                1.0\n            } else {\n                // The pace has slowed significantly - not only lower demand pressure,\n                //   ... but the new buy happened slower than the target pace.  This\n                //   ... clearly indicates that the exuberance-limitations above worked,\n                //   ... slowing down the pace.  This is a good thing, because it means\n                //   ... a more moderate price.\n                // If it's been a short time, we don't give this buyer the benefit\n                //   ... of the idle-decay, as a buyer could just be trying to\n                //   ... game the system by sandbagging the pace, only to take advantage \n                //   ... of that lower pace.\n                // However, if it's actually been a significant amount of time, and other \n                //   ... buyers have had a chance to buy at a consensually supportable price, \n                //   ... then clearly it's important to reduce the price for this buyer.\n                // Without the idle-decay, the pricing would remain high, and likely\n                //   ... the sale would stall out.\n                // This applies the decay rate in the form of a > 1.0, or stronger, weight \n                //   ... of the slower pace, reducing the next-dynamic-pace \n                //   ... as well as the current price.\n                print(\"    ---- nextPaceWeight: slowing sale; using dynaPaceIdleDecayRate \");\n                print(\"      ---- hoursSinceLastPurchase \" + purchase.hoursSinceLastPurchase.show());\n                print(\"      ---- * dynaPaceIdleDecayRate \" + settings.dynaPaceIdleDecayRate.show());\n                result = maxReal(\n                    1.0, purchase.hoursSinceLastPurchase * settings.dynaPaceIdleDecayRate\n                )\n                print(\"  -- nextPaceWeight = \" + result.show());\n                result\n            }\n        };\n        print(\"    ---- nextPaceWeight \" + nextPaceWeight.show());\n        psp : Real = purchase.prevSalePace;\n        print(\"    ---- prev salePace \" + psp.show());\n\n        nextDynamicPace : Real = (inferredPace * nextPaceWeight + psp) \n            / (nextPaceWeight + 1)\n        print(\"    ---- next salePace: \" + nextDynamicPace.show());\n        nextDynamicPace\n    }\n\n\n    func pricingFactorOverallProgress(self) -> Real {\n        // from Google Sheet:\n        // = LET(ceilingHeight, 1-paceDiscountFloorPoint\n        //     ,LET(aboveFloor,current_pace-paceDiscountFloorPoint\n        //     ,LET(relativeHeight, if(aboveFloor<=0,0, aboveFloor/ceilingHeight)\n        //     ,LET(discountDepth,1-relativeHeight\n        //     , LET(discountEarned, \n        //       discountDepth*paceDiscountWhenSlow\n        //     , LET(clampedMaxDiscount,\n        //       MAX(0,MIN(discountEarned, paceDiscountWhenSlow))\n        //     , LET(priceExpansion,\n        //       if(current_pace<1,1, \n        //          1+(\n        //            (current_pace-1)*(1+paceExpansionWhenFast)/3\n        //          )\n        //       )\n        //     , LET(RESULT, \n        //       (1-clampedMaxDiscount) * priceExpansion,  \n        //       RESULT\n        //     ))))))))\n\n        settings : DynamicSaleV1Settings = self.settings;\n        overallPacingProgress : Real = self.overallPaceIncludingThisPurchase();\n        discountEarned : Real = self.progressPricingDiscountDepth(overallPacingProgress) * \n           settings.progressPricingDiscountWhenSlow;\n        print(\"      ---- unclamped discountEarned \" + discountEarned.show());\n        clampedMaxDiscount : Real = maxReal(\n            0.0, minReal(\n                discountEarned, settings.progressPricingDiscountWhenSlow\n            )\n        );\n        print(\"      ---- clampedDiscount \" + clampedMaxDiscount.show());\n\n        r : Real = \n        (1 - clampedMaxDiscount) * self.priceExpansion(overallPacingProgress)\n        ;print(\"  -- pricingFactorOverallProgress \" + r.show());\n        r\n    }\n\n    func priceExpansion(self, overallPace: Real) -> Real {\n        expansion : Real = if (overallPace < 1.0) {\n            1.0\n        } else {\n            1.0 + (\n                (overallPace - 1.0) \n                * (1.0 + self.settings.progressPricingExpansionWhenFast) \n                / 3.0\n            )\n        }\n        ;print(\"    ---- priceExpansion \" + expansion.show());\n        expansion\n    }\n\n    func progressPricingDiscountDepth(self, overallPace: Real) -> Real {\n        settings : DynamicSaleV1Settings = self.settings;        \n\n        print(\"      ---- pPDD overallPace \" + overallPace.show());\n        ceilingHeight : Real = 1.0 - settings.progressPricingDiscountFloorPoint;       \n        // = 0.5 to 0.95\n\n        \n        aboveFloor : Real = if (overallPace > settings.progressPricingDiscountFloorPoint) {\n            overallPace - settings.progressPricingDiscountFloorPoint\n        } else {  0.0 };\n        relativeHeight : Real = if ( aboveFloor <= 0 ) { 0.0 } else { aboveFloor / ceilingHeight };\n        \n        print(\"      ---- pPDD ceilingHeight \" + ceilingHeight.show());\n        print(\"      ---- pPDD aboveFloor \" + aboveFloor.show());\n        print(\"      ---- pPDD relativeHeight \" + relativeHeight.show());\n\n        ppdd : Real = 1 - relativeHeight\n        print(\"    ---- progressPricingDiscountDepth \" + ppdd.show());\n        ppdd\n    }\n}\n\n// use this pattern inline, instead of as a function, to enable\n// optimizations in the surrounding code for accessing the various\n// details mentioned\n//\n// func mkSaleController(\n//     prevMktSale: MarketSaleData, \n//     now: Time, \n//     sellingUnitQuantity: Int,\n//     updatedSale: Option[MarketSaleData] = Option[MarketSaleData]::None\n// ) -> DynamicSaleV1 {\n//     prevProgress : SaleProgressDetails = prevMktSale.progressDetails;\n//     totalProgress: SaleProgressDetails = SaleProgressDetails{\n//         lastPurchaseAt: now,\n//         prevPurchaseAt: prevProgress.lastPurchaseAt,\n//         chunkUnitCount: prevProgress.chunkUnitCount,\n//         chunkUnitsSold: prevProgress.chunkUnitsSold + sellingUnitQuantity\n//     };\n//     prevPace : Real = prevMktSale.salePace;\n//     DynamicSaleV1{\n//         settings: prevMktSale.saleSettings,\n//         purchase: DTS_PurchaseInfo{\n//             unitsPurchased: sellingUnitQuantity,\n//             purchaseTime: now,\n//             previousPurchaseTime: prevProgress.lastPurchaseAt,\n//             prevSalePace: prevPace,\n//             totalProgress: totalProgress\n//         },\n//         sale: prevMktSale,\n//         updatedSale: updatedSale,\n//         prevSalePace: prevPace,\n//         updatedSettings: Option[DynamicSaleV1Settings]::None\n//     }\n// }\n\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/DynamicSaleV1.hl", // source filename
    moduleName:  "DynamicSaleV1",
});

const DynamicSaleV1Settings_hl = makeSource(
  "module DynamicSaleV1Settings\n\nstruct DynamicSaleV1Settings {\n    targetPrice: Real  // same as targetPriceBenchmark\n    targetedSellingTime: Duration  \n\n    minPrice: Real  // same as minSalePrice\n    maxPrice: Real  // same as maxSalePrice\n\n    // 0.20 by default\n    progressPricingDiscountFloorPoint: Real // same as paceDiscountFloorPoint\n    // 0.25 by default\n    progressPricingDiscountWhenSlow: Real  // same as paceDiscountWhenSlow\n    // 0.20 by default\n    progressPricingExpansionWhenFast: Real // same as paceExpansionWhenFast\n\n    // 0.3 by default\n    dynaPaceFasterSaleWeight: Real \n    // 0.5 by default\n    dynaPaceIdleDecayRate: Real \n\n    // 5 by default\n    pricingWeightDynaPace: Real  // same as weightNextDynaPace\n\n    func validateCreatedDetails(self) -> Bool {\n        assert(self.progressPricingDiscountFloorPoint > 0.05, \"floor point too low\");\n        assert(self.progressPricingDiscountFloorPoint < 0.50, \"floor point too high\");\n        assert(self.progressPricingDiscountWhenSlow >= 0.0, \"negative discount\");\n        assert(self.progressPricingDiscountWhenSlow < 1.0, \"discount too high\");\n        assert(self.progressPricingExpansionWhenFast > 0.05, \"expansion too low\");\n        assert(self.progressPricingExpansionWhenFast < 10.0, \"expansion too high\");\n        assert(self.dynaPaceFasterSaleWeight >= 0.0, \"faster weight negative\");\n        assert(self.dynaPaceFasterSaleWeight < 2.0, \"faster weight way too high\");\n        assert(self.dynaPaceIdleDecayRate >= 0.0, \"negative decay rate\");\n        assert(self.dynaPaceIdleDecayRate < 2.0, \"decay rate too high\");\n        assert(self.pricingWeightDynaPace >= 0.0, \"dyna pace weight negative\");\n        assert(self.pricingWeightDynaPace < 15, \"dyna pace weight way too high\");\n\n        true\n    }\n\n    // func validateUpdatedDetails(self) -> Bool {\n\n    //     true\n    // }\n}\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/DynamicSaleV1Settings.hl", // source filename
    moduleName:  "DynamicSaleV1Settings",
});

class MarketSaleBundle extends DelegatedDataBundle.usingCapoBundleClass(
  CapoHeliosBundle,
  "generic"
) {
  precompiledScriptDetails = {
    singleton: {
      scriptHash: "7c1cc6c7df8b32c9f6e33e445361dc20b416a44959d7ac54a7e73863",
      config: { "rev": "1", "delegateName": "MarketSalePolicy", "isMintDelegate": false, "isSpendDelegate": false, "isDgDataPolicy": true, "requiresGovAuthority": true }
    }
  };
  scriptParamsSource = "bundle";
  async loadPrecompiledVariant(variant) {
    const module = await import('stellar-tokenomics/contracts-preprod/MarketSale.compiled.hlb');
    const foundVariant = module.precompiled[variant];
    if (!foundVariant) {
      throw new Error(`unknown variant: ${variant}`);
    }
    return foundVariant;
  }
  specializedDelegateModule = MarketSalePolicy_hl;
  requiresGovAuthority = true;
  get modules() {
    return [
      ...super.modules,
      MarketSaleData_hl,
      SaleProgressDetails_hl,
      DynamicSaleV1_hl,
      DynamicSaleV1Settings_hl,
      VxfProtocol_hl
    ];
  }
}

export { MarketSaleBundle, MarketSaleBundle as default };
//# sourceMappingURL=MarketSale.hlb.mjs.map
