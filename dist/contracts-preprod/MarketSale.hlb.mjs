import { DelegatedDataBundle, CapoHeliosBundle } from '@donecollectively/stellar-contracts';
import { makeSource } from '@helios-lang/compiler-utils';
import { V as VxfProtocol_hl } from '../VxfProtocol.mjs';

const MarketSalePolicy_hl = makeSource(
  "module MarketSalePolicy\n\n\n// this is a Helios smart contract module for managing a market sale of assets.\n// Reference Value.md for the Value type and its operations.\n\n\n\n// specialized to ...\n//   -  support MarketSale custom-data\n// original notes about (un)specialization follow:\n\n//  //! provides a basic version, ~~not yet specialized~~\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\nimport {tx, get_current_input} from ScriptContext\n\nimport {\n    TODO,\n    REQT,\n    bREQT,\n    assertREQTgroup,\n    REQTgroup,\n    REQTgroupUnit,\n    logGroupUnit,\n    logGroupStart,\n    logGroupEnd,\n    AnyData,\n    logGroup,\n    getTimeRange,\n    endsBefore\n} from StellarHeliosHelpers\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    mkUutTnFactory\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    DgDataDetails,\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    MarketSaleData,\n    MarketSaleState,\n    SaleAssetsV1,\n    OtherSaleStateV1,\n    FixedSaleDetailsV1,\n    ThreadInfoV1,\n    MktSaleDetails\n} from MarketSaleData\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    DynamicSaleV1,\n    DTS_PurchaseInfo\n} from DynamicSaleV1\n\nenum DelegateDatum {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: MarketSaleData\n        version: Int\n        otherDetails: Data \n    }\n\n    func validateSettings(self, settings: AnyData) -> Bool {\n        assert(false, \"not valid (stubbed)\");\n        assert(settings.serialize() != self.serialize(), \"no\");\n\n        true\n    }\n}\n\nenum MintingActivity {\n    CreatingRecord {\n        seed: TxOutputId\n    }\n    SplittingSaleChunkAndBuying {\n        seed: TxOutputId\n        parentChunkId: String\n        lotsPurchased: Int\n    }\n}\n\nenum SpendingActivity {\n    UpdatingRecord {\n        id: ByteArray\n    }\n\n    AddingToSale {\n        id: ByteArray\n        mph: MintingPolicyHash\n        tn: ByteArray\n    }\n    UpdatingPendingSale {\n        id: ByteArray\n    }\n    Activating {\n        id: ByteArray\n    }\n    SellingTokens {\n        id: ByteArray\n        lotsPurchased: Int\n        salePrice: Value\n    }\n    MergingChildChunk {\n        id: ByteArray\n        childChunkId: String\n    }\n    Retiring {\n        id: ByteArray \n    }\n}\n\nenum BurningActivity {\n    DeletingRecord {\n        id: ByteArray\n    }\n\n    JoiningWithParentChunk {\n        // burns the indicated chunk UUT\n        // requires the parent-chunk to be updated with MergingChildChunk\n        id: String\n        parentChunkId: String\n    }\n    CleanupRetired {\n        id: String\n    }\n}\n\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        activity: BurningActivity\n    }\n    \n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // record id created from seed\n    }\n\n    UpdatingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // no seed\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n        activities: []Data // actually a DelegateActivity\n    }\n\n    OtherActivities {\n        activity: Data // specialized activities can be added here\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, sTxId, sIdx, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seedTxId: sTxId, \n    //         seedIdx: sIdx, \n    //         purposes: purposes,\n    //         // otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation,\n        cctx: CapoCtx\n    ) -> Bool {\n        print(\"  -- mktSalePolicy: checking additional delegate validation\");\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            CapoLifecycleActivities => {\n                // CapoLifecycleActivites are always rejected except for MINTING delegates.\n                error(\"unreachable\")\n            },\n            MintingActivities{ma} => {\n                ma.switch {\n                    SplittingSaleChunkAndBuying => { //{_,_,_/*seed, parentChunkId, buyingQuanityt*/} => {\n                        // mint of new UUT already checked\n                        \n                        //!!! it should spend the parent-chunk UUT \n                        // ... with activity-indicator SpendingActivity::SplittingToChildChunk\n                        //  ^^^ requires that the DelegatedData activities are structured \n                        //   ... with tight binding to delegate activities from this module\n                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                        error(\"SplittingSaleChunk: Implement the above details\") // ^^^\n\n                        // it should return the parent-chunk UUT to the Capo\n                        // the new chunk should have saleId pointing to the parent chunk\n                        // the new chunk should validate\n                        // the new chunk's token value should be withdrawn from the parent chunk\n                        // the new chunk's totalTokenCount should equal the withdrawn token value                        \n                    },\n                    CreatingRecord {seed} => {\n                        // mint of new UUT already checked\n                        assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                        mktSaleId : String = mkUutTnFactory(seed)(\"mktSale\");\n                        mktSaleDD : DgDataDetails = cctx.creatingDgData(mktSaleId);\n\n                        // gets the new MarketSaleData record\n                        created : MarketSaleData = MarketSaleData::updated(mktSaleDD);\n\n                        true\n                        && created.validateDetailsWhenPending(\"creating record\")\n                        && created.validatePrimaryAssetOnlyOnCreation()\n                        && cctx.requiresGovAuthority().orFail()\n                    }\n                }\n            },\n            SpendingActivities{x} => x.switch {\n                UpdatingRecord => error(\"use more specific spending activity\"),\n                UpdatingPendingSale{saleId} => logGroup(\"UpdatingPendingSale:\", false, () -> Bool {\n                    TODO(\"UpdatingPendingSale mktSale: test this code path\");\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);\n                    \n                    nextRec : MarketSaleData = MarketSaleData::updated(mktSaleDD);\n\n                    true\n                    && nextRec.validateUpdatePendingSale(mktSaleDD)\n                    && cctx.requiresGovAuthority().orFail()\n                }),\n\n                AddingToSale {saleId, mph, tn} => logGroup(\"AddingToSale:\", false, () -> Bool {\n                    TODO(\"AddingToSale: test this code path\");\n    \n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);\n                    next : MarketSaleData = MarketSaleData::updated(mktSaleDD);\n                    true\n                    && next.validateDetailsWhenPending(\"adding to sale\")\n                    && next.validateAdding(mktSaleDD, mph, tn)\n                    && cctx.requiresGovAuthority().orFail()\n                }),\n                Activating {saleId} => logGroup(\"Activating sale:\", false, () -> Bool {\n                    TODO(\"test this code path\");\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    // mktSale = cctx.updatingDgData(mktSaleId)\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);\n\n                    // gets the previous MarketSaleData record\n                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);\n                    // gets the new MarketSaleData record\n                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);\n\n                    prevState = previous.v1details().saleState\n                    nextState = updated.v1details().saleState\n\n                    prevState.mustBePending(\"previous sale\")\n                    nextState.mustBeActive(\"updated sale: activating\")\n\n                    newValue : Value = mktSaleDD.output().value;\n                    true\n                    && cctx.requiresGovAuthority().orFail()\n                    // // validates updated record\n                    && updated.validate()\n                    && updated.validateActivating(newValue, mktSaleDD)\n                    && true\n                }), \n                SellingTokens { recId, lotsPurchased, lotSellPrice : Value } => logGroup(\"SellingTokens:\", false, () -> Bool {\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);\n                    // print(\"SellingTokens: x\" + lotsPurchased.show() );\n                    // print(\"               ^^\"+  recId.show());\n\n                    // gets the previous MarketSaleData record\n                    previous = MarketSaleData::previous(mktSaleDD);\n\n                    // gets the new MarketSaleData record\n                    updated = MarketSaleData::updated(mktSaleDD);\n\n                    correctActiveState = true\n                    previous.v1details().saleState.mustBeActive(\"previous sale\")\n                    updated.v1details().saleState.mustBeActive(\"updated sale: selling tokens\")\n\n                    REQT(\"doesn't sell before the start date\")\n                    nowRange = getTimeRange(5*Duration::MINUTE);\n                    nowRangeStartStr = nowRange.start.show(); /** todo: inline */\n                    print(\"   --- now start: \" + nowRangeStartStr);\n                    startAtStr = previous.v1details().fixedSaleDetails.startAt.show(); /** todo: inline */\n                    print(\"   --- startAt:   \" + startAtStr);\n                    nowRangeEndStr = nowRange.end.show(); /** todo: inline */\n                    print(\"   --- now end: \" + nowRangeEndStr);\n\n                    assert(\n                        nowRange.is_after(\n                            previous.v1details().fixedSaleDetails.startAt\n                        ), \n                        \"sale not yet started\"\n                    );\n\n                    assert(lotsPurchased > 0, \"must sell at least one lot\");\n                    assert(lotsPurchased <= previous.v1details().saleAssets.singleBuyMaxLots, \n                        \"attempted to buy too many lots\"\n                    );\n                    prevProgress = previous.v1details().saleState.progressDetails;\n                    nextProgress = updated.v1details().saleState.progressDetails;\n\n                    TODO(\"don't gather the payments to the mktSale, but follow the VxfDestination instead\");\n                    oldValue : Value = mktSaleDD.input().value;\n                    newValue : Value = mktSaleDD.output().value;\n\n                    purchasedTokens : Value = previous.v1details().saleAssets.saleLotAssets * lotsPurchased;\n\n                    totalProgress = SaleProgressDetailsV1{\n                        lastPurchaseAt: nowRange.start,\n                        prevPurchaseAt: prevProgress.lastPurchaseAt,\n                        lotCount: nextProgress.lotCount,\n                        lotsSold: prevProgress.lotsSold + lotsPurchased\n                    };\n\n                    pricingStrategy = DynamicSaleV1{\n                        settings: previous.v1details().fixedSaleDetails.settings,\n                        purchase: DTS_PurchaseInfo::create(\n                            lotsPurchased: lotsPurchased,\n                            purchaseTime: nowRange.start,\n                            prevPurchaseTime: prevProgress.lastPurchaseAt,\n                            prevSalePace: previous.v1details().saleState.salePace,\n                            totalProgress: totalProgress\n                        ),\n                        sale: previous,\n                        updatedSale: Option[MarketSaleData]::Some{updated}\n                        // prevSalePace: previous.v1details().saleState.salePace,\n                        // updatedSettings: Option[DynamicSaleV1Settings]::None\n                    };\n                    \n                    // print(\"ok pricing strategy\");\n                    // lotPrice : Real = pricingStrategy.getlotPrice();\n                    // print(\"  -- lotPrice: \" + lotPrice.show());\n\n                    // costForPurchase : Value = Value::lovelace( \n                    //     (\n                    //         // delegate this to the selected pricing strategy!\n                    //         lotPrice * lotsPurchased\n                    //         * 1_000_000\n                    //     ).floor()\n                    // );\n\n                    paidValue : Value = newValue - oldValue + purchasedTokens;\n                    \n                    // print(\"  -- costForPurchase: \" + costForPurchase.show());\n                    print(\"  -- paidValue: \");\n                    print(paidValue.show());\n                    // if (!paidValue.contains(costForPurchase)) {\n                    //     error( \"insufficient payment\")\n                    // };\n                    // if (!costForPurchase.contains(paidValue)) {\n                    //     error( \"overpayment or wrong distribution of purchased tokens\")\n                    // };\n                    // print(\"  -- payment ok\");\n\n                    // todo: the purchased tokens are distributed to a\n                    //   configured sale-distribution contract (e.g. vesting/escrow/yield-farm)\n                    \n                    assertREQTgroup(\"Matches redeemer payment with paid value\", false, () -> Bool {\n                        print(\"  -- paidValue: \"+ paidValue.show());\n                        print(\"  -- lotSellPrice: \"+ lotSellPrice.show());\n                        print(\"  -- lotsPurchased: \"+ lotsPurchased.show());\n                        expectedPayment = lotSellPrice * lotsPurchased;\n                        print(\"  -- expected payment: \"+ expectedPayment.show());\n                        print(\"  -- actual payment: \"+ paidValue.show());\n\n                        paidValue == expectedPayment\n                    });\n\n                    true\n                    && correctActiveState\n                    && bREQT(\"ensures the sale record is updated with sale-progress details\")\n                    && nextProgress.validateUpdatedDetails(\n                        prevProgress, \n                        nowRange.start, \n                        lotsPurchased\n                    ).trace(\"details updated correctly? \")\n                    && bREQT(\"ensures the sale record is updated with dynamic sale details\")\n                    && pricingStrategy.validateUpdatedDetails()\n                    && bREQT(\"Requires payment according to the dynamic pricing strategy\")\n                    && pricingStrategy.isRightPayment(lotSellPrice, paidValue).trace(\"  -- right payment? \")\n                    // && costForPurchase.contains(paidValue).trace(\"payment correct and tokens distributed? \")\n                    && true\n                }),\n                MergingChildChunk => { //{_, _ /* recId, childChunkId */} => {\n                    error(\"todo: MergingChildChunk\")\n                },\n                Retiring => { //{_ /* recId */} => {                    \n                    error(\"todo: Retiring\")\n                    // Must not have active child chunks:\n                    // ...  previous.retiredThreads must be === previous.nestedThreads\n\n                    // updated \n                    // updated.state must be retired\n                }                \n            },\n            BurningActivities{ba} => {\n                ba.switch {\n                    DeletingRecord => error(\"use more specific burning activity\"),\n                    JoiningWithParentChunk => { //{_, _, _/* recId, parentChunkId */} => {\n                        // burns the indicated chunk UUT\n                        // requires the parent-chunk to be updated with MergingChildChunk\n                        //  ^^^ requires that the DelegatedData activities are structured \n                        //   ... with tight binding to delegate activities from this module\n                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                        error(\"todo: JoinWithParent: Implement the above details\") // ^^^\n                    },\n                    CleanupRetired => {//{_/* recId */} => {\n                        // burns the indicated chunk UUT\n\n                        error(\"todo: CleanupRetired\")\n                        // requires that the chunk is retired\n\n                        // burns the remaining previous.totalTokenCount\n\n                        // !!! todo: more details to account positively for the number of tokens actually sold\n                        //   ... by this chunk\n                        //   ... and in aggregate (this chunk and its children)\n\n                    }\n                }\n            },\n            OtherActivities => error(\n                \"no other activities exist in this delegate\"\n            ),\n            _ => false\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way\" );\n         []String{\n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation( self,\n        _priorMdd: DelegateDatum        \n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n\n// func getlotPrice(mktSale: OutputDatum::Inline, now: Time, lotsPurchased: Int) -> Real {\n//     mkPricingStrategy(\n//         MarketSaleData::from_data(mktSale.data), \n//         now, \n//         lotsPurchased\n//     ).getlotPrice()\n// }\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/MarketSalePolicy.hl", // source filename
    moduleName:  "MarketSalePolicy",
});

const MarketSaleData_hl = makeSource(
  "module MarketSaleData\n\nimport {\n    REQT,\n    bREQT,\n    REQTgroup,\n    assertREQTgroup,\n    bREQTgroup,\n    logGroup,\n    logGroupUnit,\n    logGroupStart,\n    logGroupEnd,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    DgDataDetails,\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\nimport {\n    VxfDestination\n} from VxfProtocol\n\nenum MarketSaleState {\n    Pending\n    Active\n    Retired\n    SoldOut\n}\n\nstruct SaleAssetsV1 {\n    saleLotAssets: Value\n    singleBuyMaxLots: Int\n    primaryAssetMph: MintingPolicyHash\n    primaryAssetName: ByteArray\n    primaryAssetTargetCount: Int\n    totalSaleLots: Int\n}\n\nstruct FixedSaleDetailsV1 {\n    settings: DynamicSaleV1Settings\n    // ^ was saleStrategy: AnySaleStrategy \"strat\"\n    startAt: Time\n\n    // these details about the sale should always be sync'd to nested chunks\n    vxfTokensTo: Option[VxfDestination]\n    vxfFundsTo: Option[VxfDestination]\n}\n\nstruct OtherSaleStateV1 {\n    progressDetails: SaleProgressDetailsV1\n    salePace: Real\n    state: MarketSaleState\n    // ^ was saleStrategyState: AnySaleState \"stratState\"\n\n    func mustBeActive(self, which : String) -> () {\n        REQT(\n            reqt: which + \": state must be Active\",\n            assertion: self.state == MarketSaleState::Active,\n            showSuccess: true\n        )\n    }\n\n    func mustBePending(self, which : String) -> () {\n        REQT(\n            reqt: which + \": state must be Pending\",\n            assertion: self.state == MarketSaleState::Pending,\n            showSuccess: true\n        )\n    }\n}\n\nstruct ThreadInfoV1 {\n    // These details will always start with zero values.\n    // They act as reference-counters, and they increment during split/join transactions\n    nestedThreads: Int\n    retiredThreads: Int\n\n    // Each chunk should point to the chunk it was split from.  Level 1 chunks will have parentChunkId == saleId\n    parentChunkId: ByteArray\n    chunkForkedAt: Time\n\n    // saleId is empty in the root MarketSale.\n    // each split chunk should point to the root MarketSale\n    saleId: ByteArray\n\n    func validateDetailsWhenPending(self, saleId: ByteArray) -> Bool {\n        logGroup(\"ThreadInfoV1: validateDetailsWhenPending()\", false, () -> Bool {\n            assert(self.parentChunkId == #, \"parentChunkId must be empty\");\n            assert(self.saleId == saleId, \"saleId must be equal to saleId\");\n            assert(self.nestedThreads == 0, \"nestedThreads must be zero\");\n            assert(self.retiredThreads == 0, \"retiredThreads must be zero\");\n            true\n        })\n    }\n}\n\nenum MktSaleDetails {\n    4000: V1 {\n        saleState: OtherSaleStateV1\n        fixedSaleDetails: FixedSaleDetailsV1\n        saleAssets: SaleAssetsV1\n        threadInfo: ThreadInfoV1\n    }\n}\n\nstruct MarketSaleData {\n    id: ByteArray  \"@id\"\n    type: String \"tpe\"\n    name: String\n    details: MktSaleDetails \"dtl\"\n\n    // func totalSaleSize(self) -> Value {\n    //     self.moreFields.saleAssets.saleLotAssets * self.moreFields.saleAssets.totalSaleLots\n    // }\n\n    func v1details(self) -> MktSaleDetails::V1 {\n        self.details.switch {\n            v1: V1 => v1\n            // _ => error(\"expected V1 details\")\n        }\n    }\n\n    func primaryAsset(self) -> AssetClass {\n        assets = self.v1details().saleAssets;\n        AssetClass::new(assets.primaryAssetMph, assets.primaryAssetName)\n    }\n\n    func lotSizeForToken(self, assetClass : AssetClass, optional: Bool = false) -> Int {\n        count = self.v1details().saleAssets.saleLotAssets\n            .get_safe(assetClass)\n\n        if (!optional) {\n            assert(count > 0, \"lot size is zero: \"+ assetClass.show())\n        };\n        count\n    }\n\n    func validate(self) -> Bool {\n    logGroup(\"mktSale: validate()\", false, () -> Bool {\n        assert(self.type == \"mktSale\", \"wrong type\");\n        assert(self.name.serialize().length > 10, \"name must be at least 10 characters\");\n        saleAssets = self.v1details().saleAssets;\n        assertREQTgroup(\"validate: primary asset must be divisible by totalSaleLots\", false, () -> Bool {\n            lotsStr = saleAssets.totalSaleLots.show(); /** todo: inline */\n            assetsStr = saleAssets.saleLotAssets.show(); /** todo: inline */\n            print(\"  -- saleAssets \"+ lotsStr + \" x \" + assetsStr);\n\n            primaryLotSize = self.lotSizeForToken(self.primaryAsset());\n            expectedTargetCount = primaryLotSize * saleAssets.totalSaleLots;\n\n            targetCountStr = saleAssets.primaryAssetTargetCount.show(); /** todo: inline */\n            print(\"  -- primaryAssetTargetCount: \" + targetCountStr);\n            expectedTargetCountStr = expectedTargetCount.show(); /** todo: inline */\n            print(\"  -- expectedTargetCount: \" + expectedTargetCountStr);\n\n            assert(\n                expectedTargetCount == saleAssets.primaryAssetTargetCount,\n                \"saleLotAssets' primaryToken mismatch: lot-size * totalSaleLots != primaryAssetTargetCount\"\n            );\n            true\n        });\n\n        // assert(self.currentlotPrice > 0, \"currentlotPrice must be greater than zero\");\n\n        REQT(\n            reqt: \"saleLotAssets must not be empty\",\n            assertion: saleAssets.saleLotAssets.to_map().length > 0,\n            showSuccess: true\n        );\n        REQT(\n            reqt: \"totalSaleLots must be greater than zero\",\n            assertion: saleAssets.totalSaleLots > 0,\n            showSuccess: true\n        );\n        REQT(\n            reqt: \"singleBuyMaxLots must be greater than zero\",\n            assertion: saleAssets.singleBuyMaxLots > 0,\n            showSuccess: true\n        );\n        REQT(\n            reqt: \"singleBuyMaxLots must be less than totalSaleLots\",\n            assertion: saleAssets.singleBuyMaxLots < saleAssets.totalSaleLots,\n            showSuccess: true\n        );\n        REQT(\n            reqt: \"primaryAssetTargetCount must be greater than zero\",\n            assertion: saleAssets.primaryAssetTargetCount > 0,\n            showSuccess: true\n        );\n        true\n        && true\n    })  }\n\n    func validateDetailsWhenPending(self, which : String) -> Bool {\n        logGroup(\"mktSale: validateDetailsWhenPending(): \" + which, false, () -> Bool {\n            details = self.v1details();\n            saleState = details.saleState;\n            REQT(\n                reqt: \"salePace must be initialized to 1.0\",\n                assertion: saleState.salePace == 1.0,\n                showSuccess: true\n            );\n        // assert(self.weightedPace == 0 * Duration::SECOND, \"weightedPace must be zero\");\n            saleDetails = details.fixedSaleDetails;\n            saleAssets = details.saleAssets;\n\n            saleState.mustBePending(which + \": created sale\")\n            true\n            && saleDetails.settings.validateDetailsWhenPending()\n            && saleState.progressDetails.validateDetailsWhenPending(\n                saleDetails.startAt,\n                saleAssets.totalSaleLots\n            )\n            && details.threadInfo.validateDetailsWhenPending(self.id)\n            && true\n        })\n    }\n\n    func validatePrimaryAssetOnlyOnCreation(self) -> Bool {\n        bREQTgroup(\"mktSale: when creating, only allows primary asset in saleLotAssets\", false, () -> Bool {\n            saleAssets = self.v1details().saleAssets;\n            primaryLotSize : Int = saleAssets.primaryAssetTargetCount / saleAssets.totalSaleLots;\n            print(\"  -- primaryLotSize: \" + primaryLotSize.show());\n            expectedPrimaryOnly : Value = Value::new(\n                AssetClass::new(\n                    saleAssets.primaryAssetMph,\n                    saleAssets.primaryAssetName\n                ),\n                primaryLotSize\n            );\n            expectedPrimaryOnlyStr = expectedPrimaryOnly.show(); /** todo: inline */\n            print(\"  -- expected asset bundle: \" + expectedPrimaryOnlyStr);\n            actualAssetsStr = saleAssets.saleLotAssets.show(); /** todo: inline */\n            print(\"  -- actual asset bundle: \" + actualAssetsStr);\n            assert(\n                saleAssets.saleLotAssets == expectedPrimaryOnly,\n                \"saleLotAssets must only reference the primary asset when created\"\n            );\n            true\n        })\n    }\n\n    func validateActivating(self, utxoValue: Value, DDdetails: DgDataDetails) -> Bool {\n        logGroup(\"mktSale: validateActivating()\", false, () -> Bool {\n        previous = MarketSaleData::previous(DDdetails);\n        // expectedDatum : ByteArray = previous.copy(\n        //     state: MarketSaleState::Active\n        // ).serialize();\n        // print(\"expectedDatum: \");\n        // print(expectedDatum.show());\n        // print(\"actualDatum: \");\n        // print(self.serialize().show());\n        // assert(expectedDatum == self.serialize(), \"Activating a sale may only change the state to Active\");\n\n        REQT(\n            reqt: \"name must not change\",\n            assertion: self.name == previous.name,\n            showSuccess: true\n        );\n\n        previous.v1details().saleState.mustBePending(\"previous sale\");\n\n        REQT(\n            reqt: \"state must be changed to Active\",\n            assertion: self.v1details().saleState.state == MarketSaleState::Active,\n            showSuccess: true\n        );\n\n        // ok to change the sale start time\n        // assert(self.startAt == previous.startAt, \"startAt must not change\");\n\n        // assert(self.lastPurchaseAt == previous.lastPurchaseAt, \"lastPurchaseAt must not change\");\n        // assert(self.prevPurchaseAt == previous.prevPurchaseAt, \"prevPurchaseAt must not change\");\n\n        // assert(self.weightedPace == previous.weightedPace, \"weightedPace must not change\");\n        // ok to change the assets & sale lots, as long as everthing else checks out\n        //    assert(self.saleLotAssets == previous.saleLotAssets, \"saleLotAssets must not change\");\n        //    assert(self.totalSaleLots == previous.totalSaleLots, \"totalSaleLots must not change\");\n        //    assert(self.singleBuyMaxLots == previous.singleBuyMaxLots, \"singleBuyMaxLots must not change\");\n        //    assert(self.currentlotPrice == previous.currentlotPrice, \"currentlotPrice must not change\");\n\n        assertREQTgroup(\"validateActivating: must have the required assets deposited to the sale\", false,\n        () -> Bool {\n            assets : Value = utxoValue.get_assets() - DDdetails.uutValue();\n            print(\"expected assets: \" + assets.show());\n\n            assert(\n                self.v1details().saleAssets.saleLotAssets *\n                self.v1details().saleAssets.totalSaleLots == assets,\n                \"utxo must contain the supply of tokens to be sold\"\n            );\n            true\n        });\n\n        assertREQTgroup(\"validates VxfDestination in vxfTokensTo field\", false,\n        () -> Bool {\n            self.v1details().fixedSaleDetails.vxfTokensTo.switch {\n                Some{vxf} => {\n                    assert(vxf.validate(\"vxfTokensTo\"), \"<-- that fails; this can't\");\n                },\n                None => {\n                    print(\"  -- vxfTokensTo is not restricted\");\n                }\n            };\n            true\n        });\n\n        assertREQTgroup(\"validates VxfDestination in vxfFundsTo field\", false,\n        () -> Bool {\n            assert(\n                self.v1details().fixedSaleDetails.vxfFundsTo.unwrap().validate(\"vxfFundsTo\"),\n                \"vxfFundsTo invalid\"\n            );\n            true\n        });\n\n        true\n        && self.v1details().threadInfo.validateDetailsWhenPending(self.id)\n        && true\n    })\n    }\n\n    func previous(ddd : DgDataDetails) -> MarketSaleData {\n        MarketSaleData::from_data(ddd.inputData())\n    }\n\n    func updated(ddd : DgDataDetails) -> MarketSaleData {\n        MarketSaleData::from_data(ddd.outputData())\n    }\n\n   func validateAdding(self, ddd : DgDataDetails, mph : MintingPolicyHash, tn: ByteArray) -> Bool {\n        updated = self\n        previous = MarketSaleData::previous(ddd);\n        thisAssetClass : AssetClass = AssetClass::new(mph, tn);\n        outValue : Value = ddd.output().value;\n\n\n        updatedAssetCount : Int = outValue.get_safe(thisAssetClass);\n        // expectedAssetCount =\n                // print(\"primary tn\" + self.primaryAssetName.decode_utf8());\n                // print(\"this tn: \" + tn.decode_utf8());\n                // print(\"primary mph\" + self.primaryAssetMph.show());\n                // print(\"this mph: \" + mph.show());\n\n        // currentAssets = previous.v1details().saleAssets;\n        currentState = previous.v1details().saleState;\n        nextAssets = updated.v1details().saleAssets;\n        nextState = updated.v1details().saleState;\n        // isPrimary : Bool = ( true\n        //     && ( mph == currentAssets.primaryAssetMph )\n        //         .trace(\"    -- is primary mph? \")\n        //     && ( tn == currentAssets.primaryAssetName )\n        //         .trace(\"    -- is primary tn? \")\n        // ).trace(\"  -- isPrimary? \");\n\n\n        // calculate the incremental amount being added\n        // inValue : Value = ddd.input().value;\n        // assetClass : AssetClass = AssetClass::new(mph, tn);\n        // previousAssetCount : Int = inValue.get_safe(assetClass);\n\n        print(\"  --  added token: \"+ tn.decode_utf8_safe().show());\n        lotSizeForUpdatedAsset : Int = nextAssets.saleLotAssets.get_safe(thisAssetClass);\n        assertREQTgroup(\"deposited asset total must be an even multiple of totalSaleLots\", false, () -> Bool {\n            print(\"  --  lotSizeForUpdatedAsset: \"+ lotSizeForUpdatedAsset.show());\n            assert(updatedAssetCount % nextAssets.totalSaleLots == 0,\n                \"deposited asset total not an even multiple of totalSaleLots\"\n            )\n            true;\n        });\n\n        // check that the deposited assets don't exceed the number of tokens implied by the saleLotAssets * totalSaleLots\n        assertREQTgroup(\"deposited asset total must not exceed what's planned for the sale\", false, () -> Bool {\n            assert(updatedAssetCount <= lotSizeForUpdatedAsset * nextAssets.totalSaleLots,\n                \"deposited asset total exceeds what's planned for the sale\"\n            )\n            true;\n        });\n\n        currentState.mustBePending(\"AddTokens: previous version\")\n        nextState.mustBePending(\"AddTokens: updated sale\")\n\n        true\n        && updated.validate()\n        && updated.v1details().threadInfo.validateDetailsWhenPending(updated.id)\n        && true\n    }\n\n    //! Validates updates to a MarketSale while it's in Pending state.\n    //  This function enforces which fields may be updated and which must remain unchanged.\n    func validateUpdatePendingSale(self, ddd : DgDataDetails) -> Bool {\n        print(\"mktSale: validateUpdatePendingSale()\");\n        previous : MarketSaleData = MarketSaleData::from_data(\n            ddd.inputData()\n        );\n\n        prevDetails = previous.v1details();\n        nextDetails = self.v1details();\n\n        prevState = prevDetails.saleState;\n        nextState = nextDetails.saleState;\n        nextFixed = nextDetails.fixedSaleDetails;\n        prevAssets = prevDetails.saleAssets;\n        nextAssets = nextDetails.saleAssets;\n        prevUtxoValue : Value = ddd.input().value;\n\n        // Core constraints (diagnostic-friendly)\n        assertREQTgroup( reqt: \"fails if the token count in the UTxO is modified during the update\", collapsed:false,\n        callback: () -> Bool {\n            inputAssets = ddd.input().value.get_assets();\n            outputAssets = ddd.output().value.get_assets();\n            assert(inputAssets == outputAssets, \"UTxO tokens changed; delta:  \" + (outputAssets - inputAssets).show());\n            true\n        })\n\n        REQT(\"doesn't allow changing sale pace from 1.0\",\n            assertion: nextState.salePace == 1.0,\n            showSuccess: true,\n            onError: \"sale pace must remain 1.0\"\n        );\n\n        prevState.mustBePending(\"UpdatingPendingSale: previous record\")\n        nextState.mustBePending(\"UpdatingPendingSale: updated record\")\n\n        REQT(\n            reqt: \"doesn't allow changing thread info\",\n            assertion: prevDetails.threadInfo == nextDetails.threadInfo,\n            showSuccess: true,\n            onError: \"thread info must not change\"\n        );\n\n        // Primary asset identity change logic\n        primaryAssetChanged : Bool = (\n            nextAssets.primaryAssetMph != prevAssets.primaryAssetMph\n        ) || (\n            nextAssets.primaryAssetName != prevAssets.primaryAssetName\n        );\n\n        prevPrimaryAssetClass = AssetClass::new(prevAssets.primaryAssetMph, prevAssets.primaryAssetName);\n        nextPrimaryAssetClass = AssetClass::new(nextAssets.primaryAssetMph, nextAssets.primaryAssetName);\n        if (primaryAssetChanged) {\n        assertREQTgroup(\"when primary asset is changed during update ...\", false, () -> Bool {\n\n            previousPrimaryAssetName : String = prevAssets.primaryAssetName.decode_utf8_safe();\n            nextPrimaryAssetName : String = nextAssets.primaryAssetName.decode_utf8_safe();\n            print(\"   -- primary asset changed from \" + previousPrimaryAssetName +\n                \" to \" + nextPrimaryAssetName\n            );\n            // REQT(\"if primary asset changes, check if old primary asset tokens exist in previous UTxO\");\n            prevUtxoAssets : Value = prevUtxoValue - ddd.uutValue();\n            oldPrimaryAssetsDeposited : Int = prevUtxoAssets.get_safe(\n                prevPrimaryAssetClass\n            )\n\n            hasOldPrimaryTokens : Bool = oldPrimaryAssetsDeposited > 0;\n\n            if (hasOldPrimaryTokens) {\n            bREQTgroup(\"when old primary asset tokens are present in the UTxO ...\", false, () -> Bool {\n                print(\"   -- utxo has \" + oldPrimaryAssetsDeposited.show() + \" \" + previousPrimaryAssetName);\n\n                nextSaleLotOldPrimary : Int = nextAssets.saleLotAssets\n                    .get_safe(prevPrimaryAssetClass);\n\n                print(\"   -- next saleLot has \" + nextSaleLotOldPrimary.show() + \" \" + previousPrimaryAssetName);\n\n                assertREQTgroup(\"... saleLotAssets‹primaryAsset› must keep a minimum lot-size, ≥ depositedTokens/totalSaleLots\", false, () -> Bool {\n                    expectedOldPrimaryPerLot : Int = oldPrimaryAssetsDeposited / nextAssets.totalSaleLots;\n                    print(\"   -- expectedOldPrimaryPerLot: \" + expectedOldPrimaryPerLot.show());\n                    assert(\n                        nextSaleLotOldPrimary >= expectedOldPrimaryPerLot,\n                        \"insufficient lot-size for previous primary asset\"\n                    );\n                    true\n                });\n\n                bREQTgroup(\"... saleLotAssets must contain the NEW primary token\", false, () -> Bool {\n                    nextSaleLotNewPrimary : Int = nextAssets.saleLotAssets\n                        .get_safe(nextPrimaryAssetClass);\n                    assert(\n                        nextSaleLotNewPrimary > 0,\n                        \"saleLotAssets doesn't contain the new primary asset\"\n                    );\n                    true\n                })\n            }) } else {\n            bREQTgroup(\"when no old primary asset tokens are present in the UTxO ...\", false, () -> Bool {\n                nextSaleLotOldPrimary : Int = nextAssets.saleLotAssets.get_safe(\n                    prevPrimaryAssetClass\n                )\n\n                assertREQTgroup(\"... saleLotAssets must not reference old primary token\", false, () -> Bool {\n                    print(\"   -- \" + nextSaleLotOldPrimary.show() + \" \" + previousPrimaryAssetName);\n                    assert(\n                        nextSaleLotOldPrimary == 0,\n                        \"saleLotAssets has old primary tokens remaining\"\n                    );\n                    true\n                });\n\n                nextSaleLotNewPrimary : Int = nextAssets.saleLotAssets.get_safe(nextPrimaryAssetClass);\n\n                bREQTgroup(\"...saleLotAssets must reference new primary asset\", false, () -> Bool {\n                    print(\"   -- next saleLot has \" + nextSaleLotNewPrimary.show() + \" \" + nextPrimaryAssetName);\n                    assert(\n                        nextSaleLotNewPrimary > 0,\n                        \"saleLotAssets must reference new primary asset\"\n                    );\n                    true\n                });\n            }) }\n        }) }\n\n        // Primary asset target count consistency\n        assertREQTgroup(\"fails if primaryAssetTargetCount is missing or not an even multiple of the lot count\", false, () -> Bool {\n            nextPrimaryLotSize : Int = nextAssets.saleLotAssets.get_safe(\n                nextPrimaryAssetClass\n            );\n            assert(nextPrimaryLotSize > 0, \"missing primary token in saleLotAssets\");\n            expectedTargetCount : Int = nextAssets.totalSaleLots * nextPrimaryLotSize;\n            assert(\n                nextAssets.primaryAssetTargetCount == expectedTargetCount,\n                \"lot size mismatch with target count for primary asset\"\n            );\n            true\n        });\n\n        // Validate VxfDestination fields\n        REQT(\"validates VxfDestination in vxfTokensTo if Some\");\n        nextFixed.vxfTokensTo.switch {\n            Some{vxf} => {\n                assert(vxf.validate(\"vxfTokensTo\"), \"vxfTokensTo must be valid\");\n            },\n            None => {\n                print(\"  -- vxfTokensTo is None (allowed)\");\n            }\n        }\n\n        REQT(\"validates VxfDestination in vxfFundsTo if Some\");\n        nextFixed.vxfFundsTo.switch {\n            Some{vxf} => {\n                assert(vxf.validate(\"vxfFundsTo\"), \"vxfFundsTo must be valid\");\n            },\n            None => {\n                print(\"  -- vxfFundsTo is None (allowed for pending updates)\");\n            }\n        }\n\n        // Final validations\n        REQT(\"validates updated record passes all general validations\");\n        assert(self.validate(), \"updated record must pass general validation\");\n\n        REQT(\"validates updated record passes pending-specific validations\");\n        assert(\n            self.v1details().threadInfo.validateDetailsWhenPending(self.id),\n            \"updated record must pass pending validations\"\n        );\n\n        REQT(\"validates settings\");\n        assert(\n            nextFixed.settings.validateDetailsWhenPending(),\n            \"updated settings must pass validation\"\n        );\n\n        REQT(\"validates progressDetails still matches startAt and totalSaleLots\");\n        assert(\n            nextState.progressDetails.validateDetailsWhenPending(\n                nextFixed.startAt,\n                nextAssets.totalSaleLots\n            ),\n            \"progressDetails must be consistent with startAt and totalSaleLots\"\n        );\n\n        true\n    }\n}\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/MarketSaleData.hl", // source filename
    moduleName:  "MarketSaleData",
});

const SaleProgressDetails_hl = makeSource(
  "module SaleProgressDetails\n\nimport {\n    REQT,\n    bREQT,\n    REQTgroup,\n    assertREQTgroup,\n    bREQTgroup,\n    logGroup,\n    logGroupUnit,\n    logGroupStart,\n    logGroupEnd,\n    TODO\n} from StellarHeliosHelpers\n\nstruct SaleProgressDetailsV1 {\n    lastPurchaseAt: Time \n    prevPurchaseAt: Time \n\n    lotCount: Int \n    lotsSold: Int \n\n    func validateDetailsWhenPending(self, \n        saleStartTime : Time, \n        totalSaleLots : Int\n     ) -> Bool {\n        logGroup(\"SaleProgressDetails: validateCreatedDetails()\", false, () -> Bool {\n            assert(self.lastPurchaseAt == saleStartTime, \"lastPurchaseAt must be equal to startAt\");\n            assert(self.prevPurchaseAt == saleStartTime, \"prevPurchaseAt must be equal to startAt\");\n            assert(self.lotCount == totalSaleLots, \"lotCount must be equal to totalSaleLots\");\n            assert(self.lotsSold == 0, \"lotsSold must be zero\");\n            // assert(self.lastPurchaseAt >= self.prevPurchaseAt, \"lastPurchaseAt must be greater than or equal to prevPurchaseAt\");\n            true    \n        })\n    }\n\n    func validateUpdatedDetails(\n        self, \n        prevProgress: SaleProgressDetailsV1, \n        now: Time,\n        lotsSold: Int\n    ) -> Bool {\n        logGroup(\"SaleProgressDetails: validateUpdatedDetails()\", false, () -> Bool {\n            bREQTgroup(\"Updates last-purchase-time to the current tx time\", false, () -> Bool {\n                lps = self.lastPurchaseAt.show();\n                nowStr = now.show();\n                print(\"   ----  lastPurchaseAt: \" + lps);\n                print(\"   ----  now: \" + nowStr);\n                assert(\n                    (self.lastPurchaseAt == now),\n                    \"lastPurchaseAt not updated correctly\"\n                )\n                print(\"✔ lastPurchaseAt updated OK\")\n                true\n            })\n\n            && bREQTgroup(\"Keeps a record of the prior purchase time for dynamic pacing\", false, () -> Bool {\n                prevNow : Time = prevProgress.lastPurchaseAt;\n                assert(self.prevPurchaseAt == prevNow,\n                    \"must update prevPurchaseAt to prev lastPurchaseAt \" + prevNow.show() + \n                    \", got \" + self.prevPurchaseAt.show()\n                )\n                print(\"✔ prevPurchaseAt updated OK\")\n                true\n            })\n\n            && bREQTgroup(\"Updates lotsSold to include the new lots being purchased\", false, () -> Bool {\n                prevLotsSoldStr = prevProgress.lotsSold.show(); /** todo: inline */\n                print(\"   ----  prev lotsSold: \" + prevLotsSoldStr);\n                lotsSoldStr = self.lotsSold.show(); /** todo: inline */\n                print(\"   ----  lotsSold: \" + lotsSoldStr);\n                assert(\n                    (\n                        self.lotsSold == prevProgress.lotsSold + lotsSold\n                    ),\n                    \"lotsSold not updated correctly\"\n                )\n                print(\"✔ lotsSold updated OK\")\n                true\n            }) \n\n            && bREQTgroup(\"Ensures the total number of lots available for purchase is unchanged\", false, () -> Bool {\n                assert(\n                    (self.lotCount == prevProgress.lotCount),\n                    \"must not change chunk's lot count\"\n                )\n                print(\"✔ lotCount unchanged OK\")\n                true\n            }) \n            && true\n        })\n    }\n}", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/SaleProgressDetails.hl", // source filename
    moduleName:  "SaleProgressDetails",
});

const DynamicSaleV1_hl = makeSource(
  "module DynamicSaleV1\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {\n    MarketSaleData\n} from MarketSaleData\n\nimport {\n    DynamicSaleV1Settings\n} from DynamicSaleV1Settings\n\nimport {\n    SaleProgressDetailsV1\n} from SaleProgressDetails\n\n// struct DynamicSaleV1State {\n//     dynamicPace: Real \"dynaPace\"\n    \n//     func validateCreatedDetails(self) -> Bool {\n//         assert(self.dynamicPace == 1.0, \"dynamic pace must be initialized to 1.0\");\n//         true\n//     }\n// }\n\nfunc maxReal(a: Real, b: Real) -> Real {\n    // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way\");\n    if (a > b)  { a } else { b }\n}\n\nfunc minReal(a: Real, b: Real) -> Real {\n    // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way\");\n    if (a < b) { a } else { b }\n}\n\n// information about a specific, single purchase\nstruct DTS_PurchaseInfo {\n    inferredPace: Real\n    hoursSinceLastPurchase: Real\n\n    lotsPurchased: Int\n    purchaseTime: Time\n    // previousPurchaseTime: Time\n    \n    // dynamicPace: Real\n    prevSalePace: Real\n\n    totalProgress: SaleProgressDetailsV1\n\n    // func inferredPace(self) -> Real {\n    //      p : Real = \n    //      self.lotsPurchased / self.hoursSinceLastPurchase()\n    //      ;print (\"    ---- inferredPace \" + p.show());\n    //      p\n    // }\n\n    // // probably can optimize\n    // func hoursSinceLastPurchase(self) -> Real {\n    //     h : Real = \n    //      (   \n    //         (\n    //             self.purchaseTime - self.previousPurchaseTime\n    //         ) / Duration::new(1) * 1_000_000.0\n    //         / 3_600_000.0\n    //     ) / 1_000_000.0\n    //     ; print(\"    ---- hoursSinceLastPurchase \" + h.show());\n    //     h\n    // }\n    func create(\n        lotsPurchased: Int, \n        purchaseTime: Time, \n        prevPurchaseTime: Time,\n        prevSalePace: Real,\n        totalProgress: SaleProgressDetailsV1\n    ) -> DTS_PurchaseInfo {\n        // using Ratio adds some library size to the bundle\n        // hoursSinceLastPurchase  = Ratio::new(\n        //     (purchaseTime - prevPurchaseTime) / Duration::MINUTE,\n        //     60\n        // )\n        hoursSinceLastPurchase : Real = (\n            (purchaseTime - prevPurchaseTime) / Duration::new(1)* 1_000_000.0/ \n            3_600_000.0\n        ) / 1_000_000.0;\n        REQT(\"Infers the pace of the current purchase\")\n        print(\"      ---- lotsPurchased \" + lotsPurchased.show());\n        print(\"      ---- hoursSinceLastPurchase \" + hoursSinceLastPurchase.show());\n        // inferredPace = Ratio::new(\n        //     lotsPurchased, 1\n        // ) / hoursSinceLastPurchase;\n        inferredPace : Real = lotsPurchased / hoursSinceLastPurchase;\n        print(\"  -- inferredPace \" + inferredPace.show());\n        DTS_PurchaseInfo{\n            inferredPace: inferredPace,\n            hoursSinceLastPurchase: hoursSinceLastPurchase,\n            lotsPurchased: lotsPurchased,\n            purchaseTime: purchaseTime,\n            // previousPurchaseTime: prevPurchaseTime,\n            prevSalePace: prevSalePace,\n            totalProgress: totalProgress\n        }\n    }\n}\n\nstruct DynamicSaleV1 {\n    settings: DynamicSaleV1Settings\n    purchase: DTS_PurchaseInfo\n\n    sale: MarketSaleData\n    updatedSale: Option[MarketSaleData]\n    \n    // prevSalePace: Real\n    // updatedSettings: Option[DynamicSaleV1Settings]\n    // updatedState: DynamicSaleV1State\n\n    func isRightPayment(self, lotPrice: Value, payment: Value) -> Bool {\n        expectedPrice = self.lotPriceForSale();\n        actualPrice : Real = lotPrice.get_lovelace() / 1_000_000.0;\n        print(\"    ---- actual price \" + actualPrice.show());\n        print(\"    ---- expected price \" + expectedPrice.show());\n        diff : Real = (actualPrice - expectedPrice);\n        if (diff.abs() > 0.000002) {\n            error(\"incorrect lot price in redeemer\")\n        } else if (diff.abs() > 0.0) {\n            print(\"  -- unit price is close enough, delta = \"+diff.show())\n        };\n        // if the actual price is \"close enough\" to expected, then the expected payment is...\n        // the ACTUAL price * lot-count\n        expectedPayment : Real = actualPrice * self.purchase.lotsPurchased;\n        // todo: support non-ADA payments\n        actualPayment : Real = payment.get_lovelace() / 1_000_000.0;\n        \n        print(\"    ---- expected payment \" + expectedPayment.show() + \" +/- 0.000002\");\n        print(\"    ---- actual payment \" + actualPayment.show());\n        assert(payment.get_assets().is_zero(), \"non-ADA assets not yet supported here\");\n\n        paymentDiff : Real = (actualPayment - expectedPayment);\n        assert(paymentDiff == 0.0, \"payment amount is not correct\")\n        true\n    }\n\n    // func updatedSettings(self) -> DynamicSaleV1Settings {\n    //     self.updatedSale.switch {\n    //         None => error(\"must have updatedSale during tx validation\"),\n    //         Some{sale} => {\n    //             AnySaleStrategy::from_data(sale.saleStrategy).switch {\n    //                 DynamicSaleV1{settings /* DynamicSaleV1Settings */ } => settings,\n    //                 _ => error(\"no way\") // should never happen\n    //             }\n    //         }\n    //     }\n    // }\n\n    func lotPriceForSale(self) -> Real {\n        // paceThisPurchase : Real = self.purchase.inferredPace(); // units / hours-since-last-purchase\n        // targetPriceStr = self.settings.targetPrice.show(); /** todo: inline */\n        targetPrice = self.settings.targetPrice;\n        print(\"    ---- target price \" + targetPrice.show());\n\n        targetPrice = self.settings.targetPrice\n        price: Real = targetPrice\n            * self.pricingFactorOverallProgress()\n            * self.pricingFactorDynamicPace();\n            print(\"    ---- lotPriceForSale - unclamped \" + price.show());\n\n        // clamp the price to min/max limits\n        clamped : Real = minReal(\n            maxReal(price, self.settings.minPrice),\n            self.settings.maxPrice\n        );\n        print(\"    -- lotPriceForSale: clamped = \" + clamped.show());\n        clamped\n    }\n\n    func validateUpdatedDetails(self) -> Bool {\n        print(\"DynamicSaleV1: validating updated details\");\n        upd : MarketSaleData = self.updatedSale.switch {\n            None => error(\"must have updatedSale during tx validation\"),\n            Some{s} => s\n        };\n        REQT(\"EXPECTS the basic SaleProgressDetails to be validated separately\")\n\n        REQT(\"fails if it changes the settings\");\n        prevSettings : DynamicSaleV1Settings = self.settings;\n        nextSettings = upd.v1details().fixedSaleDetails.settings;\n        assert(\n            (\n                prevSettings == nextSettings\n            ).trace(\"  -- settings unchanged? \"), \n            \"settings were changed\"\n        );\n\n        expectedPace : Real = self.nextSalePace();\n        nextPace : Real = upd.v1details().saleState.salePace;\n\n        // prevState : SaleProgressDetails = self.purchase.totalProgress;\n\n        REQT(\"Updates the nextPace to reflect the ongoing dynamic sale progress\");\n        print(\"  ---- updated salePace: \" + nextPace.show());\n        assert(\n            (\n                (nextPace - expectedPace).abs() < 0.000005\n            ).trace(\"  -- nextPace ok? \"),\n            \"wrong next salePace in updated sale, expected \" + expectedPace.show()\n        );\n\n        REQT(\"won't sell tokens from a sale chunk less than 10 minutes old\");\n        chunkAge : Duration = upd.v1details().saleState.progressDetails.lastPurchaseAt\n            - self.sale.v1details().saleState.progressDetails.lastPurchaseAt;\n\n        print(\"  ---- chunkAge: \" + chunkAge.show());\n        assert(\n            (chunkAge >= 10 * Duration::MINUTE).trace(\"  -- chunkAge ok? \"),\n            \"sale chunk too fresh (less than 10 minutes)\"\n        );\n\n        true\n    }\n\n    func actualSellingPace(self) -> Real {\n        t : Real = (\n            self.purchase.lotsPurchased\n            + self.sale.v1details().saleState.progressDetails.lotsSold \n        ) / self.elapsedSaleHours();\n        print(\"    ---- actualSellingPace \" + t.show());\n        t\n    }\n\n    func targetSellingPace(self) -> Real {\n        // print(\"selling time \" + self.settings.targetedSellingTime.show());\n        // print(\"  -- in hours\" + (100 *  self.settings.targetedSellingTime / Duration::HOUR / 100.0).show());\n        lotCount : Int = self.purchase.totalProgress.lotCount;\n        // print(\"lotCount\"+ self.purchase.totalProgress.lotCount.show());\n        t : Real = \n         (lotCount + 0.0) / (\n             self.settings.targetedSellingTime * 100 / Duration::HOUR / 100.0\n        ) \n\n        ; print( \"    ---- targetSellingPace \" + t.show());\n        t\n\n        // returns the CHUNK-RELATIVE selling pace\n        // ^^^ distinct from sale-aggregate pace vvv\n        // return self.sale.totalSaleLots / self.settings.targetedSellingTime\n    }\n\n    func elapsedSaleHours(self) -> Real {\n        h : Real = \n        ( self.purchase.purchaseTime - self.sale.v1details().fixedSaleDetails.startAt ) * 1_000_000 / Duration::HOUR / 1_000_000.0\n        ;print(\"    ---- elapsedSaleHours \" + h.show());\n        h\n    }\n\n    // 5000 hours = 208.3333333333333 days\n   // = 5000 * 3600 * 1000 = 18_000_000_000 ms\n   // 5 minutes = 60 * 5 * 1000 = 300_000 ms\n    // at the 5 minute mark, the total pace would be  300 / 18_000_000 = 0.000017\n    // this is okay, though it's near the lower limit of Helios fixed-point precision\n\n    // using elapsedSaleHours in actualSellingPace helps avoid underflow that could otherwise\n    // arise when using elapsed time MS / targetSellingTime, when the target time is very large\n\n    // if the actual selling pace is near 0, then the overall pace will also be near 0\n    //   ... or worst case, actually 0 due to underflow.\n\n    func overallPaceIncludingThisPurchase(self) -> Real {\n        op : Real = \n        self.actualSellingPace() / self.targetSellingPace()\n        ;print(\"    ---- overallPaceIncludingThisPurchase \" + op.show());\n        op\n        \n        // // fraction of time elapsed can be by hours, but it can just as easily use milliseconds; \n        // // ... the HOURs (or ms) cancel each other out in the division.\n        // timeProgress: Real  = self.elapsedTime() / self.settings.targetedSellingTime\n\n        // saleProgress : SaleProgressDetails = self.purchase.totalProgress;\n        // unitsProgress : Real = saleProgress.lotsSold / saleProgress.lotCount;\n\n        // // net overall pacing is the portion of units sold vs the portion of time elapsed\n        // unitsProgress / timeProgress\n    }\n\n    func pricingFactorDynamicPace(self) -> Real {\n        // from Google Sheet:\n        // =max(0.5,(\n        //     LET(prevWeight, 1\n        //    ,LET(prevPace, recent_pace_in\n        //    ,LET(nextPace, recent_pace_out\n        //    ,LET(nextWeight, weightNextDynaPace,\n        //     ( \n        //         IF(prevPace=0,1,\n        //           prevPace / targetSellingPace\n        //         ) * prevWeight\n        //       + IF(nextPace=0,1,\n        //          nextPace / targetSellingPace\n        //         ) * nextWeight \n        //     ) / ( prevWeight +nextWeight )\n        //   ))))\n        //   ))\n\n        // the weight of the previous dyanamic pace\n        prevWeight : Real = 1.0;\n        nextPace : Real = self.nextSalePace();\n        prevPace : Real = self.purchase.prevSalePace;\n        // the weight of the next dynamic pace is variable\n        nextWeight : Real = self.settings.pricingWeightDynaPace;\n        targetSellingPace : Real = self.targetSellingPace();\n        r : Real = \n        ( \n            if (prevPace == 0) { 1.0 } else { \n                prevPace / targetSellingPace\n            } * prevWeight\n            + if (nextPace == 0) { 1.0 } else { \n                nextPace / targetSellingPace\n            } * nextWeight\n        ) / (prevWeight + nextWeight)\n\n        ;print(\"  -- pricingFactorDynamicPace \" + r.show());\n        r\n    }\n\n    func nextSalePace(self) -> Real {\n        // from Google Sheet:\n        // = LET(nextWeight, \n        //     if(purchase_inferred_pace > prev_dyna_pace,\n        //         dynaPaceFasterSaleWeight,\n        //         if (purchase_inferred_pace/targetSellingPace > 1,\n        //           purchase_inferred_pace/targetSellingPace,\n        //           max(1,time_lag * dynaPaceIdleDecayRate)\n        //         )\n        //       ),\n        //      ( purchase_inferred_pace*nextWeight\n        //        + prev_dyna_pace\n        //      ) / (1+nextWeight)\n        //   )\n        purchase : DTS_PurchaseInfo = self.purchase;\n        settings : DynamicSaleV1Settings = self.settings;\n        // sale : MarketSaleData = self.sale;\n        \n        REQT(\"Computes the next sale pace, escalating when the pace increases or decaying when the pace below the target pace\");\n        inferredPace : Real = purchase.inferredPace;\n        print(\"    ---- inferredPace \" + inferredPace.show());\n        nextPaceWeight : Real = if (inferredPace > purchase.prevSalePace) {\n            // this buyer is buying faster than the previous pace,\n            //  ... indicating strong demand and likely opportunity to get a higher price\n            //  ... or at least for that higher price to make space for easing buyer exuberance\n            print(\"    ---- nextPaceWeight: dynaPaceFasterSaleWeight (sale is speeding up)\");\n            settings.dynaPaceFasterSaleWeight\n        } else {\n            if (inferredPace > self.targetSellingPace()) {\n                // the pace is slowing down some, but still selling faster than the target pace\n                //   ... so it's not necessary to soften the price for this buyer or apply an idle-decay\n                // this lets the dynamic pace evolve gently downward to reflect\n                //   ... that the \"recent pace\" isn't quite as fast as it was.\n                // This works in opposition to the escalation effect of the increasing pace.\n                // The current buy will be at higher price than the previous one,\n                //   ... but if the next buy is \"at target pace\", then it will be at a lower price,\n                //   ... reflecting the lower demand pressure.\n                //   ... This creates a small window for a single buyer to game a slightly\n                //   ... lower price, but other people can slip in and buy at that price too. \n                print(\"    ---- nextPaceWeight: 1.0 (sale is proceeding faster than target pace)\");\n                1.0\n            } else {\n                // The pace has slowed significantly - not only lower demand pressure,\n                //   ... but the new buy happened slower than the target pace.  This\n                //   ... clearly indicates that the exuberance-limitations above worked,\n                //   ... slowing down the pace.  This is a good thing, because it means\n                //   ... a more moderate price.\n                // If it's been a short time, we don't give this buyer the benefit\n                //   ... of the idle-decay, as a buyer could just be trying to\n                //   ... game the system by sandbagging the pace, only to take advantage \n                //   ... of that lower pace.\n                // However, if it's actually been a significant amount of time, and other \n                //   ... buyers have had a chance to buy at a consensually supportable price, \n                //   ... then clearly it's important to reduce the price for this buyer.\n                // Without the idle-decay, the pricing would remain high, and likely\n                //   ... the sale would stall out.\n                // This applies the decay rate in the form of a > 1.0, or stronger, weight \n                //   ... of the slower pace, reducing the next-dynamic-pace \n                //   ... as well as the current price.\n                print(\"    ---- nextPaceWeight: slowing sale; using dynaPaceIdleDecayRate \");\n                hslpStr = purchase.hoursSinceLastPurchase.show(); /** todo: inline */\n                print(\"      ---- hoursSinceLastPurchase \" + hslpStr);\n                dpidrStr = settings.dynaPaceIdleDecayRate.show(); /** todo: inline */\n                print(\"      ---- * dynaPaceIdleDecayRate \" + dpidrStr);\n                result = maxReal(\n                    1.0, purchase.hoursSinceLastPurchase * settings.dynaPaceIdleDecayRate\n                )\n                resultStr = result.show(); /** todo: inline */\n                print(\"  -- nextPaceWeight = \" + resultStr);\n                result\n            }\n        };\n        nextPaceWeightStr = nextPaceWeight.show(); /** todo: inline */\n        print(\"    ---- nextPaceWeight \" + nextPaceWeightStr);\n        psp : Real = purchase.prevSalePace;\n        print(\"    ---- prev salePace \" + psp.show());\n\n        nextDynamicPace : Real = (inferredPace * nextPaceWeight + psp) \n            / (nextPaceWeight + 1)\n        print(\"    ---- next salePace: \" + nextDynamicPace.show());\n        nextDynamicPace\n    }\n\n\n    func pricingFactorOverallProgress(self) -> Real {\n        // from Google Sheet:\n        // = LET(ceilingHeight, 1-paceDiscountFloorPoint\n        //     ,LET(aboveFloor,current_pace-paceDiscountFloorPoint\n        //     ,LET(relativeHeight, if(aboveFloor<=0,0, aboveFloor/ceilingHeight)\n        //     ,LET(discountDepth,1-relativeHeight\n        //     , LET(discountEarned, \n        //       discountDepth*paceDiscountWhenSlow\n        //     , LET(clampedMaxDiscount,\n        //       MAX(0,MIN(discountEarned, paceDiscountWhenSlow))\n        //     , LET(priceExpansion,\n        //       if(current_pace<1,1, \n        //          1+(\n        //            (current_pace-1)*(1+paceExpansionWhenFast)/3\n        //          )\n        //       )\n        //     , LET(RESULT, \n        //       (1-clampedMaxDiscount) * priceExpansion,  \n        //       RESULT\n        //     ))))))))\n\n        settings : DynamicSaleV1Settings = self.settings;\n        overallPacingProgress : Real = self.overallPaceIncludingThisPurchase();\n        discountEarned : Real = self.progressPricingDiscountDepth(overallPacingProgress) * \n           settings.progressPricingDiscountWhenSlow;\n        print(\"      ---- unclamped discountEarned \" + discountEarned.show());\n        clampedMaxDiscount : Real = maxReal(\n            0.0, minReal(\n                discountEarned, settings.progressPricingDiscountWhenSlow\n            )\n        );\n        print(\"      ---- clampedDiscount \" + clampedMaxDiscount.show());\n\n        r : Real = \n        (1 - clampedMaxDiscount) * self.priceExpansion(overallPacingProgress)\n        ;print(\"  -- pricingFactorOverallProgress \" + r.show());\n        r\n    }\n\n    func priceExpansion(self, overallPace: Real) -> Real {\n        expansion : Real = if (overallPace < 1.0) {\n            1.0\n        } else {\n            1.0 + (\n                (overallPace - 1.0) \n                * (1.0 + self.settings.progressPricingExpansionWhenFast) \n                / 3.0\n            )\n        }\n        ;print(\"    ---- priceExpansion \" + expansion.show());\n        expansion\n    }\n\n    func progressPricingDiscountDepth(self, overallPace: Real) -> Real {\n        settings : DynamicSaleV1Settings = self.settings;        \n\n        print(\"      ---- pPDD overallPace \" + overallPace.show());\n        ceilingHeight : Real = 1.0 - settings.progressPricingDiscountFloorPoint;       \n        // = 0.5 to 0.95\n\n        \n        aboveFloor : Real = if (overallPace > settings.progressPricingDiscountFloorPoint) {\n            overallPace - settings.progressPricingDiscountFloorPoint\n        } else {  0.0 };\n        relativeHeight : Real = if ( aboveFloor <= 0 ) { 0.0 } else { aboveFloor / ceilingHeight };\n        \n        print(\"      ---- pPDD ceilingHeight \" + ceilingHeight.show());\n        print(\"      ---- pPDD aboveFloor \" + aboveFloor.show());\n        print(\"      ---- pPDD relativeHeight \" + relativeHeight.show());\n\n        ppdd : Real = 1 - relativeHeight\n        print(\"    ---- progressPricingDiscountDepth \" + ppdd.show());\n        ppdd\n    }\n}\n\n// use this pattern inline, instead of as a function, to enable\n// optimizations in the surrounding code for accessing the various\n// details mentioned\n//\n// func mkSaleController(\n//     prevMktSale: MarketSaleData, \n//     now: Time, \n//     lotsPurchased: Int,\n//     updatedSale: Option[MarketSaleData] = Option[MarketSaleData]::None\n// ) -> DynamicSaleV1 {\n//     prevProgress : SaleProgressDetails = prevMktSale.progressDetails;\n//     totalProgress: SaleProgressDetails = SaleProgressDetails{\n//         lastPurchaseAt: now,\n//         prevPurchaseAt: prevProgress.lastPurchaseAt,\n//         lotCount: prevProgress.lotCount,\n//         lotsSold: prevProgress.lotsSold + lotsPurchased\n//     };\n//     prevPace : Real = prevMktSale.salePace;\n//     DynamicSaleV1{\n//         settings: prevMktSale.saleSettings,\n//         purchase: DTS_PurchaseInfo{\n//             lotsPurchased: lotsPurchased,\n//             purchaseTime: now,\n//             previousPurchaseTime: prevProgress.lastPurchaseAt,\n//             prevSalePace: prevPace,\n//             totalProgress: totalProgress\n//         },\n//         sale: prevMktSale,\n//         updatedSale: updatedSale,\n//         prevSalePace: prevPace,\n//         updatedSettings: Option[DynamicSaleV1Settings]::None\n//     }\n// }\n\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/DynamicSaleV1.hl", // source filename
    moduleName:  "DynamicSaleV1",
});

const DynamicSaleV1Settings_hl = makeSource(
  "module DynamicSaleV1Settings\n\nimport {\n    REQT,\n    bREQT,\n    REQTgroup,\n    assertREQTgroup,\n    bREQTgroup,\n    logGroup,\n    logGroupUnit,\n    logGroupStart,\n    logGroupEnd,\n    TODO\n} from StellarHeliosHelpers\n\nstruct DynamicSaleV1Settings {\n    targetPrice: Real  \n    //TODO: add pricing unit\n    // pricingUnit: AssetClass\n    \n    targetedSellingTime: Duration  \n\n    minPrice: Real  // same as minSalePrice\n    maxPrice: Real  // same as maxSalePrice\n\n    // 0.20 by default\n    progressPricingDiscountFloorPoint: Real // same as paceDiscountFloorPoint\n    // 0.25 by default\n    progressPricingDiscountWhenSlow: Real  // same as paceDiscountWhenSlow\n    // 0.20 by default\n    progressPricingExpansionWhenFast: Real // same as paceExpansionWhenFast\n\n    // 0.3 by default\n    dynaPaceFasterSaleWeight: Real \n    // 0.5 by default\n    dynaPaceIdleDecayRate: Real \n\n    // 5 by default\n    pricingWeightDynaPace: Real  // same as weightNextDynaPace\n\n    func validateDetailsWhenPending(self) -> Bool {\n    logGroup(\"DynamicSaleV1Settings: validateCreatedDetails()\" , false, () -> Bool {\n        assert(self.progressPricingDiscountFloorPoint > 0.05, \"floor point too low\");\n        assert(self.progressPricingDiscountFloorPoint < 0.50, \"floor point too high\");\n        assert(self.progressPricingDiscountWhenSlow >= 0.0, \"negative discount\");\n        assert(self.progressPricingDiscountWhenSlow < 1.0, \"discount too high\");\n        assert(self.progressPricingExpansionWhenFast > 0.05, \"expansion too low\");\n        assert(self.progressPricingExpansionWhenFast < 10.0, \"expansion too high\");\n        assert(self.dynaPaceFasterSaleWeight >= 0.0, \"faster weight negative\");\n        assert(self.dynaPaceFasterSaleWeight < 2.0, \"faster weight way too high\");\n        assert(self.dynaPaceIdleDecayRate >= 0.0, \"negative decay rate\");\n        assert(self.dynaPaceIdleDecayRate < 2.0, \"decay rate too high\");\n        assert(self.pricingWeightDynaPace >= 0.0, \"dyna pace weight negative\");\n        assert(self.pricingWeightDynaPace < 15, \"dyna pace weight way too high\");\n\n        true\n    })}\n\n    // func validateUpdatedDetails(self) -> Bool {\n\n    //     true\n    // }\n}\n", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/MarketSale/DynamicSaleV1Settings.hl", // source filename
    moduleName:  "DynamicSaleV1Settings",
});

class MarketSaleBundle extends DelegatedDataBundle.usingCapoBundleClass(
  CapoHeliosBundle,
  "generic"
) {
  precompiledScriptDetails = {
    singleton: {
      scriptHash: "8bee69d82aaa0f20ac19dd247d383fd8fb622627d070cbff2d5eadc1",
      config: { "rev": "1", "delegateName": "MarketSalePolicy", "isMintDelegate": false, "isSpendDelegate": false, "isDgDataPolicy": true, "requiresGovAuthority": true }
    }
  };
  scriptParamsSource = "bundle";
  async loadPrecompiledVariant(variant) {
    const module = await import('stellar-tokenomics/contracts-preprod/MarketSale.compiled.hlb');
    const foundVariant = module.precompiled[variant];
    if (!foundVariant) {
      throw new Error(`unknown variant: ${variant}`);
    }
    return foundVariant;
  }
  specializedDelegateModule = MarketSalePolicy_hl;
  requiresGovAuthority = true;
  get modules() {
    return [
      ...super.modules,
      MarketSaleData_hl,
      SaleProgressDetails_hl,
      DynamicSaleV1_hl,
      DynamicSaleV1Settings_hl,
      VxfProtocol_hl
    ];
  }
}

export { MarketSaleBundle, MarketSaleBundle as default };
//# sourceMappingURL=MarketSale.hlb.mjs.map
