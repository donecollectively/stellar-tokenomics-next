import { makeSource } from '@helios-lang/compiler-utils';

const VxfProtocol_hl = makeSource(
  "module VxfProtocol\n\nimport {\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    REQT,\n    bREQT,\n    TODO\n} from StellarHeliosHelpers\n\n/**\n * The VxfExpectedActivity enum is used to capture details of how the vesting contract can\n * enforce the required smart contract to which funds may be distributed after they vest.\n * It is used in the Vxf Sealing process to establish a positive linkage to a receiving contract, \n * or to a collaborating (Vxf Transfer agent) contract that has a stake or policy to be enforced \n * during the funds distribution.\n *\n * the appData field can include additional details which are transparent to the vesting contract,\n * interpreted only by the receiving contract to enforce any details of its required behavior.\n * When distributing funds out of the vesting contract, the receiving contract must match with the\n * provided appData (if provided).\n */\nenum VxfExpectedActivity {\n    /** \n    * implicitly seeks a tagged redeemer with first-field constructor 'VX' = 0x5658 = decimal 22104\n    *\n    * This is the same as using TaggedRedeemer with id=22104.\n    *\n    * The appData field can include further details to be enforced by the receiving \n    * contract, and if provided, the target redeemer's 22104 must have the matching appData \n    * in its first field. ??? TODO: value needed too?\n    */\n    22104: VxfTransfer {\n        appData: Option[Data]\n    }\n\n    /**\n    * implicitly seeks a tagged redeemer with first-field constructor 'VZ' = 0x565A = decimal 22106.\n    * \n    * This is the same as using TaggedRedeemer with id=22106.\n    *\n    * When provided, the appData field must be matched by the receiving contract's \n    * matched redeemer, the VZ constructor's first field. \n    * TODO: value needed too?\n    */\n    22106: VxfStorage {\n        appData: Option[Data]\n    }\n    /**\n    * Seeks a redeemer with a specific constructor tag.  When inNestedList is true,\n    * the indicated constructor tag is also sought in any item of a nested list found \n    * in the first field of any top-level constructor tag.  With a nestedListRedeemerId,\n    * that top-level constructor-tag is required to match, before the nested-list item is sought.\n    *\n    * When provided, the appData field must be matched by the receiving contract's \n    * matched redeemer, in the constructor tag's second field.\n    * TODO: value needed too?\n    */\n    22107: SpecificRedeemerId {\n        id: Int\n        inNestedList: Bool\n        nestedListRedeemerId: Option[Int]\n        appData: Option[Data]\n    }\n    /**\n     * Seeks a redeemer at any index, with its first field as a tagged constructor with \n     * the specified integer tag.  This first-field constructor-index convention allows \n     * any top-level redeemer index, with the indicated first field as a highly selective \n     * discriminator of minimal size.  \n     *\n     * When inNestedList is true, the indicated constructor tag is also sought in any item of a \n     * nested list found in the first field of any top-level constructor tag.\n     *\n     * When provided, the appData field must be matched by the receiving contract's \n     * matched redeemer, in the matched field constructor's first field.\n     * TODO: value needed too?\n     */\n    22108: TaggedRedeemer {\n        firstFieldConstrTag: Int\n        inNestedList: Bool\n        // scriptPurpose: ScriptPurpose\n        appData: Option[Data]\n    }\n}\n\nenum VxfDestination {\n    /**\n    * When the beneficiary is a relative link with a validator hash, the link is used to identify\n    * a delegate script whose UUT controls spending of its utxos, including\n    * the vested + distributed funds.  That script's activity is anchored with the ***required `vxfActvity`***,\n    * identifying the script activity (redeemer variant) needed to take control of the funds \n    * on distribution\n    *\n    * When the beneficiary is a member UUT name, the delegate link\n    * will have no delegateValidatorHash, and the vxfActivity field is not required.\n    * The UUT is a token name in the minting policy of the same Capo in which the vesting\n    * record is created.  In this case, the vxfActivity field is not required.  ***The holder\n    * of the indicated token will be able to withdraw vested funds.***\n    */\n    RelativeLink { \n        link: RelativeDelegateLink \n        vxfActivity: Option[VxfExpectedActivity]\n    }\n\n    /**\n     * The beneficiary is any token holder of the given minting policy\n     * and asset name.  Normally this asset name will be a unique token.\n     */\n    AnyTokenHolder {\n        mph: MintingPolicyHash\n        assetName: ByteArray\n    }\n\n    /**\n     * The beneficiary is identified by a public key.  This is useful for indicating a\n     * wallet address, without the scripting overhead needed for encoding an Address here.\n     */\n    PubKey {\n        pkh: PubKeyHash\n    }\n    /**\n     * when the beneficiary is not constrained\n     */\n    98: Anywhere\n    /**\n     * when the beneficiary is not yet defined.  Will need to be defined before activation.\n     */\n    99: NotYetDefined\n    /**\n     * The beneficiary is any address.  This is useful for vesting to a\n     * multi-sig address, or other situations where a more specific way of identifying\n     * the beneficiary is not available.\n     *\n     * The credential for the address is required.  When the address is a plutus script,\n     * the vxfActivity is strongly recommended, to create a strong linkage between the\n     * vesting instance and specific activities under the receiving contract's control; otherwise,\n     * a utxo could be created that not ever be spendable by the receiver, or which could misdirect\n     * the receiver's further disposition of the funds.\n     *\n     * When the address is a multi-sig (/NativeScript) address, the Credential (a hash of the script)\n     * is required, and the vxfActivity is not needed.\n     */\n    //  TODO when there's a good use-case for this generic angle on distributing based on address\n    // AnyAddress {\n    //     unsupported: Int\n    //     // NOTE: Address is a pretty large type, consuming from a limited space in the compiled script\n    //     // address: Address\n    //     // credential: Credential\n    //     // vxfExpectedActivity: Option[VxfExpectedActivity]\n    // }\n\n    func validate(self, fieldName: String) -> Bool {\n        self.switch {\n            RelativeLink => error(fieldName + \": todo: RelativeLink support\"),\n            AnyTokenHolder => error(fieldName+ \": todo: AnyTokenHolder support\"),\n            PubKey => true,\n            Anywhere => true,\n            NotYetDefined => error(\"VxfDestination: \" + fieldName + \": NotYetDefined\")\n            // should NOT need to check the default case\n            // if the above cases are exhaustive\n            // _ => false\n        }\n    }\n\n    func verifyDestination(self, tx: Tx) -> Bool {\n        self.switch {\n            RelativeLink => error(\"todo: RelativeLink support\"),\n            AnyTokenHolder => error(\"todo: AnyTokenHolder support\"),\n            PubKey{pkh} => tx.is_signed_by(pkh),\n            Anywhere => true,\n            NotYetDefined => {\n                error(\"unreachable\")\n            }\n            // should NOT need to check the default case\n            // if the above cases are exhaustive\n            // _ => false\n        }\n    }\n}", {
    project: "stellar-tokenomics",
    purpose: "module",
    name:  "src/Vesting/VxfProtocol.hl", // source filename
    moduleName:  "VxfProtocol",
});

export { VxfProtocol_hl as V };
//# sourceMappingURL=VxfProtocol.mjs.map
