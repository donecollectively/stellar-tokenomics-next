module MarketSalePolicy


// this is a Helios smart contract module for managing a market sale of assets.
// Reference Value.md for the Value type and its operations.



// specialized to ...
//   -  support MarketSale custom-data
// original notes about (un)specialization follow:

//  //! provides a basic version, ~~not yet specialized~~
//  // of the "specializedDelegate" interface, which simply
//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  

//  //! Your specialization MUST include the enum variants found in this
//  //  ... unspecialized version.  It MAY include additional Datum variants.
//  // Any additional Redeemer/Activity variants should be added underneath 
//  // the SpendingActivity / MintingActivity top-level enum variants, instead 
//  // of adding new top-level enum variants to DelegateActivity.

//  // The DelegateActivity (redeemer) enum conforms to the 
//  // Delegate Redeemer protocol, in which enum 0 is reserved for
//  // lifecycle activities, enum 1 is used for spend-related activities 
//  // (if the delegate is used as a spend delegate), and enum 2 is called
//  // for authorizing minting.  Enum 3 and beyond are reserved for
//  // extensions to the Delegate Redeemer protocol.

//  // Within the minting and spending activities, the specialization can 
//  // indicate a nested activity enum to support various dApp-specific
//  // activities.  

//  // Activities that validate minting of UUTs should contain enum fields 
//  // to identify the seed-transaction details needed for properly validating 
//  // UUT mints fitting the use-case.

//  //! Your specialization MAY include any additional functions, imports or 
//  //  methods defined on any of the types in this file.

import {tx, get_current_input} from ScriptContext

import {
    TODO,
    REQT,
    bREQT,
    assertREQTgroup,
    bREQTgroup,
    REQTgroup,
    REQTgroupUnit,
    logGroupUnit,
    logGroupStart,
    logGroupEnd,
    AnyData,
    logGroup,
    getTimeRange,
    endsBefore
} from StellarHeliosHelpers

import {
    DelegationDetail,
    mustReturnValueToScript,
    DelegateLifecycleActivity,
    CapoLifecycleActivity,
    unmodifiedDelegation
} from CapoDelegateHelpers

import {
    validateUutMinting,
    mkUutTnFactory
} from CapoMintHelpers

// import {
//     ProtocolSettings
// } from ProtocolSettings

import {
    DgDataDetails,
    CapoCtx,
    mkCapoCtx
} from CapoHelpers

import {
    MarketSaleData,
    MarketSaleState,
    SaleAssetsV1,
    OtherSaleStateV1,
    FixedSaleDetailsV1,
    ThreadInfoV1,
    MktSaleDetails
} from MarketSaleData

import {
    SaleProgressDetailsV1
} from SaleProgressDetails

import {
    DynamicSaleV1Settings
} from DynamicSaleV1Settings

import {
    DynamicSaleV1,
    DTS_PurchaseInfo
} from DynamicSaleV1

enum DelegateDatum {
    Cip68RefToken {  
        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard 
        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName
        //     - this asset name can serve user-side tokens using the CIP-68 "222", "333" or other token types.
        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and 
        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)
        //       ... to locate this reference datum; this datum content will be interpreted
        //       ... according to the semantics implied by the user-side asset-name prefix.
        //
        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type
        //    - for "222" tokens, the meta field should contain the following fields:
        //        - "name" : String
        //        - "description" : String 
        //        - "files" :   // {mediaType, src (url), name?, ... otherFields)
        //        - "image": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)
        //    - for "333" tokens, the meta field should contain the following fields:
        //        - "name" : String
        //        - "description" : String 
        //        - "ticker" : String

        //        - "url": String  // project URL
        //        - "logo": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)
        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`
        //        - "decimals" : Int

        cip68meta: AnyData
        cip68version: Int
        otherDetails: Data // can be Unit () or anything else
    }

    IsDelegation {
        dd: DelegationDetail
    }
    // same variant-index as Capo's DelegatedData
    capoStoredData {
        data: MarketSaleData
        version: Int
        otherDetails: Data 
    }

    func validateSettings(self, settings: AnyData) -> Bool {
        assert(false, "not valid (stubbed)");
        assert(settings.serialize() != self.serialize(), "no");

        true
    }
}

enum MintingActivity {
    CreatingRecord {
        seed: TxOutputId
    }
    SplittingSaleChunkAndBuying {
        seed: TxOutputId
        parentChunkId: String
        lotsPurchased: Int
    }
}

enum SpendingActivity {
    UpdatingRecord {
        id: ByteArray
    }

    AddingToSale {
        id: ByteArray
        mph: MintingPolicyHash
        tn: ByteArray
    }
    UpdatingPendingSale {
        id: ByteArray
    }
    Activating {
        id: ByteArray
    }
    SellingTokens {
        id: ByteArray
        lotsPurchased: Int
        salePrice: Value
    }
    MergingChildChunk {
        id: ByteArray
        childChunkId: String
    }
    Stopping {
        id: ByteArray
    }
    Resuming {
        id: ByteArray
    }
    UpdatingPausedSale {
        id: ByteArray
    }
    51 : WithdrawingProceeds {
        id: ByteArray
    }
    65 : Retiring {
        id: ByteArray
    }
    86 : SoldOut {
        id: ByteArray
    }
}

enum BurningActivity {
    DeletingRecord {
        id: ByteArray
    }

    JoiningWithParentChunk {
        // burns the indicated chunk UUT
        // requires the parent-chunk to be updated with MergingChildChunk
        id: String
        parentChunkId: String
    }
    CleanupRetired {
        id: String
    }
}

enum DelegateActivity {
    // must ALWAYS be at Enum position 0
    CapoLifecycleActivities {
        activity: CapoLifecycleActivity
    }

    // must ALWAYS be at Enum position 1
    DelegateLifecycleActivities {
        // administrative activities for the delegate lifecycle, enforced
        //  by the basic mint delegate code.  Specializations can add more 
        //  restrictions, but in many/most cases they will not need to.
        activity: DelegateLifecycleActivity
    }

    // application-specific spending activities, ALWAYS at Enum position 2
    SpendingActivities {
        activity: SpendingActivity
    }

    // application-specific minting activities, ALWAYS at Enum position 3
    MintingActivities {
        activity: MintingActivity
    }

    BurningActivities {
        activity: BurningActivity
    }
    
    CreatingDelegatedData {
        seed: TxOutputId
        dataType: String
        // record id created from seed
    }

    UpdatingDelegatedData {
        // no seed
        dataType: String
        recId: ByteArray
    }

    DeletingDelegatedData {
        // no seed
        dataType: String
        recId: ByteArray
    }

    MultipleDelegateActivities {
        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved
        activities: []Data // actually a DelegateActivity
    }

    OtherActivities {
        activity: Data // specialized activities can be added here
    }

    // this function gives a general-purpose implementation of checking for 
    // valid uut minting. 
    //
    // A specialization might modify it to use different policies
    // or enforce additional requirements
    // 
    // func genericUutMinting(self, 
    //     mdd: DelegateDatum
    // ) -> Bool {
    //     //!!! replace with an activity using the same seed-txn pattern:
    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;
    //     DelegateDatum::IsDelegation{dd} = mdd;
    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());

    //     o : []TxOutput = get_cont_outputs();
    //     if (o.length != 1) { error("single utxo only") };

    //     print ("in unsp_MD");
    //     isOk : Bool = returnsAuthzToken && 

    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&

    //     // This call can serve as a template for enforcing expected mints 
    //     // of uuts (and additional token values) in validation of application-
    //     // specific activities, given (mph, sTxId, sIdx, purposes)
    //     validateUutMinting(
    //         mph: dd.mph,
    //         seedTxId: sTxId, 
    //         seedIdx: sIdx, 
    //         purposes: purposes,
    //         // otherMintedValue: ()
    //         mkTokenName: mkUutTnFactory(sTxId, sIdx)
    //     );

    //     isOk
    // }

    //! used only for validating IsDelegation datum, that is,
    //   ... to approve minting requests or any customize spending modes 
    //   ... of that datum.  
    
    //  Note that the basic delegate already enforces some basic
    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities
    //    so a specialization doesn't need to re-implement those checks.
    func additionalDelegateValidation( self,
        priorMddd: DelegateDatum::IsDelegation,
        cctx: CapoCtx
    ) -> Bool {
        print("  -- mktSalePolicy: checking additional delegate validation");
        self.switch {
            // generic DelegateLifecycleActivities is already validated, but 
            //  ... you can add more constraints here if needed
            DelegateLifecycleActivities => true,
            CapoLifecycleActivities => {
                // CapoLifecycleActivites are always rejected except for MINTING delegates.
                error("unreachable")
            },
            MintingActivities{ma} => {
                ma.switch {
                    SplittingSaleChunkAndBuying => { //{_,_,_/*seed, parentChunkId, buyingQuanityt*/} => {
                        // mint of new UUT already checked
                        
                        //!!! it should spend the parent-chunk UUT 
                        // ... with activity-indicator SpendingActivity::SplittingToChildChunk
                        //  ^^^ requires that the DelegatedData activities are structured 
                        //   ... with tight binding to delegate activities from this module
                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        error("SplittingSaleChunk: Implement the above details") // ^^^

                        // it should return the parent-chunk UUT to the Capo
                        // the new chunk should have saleId pointing to the parent chunk
                        // the new chunk should validate
                        // the new chunk's token value should be withdrawn from the parent chunk
                        // the new chunk's totalTokenCount should equal the withdrawn token value                        
                    },
                    CreatingRecord {seed} => {
                        // mint of new UUT already checked
                        assert(cctx.withCharterRef().orFail(), "can't");

                        mktSaleId : String = mkUutTnFactory(seed)("mktSale");
                        mktSaleDD : DgDataDetails = cctx.creatingDgData(mktSaleId);

                        // gets the new MarketSaleData record
                        created : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                        true
                        && created.validateDetailsWhenPending("creating record")
                        && created.validatePrimaryAssetOnlyOnCreation()
                        && cctx.requiresGovAuthority().orFail()
                    }
                }
            },
            SpendingActivities{x} => x.switch {
                UpdatingRecord => error("use more specific spending activity"),
                UpdatingPendingSale{saleId} => logGroup("UpdatingPendingSale:", false, () -> Bool {
                    TODO("UpdatingPendingSale mktSale: test this code path");
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    
                    nextRec : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    true
                    && nextRec.validateUpdatePendingSale(mktSaleDD)
                    && cctx.requiresGovAuthority().orFail()
                }),

                AddingToSale {saleId, mph, tn} => logGroup("AddingToSale:", false, () -> Bool {
                    TODO("AddingToSale: test this code path");
    
                    assert(cctx.withCharterRef().orFail(), "can't");
                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    next : MarketSaleData = MarketSaleData::updated(mktSaleDD);
                    true
                    && next.validateDetailsWhenPending("adding to sale")
                    && next.validateAdding(mktSaleDD, mph, tn)
                    && cctx.requiresGovAuthority().orFail()
                }),
                Activating {saleId} => logGroup("Activating sale:", false, () -> Bool {
                    TODO("test this code path");
                    assert(cctx.withCharterRef().orFail(), "can't");

                    // mktSale = cctx.updatingDgData(mktSaleId)
                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);

                    // gets the previous MarketSaleData record
                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);
                    // gets the new MarketSaleData record
                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    prevState = previous.v1details().saleState
                    nextState = updated.v1details().saleState

                    prevState.mustBePending("previous sale")
                    nextState.mustBeActive("updated sale: activating")

                    nowRange = getTimeRange(5*Duration::MINUTE);
                    newValue : Value = mktSaleDD.output().value;
                    true
                    && cctx.requiresGovAuthority().orFail()
                    // // validates updated record
                    && updated.validate()
                    && updated.validateActivating(newValue, mktSaleDD)
                    && bREQT(
                        reqt: "chunkForkedAt freshened to activation time (REQT-apddgwqy9q)",
                        assertion: updated.v1details().threadInfo.chunkForkedAt == nowRange.start,
                        showSuccess: true,
                        onError: "chunkForkedAt must be set to current time at activation"
                    )
                    && bREQTgroup(
                        reqt: "progress timestamps freshened to activation time (REQT-stf3bz3fkk)",
                        collapsed: false,
                        callback: () -> Bool {
                            progressDetails = updated.v1details().saleState.progressDetails;
                            assert(
                                progressDetails.lastPurchaseAt == nowRange.start,
                                "lastPurchaseAt must be freshened to activation time"
                            );
                            assert(
                                progressDetails.prevPurchaseAt == nowRange.start,
                                "prevPurchaseAt must be freshened to activation time"
                            );
                            true
                        }
                    )
                    && true
                }),
                SellingTokens { recId, lotsPurchased, lotSellPrice : Value } => logGroup("SellingTokens:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: recId);
                    // print("SellingTokens: x" + lotsPurchased.show() );
                    // print("               ^^"+  recId.show());

                    // gets the previous MarketSaleData record
                    previous = MarketSaleData::previous(mktSaleDD);

                    // gets the new MarketSaleData record
                    updated = MarketSaleData::updated(mktSaleDD);

                    // IMPORTANT POLICY: When chunk-splitting is implemented, child chunks
                    // MUST NOT sell while the root sale is Paused.  The root sale's UTxO
                    // should be required as a reference input, and its state checked here.
                    // This ensures that Stopping the root effectively halts the entire sale
                    // across all chunks, without requiring each chunk to be stopped individually.

                    assert(
                        previous.v1details().fixedSaleDetails.requireVxfFieldsNone(),
                        "VXF fields must be None"
                    );

                    correctActiveState = true
                    previous.v1details().saleState.mustBeActive("previous sale")
                    updated.v1details().saleState.mustBeActive("updated sale: selling tokens")

                    REQT("doesn't sell before the start date")
                    nowRange = getTimeRange(5*Duration::MINUTE);
                    nowRangeStartStr = nowRange.start.show(); /** todo: inline */
                    print("   --- now start: " + nowRangeStartStr);
                    startAtStr = previous.v1details().fixedSaleDetails.startAt.show(); /** todo: inline */
                    print("   --- startAt:   " + startAtStr);
                    nowRangeEndStr = nowRange.end.show(); /** todo: inline */
                    print("   --- now end: " + nowRangeEndStr);

                    assert(
                        nowRange.is_after(
                            previous.v1details().fixedSaleDetails.startAt
                        ), 
                        "sale not yet started"
                    );

                    assert(lotsPurchased > 0, "must sell at least one lot");
                    assert(lotsPurchased <= previous.v1details().saleAssets.singleBuyMaxLots, 
                        "attempted to buy too many lots"
                    );
                    prevProgress = previous.v1details().saleState.progressDetails;
                    nextProgress = updated.v1details().saleState.progressDetails;

                    // funds accumulate to sale UTxO under None-mode (REQT-wh3kjtwmj9)
                    TODO("when VXF routing is implemented, route per vxfFundsTo instead");
                    oldValue : Value = mktSaleDD.input().value;
                    newValue : Value = mktSaleDD.output().value;

                    // tokens go to buyer with no routing constraint (REQT-nnxpz49srs)
                    purchasedTokens : Value = previous.v1details().saleAssets.saleLotAssets * lotsPurchased;

                    totalProgress = SaleProgressDetailsV1{
                        lastPurchaseAt: nowRange.start,
                        prevPurchaseAt: prevProgress.lastPurchaseAt,
                        lotCount: nextProgress.lotCount,
                        lotsSold: prevProgress.lotsSold + lotsPurchased
                    };

                    pricingStrategy = DynamicSaleV1{
                        settings: previous.v1details().fixedSaleDetails.settings,
                        purchase: DTS_PurchaseInfo::create(
                            lotsPurchased: lotsPurchased,
                            purchaseTime: nowRange.start,
                            prevPurchaseTime: prevProgress.lastPurchaseAt,
                            prevSalePace: previous.v1details().saleState.salePace,
                            totalProgress: totalProgress
                        ),
                        sale: previous,
                        updatedSale: Option[MarketSaleData]::Some{updated}
                        // prevSalePace: previous.v1details().saleState.salePace,
                        // updatedSettings: Option[DynamicSaleV1Settings]::None
                    };
                    
                    // print("ok pricing strategy");
                    // lotPrice : Real = pricingStrategy.getlotPrice();
                    // print("  -- lotPrice: " + lotPrice.show());

                    // costForPurchase : Value = Value::lovelace( 
                    //     (
                    //         // delegate this to the selected pricing strategy!
                    //         lotPrice * lotsPurchased
                    //         * 1_000_000
                    //     ).floor()
                    // );

                    paidValue : Value = newValue - oldValue + purchasedTokens;
                    
                    // print("  -- costForPurchase: " + costForPurchase.show());
                    print("  -- paidValue: ");
                    print(paidValue.show());
                    // if (!paidValue.contains(costForPurchase)) {
                    //     error( "insufficient payment")
                    // };
                    // if (!costForPurchase.contains(paidValue)) {
                    //     error( "overpayment or wrong distribution of purchased tokens")
                    // };
                    // print("  -- payment ok");

                    // todo: the purchased tokens are distributed to a
                    //   configured sale-distribution contract (e.g. vesting/escrow/yield-farm)
                    
                    assertREQTgroup("Matches redeemer payment with paid value", false, () -> Bool {
                        print("  -- paidValue: "+ paidValue.show());
                        print("  -- lotSellPrice: "+ lotSellPrice.show());
                        print("  -- lotsPurchased: "+ lotsPurchased.show());
                        expectedPayment = lotSellPrice * lotsPurchased;
                        print("  -- expected payment: "+ expectedPayment.show());
                        print("  -- actual payment: "+ paidValue.show());

                        paidValue == expectedPayment
                    });

                    true
                    && correctActiveState
                    && bREQT("ensures the sale record is updated with sale-progress details")
                    && nextProgress.validateUpdatedDetails(
                        prevProgress, 
                        nowRange.start, 
                        lotsPurchased
                    ).trace("details updated correctly? ")
                    && bREQT("ensures the sale record is updated with dynamic sale details")
                    && pricingStrategy.validateUpdatedDetails()
                    && bREQT("Requires payment according to the dynamic pricing strategy")
                    && pricingStrategy.isRightPayment(lotSellPrice, paidValue).trace("  -- right payment? ")
                    // && costForPurchase.contains(paidValue).trace("payment correct and tokens distributed? ")
                    && true
                }),
                MergingChildChunk => { //{_, _ /* recId, childChunkId */} => {
                    error("todo: MergingChildChunk")
                },
                Stopping {saleId} => logGroup("Stopping sale:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);
                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    previous.v1details().saleState.mustBeActive("Stopping: previous sale");
                    updated.v1details().saleState.mustBePaused(
                        "Stopping: updated sale", "REQT-fx7m3y1ctf"
                    );

                    true
                    && updated.validateStateOnlyChange(previous, "REQT-nxqq219k4r")
                    && bREQTgroup(
                        reqt: "UTxO token assets unchanged, ADA within 1 ADA tolerance (REQT-03ff0mfddc)",
                        collapsed: false,
                        callback: () -> Bool {
                            inputValue = mktSaleDD.input().value;
                            outputValue = mktSaleDD.output().value;
                            assert(
                                inputValue.get_assets() == outputValue.get_assets(),
                                "UTxO tokens changed during Stopping"
                            );
                            adaDiff = (inputValue.get_lovelace() - outputValue.get_lovelace()).abs();
                            assert(
                                adaDiff <= 1000000,
                                "ADA changed by more than 1 ADA during Stopping: delta " + adaDiff.show()
                            );
                            true
                        }
                    )
                    && cctx.requiresGovAuthority().orFail()
                }),
                Resuming {saleId} => logGroup("Resuming sale:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);
                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    previous.v1details().saleState.mustBePaused(
                        "Resuming: previous sale", "REQT-3h96mdmn5k"
                    );
                    updated.v1details().saleState.mustBeActive("Resuming: updated sale");

                    saleAssets = updated.v1details().saleAssets;
                    remainingLots = saleAssets.totalSaleLots
                        - updated.v1details().saleState.progressDetails.lotsSold;

                    true
                    && updated.validateStateOnlyChange(previous, "REQT-60azhtn9dy")
                    && bREQTgroup(
                        reqt: "UTxO token assets unchanged, ADA within 1 ADA tolerance (REQT-998waf4mz3)",
                        collapsed: false,
                        callback: () -> Bool {
                            inputValue = mktSaleDD.input().value;
                            outputValue = mktSaleDD.output().value;
                            assert(
                                inputValue.get_assets() == outputValue.get_assets(),
                                "UTxO tokens changed during Resuming"
                            );
                            adaDiff = (inputValue.get_lovelace() - outputValue.get_lovelace()).abs();
                            assert(
                                adaDiff <= 1000000,
                                "ADA changed by more than 1 ADA during Resuming: delta " + adaDiff.show()
                            );
                            true
                        }
                    )
                    && bREQTgroup(
                        reqt: "remaining sale tokens present in UTxO (REQT-qh3qkk8f92)",
                        collapsed: false,
                        callback: () -> Bool {
                            expectedAssets = saleAssets.saleLotAssets * remainingLots;
                            utxoValue = mktSaleDD.output().value;
                            print("   -- expected remaining: " + expectedAssets.show());
                            print("   -- UTxO value: " + utxoValue.show());
                            assert(
                                utxoValue.contains(expectedAssets),
                                "UTxO must contain remaining sale tokens"
                            );
                            true
                        }
                    )
                    && bREQT(
                        reqt: "VXF fields must be None on resume (REQT-1h49829nsx,88cfkdj7p2)",
                        assertion: updated.v1details().fixedSaleDetails.requireVxfFieldsNone(),
                        showSuccess: true
                    )
                    && bREQT(
                        reqt: "datum passes general validation on resume (REQT-fkww59zyt3)",
                        assertion: updated.validate(),
                        showSuccess: true
                    )
                    && cctx.requiresGovAuthority().orFail()
                }),
                UpdatingPausedSale {saleId} => logGroup("UpdatingPausedSale:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    nextRec : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    true
                    && nextRec.validateUpdatePausedSale(mktSaleDD)
                    && cctx.requiresGovAuthority().orFail()
                }),
                Retiring {saleId} => logGroup("Retiring sale:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    previous : MarketSaleData = MarketSaleData::previous(mktSaleDD);
                    updated : MarketSaleData = MarketSaleData::updated(mktSaleDD);

                    previous.v1details().saleState.mustBePaused(
                        "Retiring: previous sale", "REQT-hcagxtdt35"
                    );
                    REQT(
                        reqt: "Retiring: state must be Retired (REQT-hcagxtdt35)",
                        assertion: updated.v1details().saleState.state == MarketSaleState::Retired,
                        showSuccess: true
                    );

                    true
                    && updated.validateStateOnlyChange(previous, "REQT-9nsee3zj78")
                    && bREQTgroup(
                        reqt: "UTxO token assets unchanged, ADA within 1 ADA tolerance (REQT-dtpwzjqn9p)",
                        collapsed: false,
                        callback: () -> Bool {
                            inputValue = mktSaleDD.input().value;
                            outputValue = mktSaleDD.output().value;
                            assert(
                                inputValue.get_assets() == outputValue.get_assets(),
                                "UTxO tokens changed during Retiring"
                            );
                            adaDiff = (inputValue.get_lovelace() - outputValue.get_lovelace()).abs();
                            assert(
                                adaDiff <= 1000000,
                                "ADA changed by more than 1 ADA during Retiring: delta " + adaDiff.show()
                            );
                            true
                        }
                    )
                    && cctx.requiresGovAuthority().orFail()
                }),
                WithdrawingProceeds {saleId} => logGroup("WithdrawingProceeds:", false, () -> Bool {
                    assert(cctx.withCharterRef().orFail(), "can't");

                    mktSaleDD : DgDataDetails = cctx.updatingDgData(recIdBytes: saleId);
                    current : MarketSaleData = MarketSaleData::previous(mktSaleDD);
                    currentState = current.v1details().saleState.state;

                    bREQTgroup(
                        reqt: "withdrawal valid only in Paused, SoldOut, or Retired (REQT-ayvw26q6av)",
                        collapsed: false,
                        callback: () -> Bool {
                            currentState.switch {
                                Paused => true,
                                SoldOut => true,
                                Retired => true,
                                _ => error("WithdrawingProceeds requires Paused, SoldOut, or Retired")
                            }
                        }
                    )
                    && bREQTgroup(
                        reqt: "non-ADA tokens must remain in UTxO (REQT-gy6jd9cjkg)",
                        collapsed: false,
                        callback: () -> Bool {
                            inputAssets = mktSaleDD.input().value.get_assets();
                            outputAssets = mktSaleDD.output().value.get_assets();
                            assert(
                                inputAssets == outputAssets,
                                "non-ADA tokens changed during WithdrawingProceeds"
                            );
                            true
                        }
                    )
                    && bREQT(
                        reqt: "datum fields unchanged after withdrawal (REQT-ykqx9qgh88)",
                        assertion: mktSaleDD.inputData() == mktSaleDD.outputData(),
                        showSuccess: true,
                        onError: "datum must not change during WithdrawingProceeds"
                    )
                    && cctx.requiresGovAuthority().orFail()
                }),
                SoldOut => error("todo: SoldOut")
            },
            BurningActivities{ba} => {
                ba.switch {
                    DeletingRecord => error("use more specific burning activity"),
                    JoiningWithParentChunk => { //{_, _, _/* recId, parentChunkId */} => {
                        // burns the indicated chunk UUT
                        // requires the parent-chunk to be updated with MergingChildChunk
                        //  ^^^ requires that the DelegatedData activities are structured 
                        //   ... with tight binding to delegate activities from this module
                        // !!!!!!!!!!!!!!!!!!!!!!!!!!! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        error("todo: JoinWithParent: Implement the above details") // ^^^
                    },
                    CleanupRetired => {//{_/* recId */} => {
                        // burns the indicated chunk UUT

                        error("todo: CleanupRetired")
                        // requires that the chunk is retired

                        // burns the remaining previous.totalTokenCount

                        // !!! todo: more details to account positively for the number of tokens actually sold
                        //   ... by this chunk
                        //   ... and in aggregate (this chunk and its children)

                    }
                }
            },
            OtherActivities => error(
                "no other activities exist in this delegate"
            ),
            _ => false
        } || tx.serialize() == priorMddd.serialize()        
    }

    func supportedCapoDelegatePurposes(self) -> []String {
        assert(true || /* prevent unused variable */ self == self, "no way" );
         []String{
            // "nothingHereYet",
        }
    }

    //! Used only for validating non-IsDelegation datum types and activities.
    // if you have any special admininstrative data structures that inform 
    // ...  your minting policy, this might be useful.  Otherwise, and typically,
    // ... you should look to Activity validations above in additionalDelegateValidation,
    // ...  in which the isDelegation token is being spent with an application-specific
    // ...  activity/redeemer
    func otherDatumValidation( self,
        _priorMdd: DelegateDatum        
    ) -> Bool {
        neverTriggered = () -> {  error("never called") };
        self.switch{
            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.
            //  Using it on any other Datum type will always fail and execution will never arrive here.
            DelegateLifecycleActivities => neverTriggered(),
            CapoLifecycleActivities => neverTriggered(),

            // -- Application-specific activities can be added here 
            // -- for special & app-specific types of datum in a delegate,
            // -- for EXCEPTIONAL cases, if you really know what you're doing.  
            //  -- see above for normal cases

            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls
        }
    }
}


// func getlotPrice(mktSale: OutputDatum::Inline, now: Time, lotsPurchased: Int) -> Real {
//     mkPricingStrategy(
//         MarketSaleData::from_data(mktSale.data), 
//         now, 
//         lotsPurchased
//     ).getlotPrice()
// }
