module MarketSaleData

import {
    REQT,
    bREQT,
    REQTgroup,
    assertREQTgroup,
    bREQTgroup,
    logGroup,
    logGroupUnit,
    logGroupStart,
    logGroupEnd,
    TODO
} from StellarHeliosHelpers

import {
    DgDataDetails,
    CapoCtx,
    mkCapoCtx
} from CapoHelpers

import {
    DynamicSaleV1Settings
} from DynamicSaleV1Settings

import {
    SaleProgressDetailsV1
} from SaleProgressDetails

import {
    VxfDestination
} from VxfProtocol

enum MarketSaleState {
    Pending
    Active
    Retired
    SoldOut
}

struct SaleAssetsV1 {
    saleUnitAssets: Value
    singleBuyMaxUnits: Int
    primaryAssetMph: MintingPolicyHash
    primaryAssetName: ByteArray
    primaryAssetTargetCount: Int 
    totalSaleUnits: Int
}

struct FixedSaleDetailsV1 {
    settings: DynamicSaleV1Settings
    // ^ was saleStrategy: AnySaleStrategy "strat" 
    startAt: Time

    // these details about the sale should always be sync'd to nested chunks
    vxfTokensTo: Option[VxfDestination]
    vxfFundsTo: Option[VxfDestination] 
}

struct OtherSaleStateV1 {
    progressDetails: SaleProgressDetailsV1
    salePace: Real
    state: MarketSaleState 
    // ^ was saleStrategyState: AnySaleState "stratState" 

    func mustBeActive(self, which : String) -> () {
        REQT(
            reqt: which + ": state must be Active",  
            assertion: self.state == MarketSaleState::Active, 
            showSuccess: true
        )
    }

    func mustBePending(self, which : String) -> () {
        REQT(
            reqt: which + ": state must be Pending",  
            assertion: self.state == MarketSaleState::Pending, 
            showSuccess: true
        )
    }
}

struct ThreadInfoV1 {
    // These details will always start with zero values.  
    // They act as reference-counters, and they increment during split/join transactions
    nestedThreads: Int
    retiredThreads: Int
    
    // Each chunk should point to the chunk it was split from.  Level 1 chunks will have parentChunkId == saleId
    parentChunkId: ByteArray 
    chunkForkedAt: Time 

    // saleId is empty in the root MarketSale.
    // each split chunk should point to the root MarketSale 
    saleId: ByteArray 

    func validateDetailsWhenPending(self, saleId: ByteArray) -> Bool {
        logGroup("ThreadInfoV1: validateDetailsWhenPending()", false, () -> Bool {
            assert(self.parentChunkId == #, "parentChunkId must be empty");
            assert(self.saleId == saleId, "saleId must be equal to saleId");
            assert(self.nestedThreads == 0, "nestedThreads must be zero");
            assert(self.retiredThreads == 0, "retiredThreads must be zero");
            true
        })
    }
}

enum MktSaleDetails {
    4000: V1 {
        saleState: OtherSaleStateV1
        fixedSaleDetails: FixedSaleDetailsV1
        saleAssets: SaleAssetsV1
        threadInfo: ThreadInfoV1 
    }
}

struct MarketSaleData {
    id: ByteArray  "@id"
    type: String "tpe"
    name: String
    details: MktSaleDetails "dtl"

    // func totalSaleSize(self) -> Value {
    //     self.moreFields.saleAssets.saleUnitAssets * self.moreFields.saleAssets.totalSaleUnits
    // }

    func v1details(self) -> MktSaleDetails::V1 {
        self.details.switch {
            v1: V1 => v1
            // _ => error("expected V1 details")
        }
    }

    func primaryAsset(self) -> AssetClass {
        assets = self.v1details().saleAssets;
        AssetClass::new(assets.primaryAssetMph, assets.primaryAssetName)
    }

    func lotSizeForToken(self, assetClass : AssetClass, optional: Bool = false) -> Int {
        count = self.v1details().saleAssets.saleUnitAssets
            .get_safe(assetClass)

        if (!optional) {
            assert(count > 0, "lot size is zero: "+ assetClass.show())
        };
        count
    }

    func validate(self) -> Bool {
    logGroup("mktSale: validate()", false, () -> Bool {
        assert(self.type == "mktSale", "wrong type");
        assert(self.name.serialize().length > 10, "name must be at least 10 characters");
        saleAssets = self.v1details().saleAssets;
        assertREQTgroup("validate: primary asset must be divisible by totalSaleUnits", false, () -> Bool {
            print("  -- saleAssets "+ saleAssets.totalSaleUnits.show() + " x " + saleAssets.saleUnitAssets.show());

            primaryLotSize = self.lotSizeForToken(self.primaryAsset());
            expectedTargetCount = primaryLotSize * saleAssets.totalSaleUnits;
            print("  -- primaryAssetTargetCount: " + saleAssets.primaryAssetTargetCount.show());
            print("  -- expectedTargetCount: " + expectedTargetCount.show());
            assert(
                expectedTargetCount == saleAssets.primaryAssetTargetCount, 
                "saleUnitAssets' primaryToken mismatch: lot-size * totalSaleUnits != primaryAssetTargetCount"
            );
            true
        });

        // assert(self.currentUnitPrice > 0, "currentUnitPrice must be greater than zero");

        REQT(
            reqt: "saleUnitAssets must not be empty", 
            assertion: saleAssets.saleUnitAssets.to_map().length > 0, 
            showSuccess: true
        );
        REQT(
            reqt: "totalSaleUnits must be greater than zero", 
            assertion: saleAssets.totalSaleUnits > 0, 
            showSuccess: true
        );
        REQT(
            reqt: "singleBuyMaxUnits must be greater than zero", 
            assertion: saleAssets.singleBuyMaxUnits > 0, 
            showSuccess: true
        );
        REQT(
            reqt: "singleBuyMaxUnits must be less than totalSaleUnits", 
            assertion: saleAssets.singleBuyMaxUnits < saleAssets.totalSaleUnits, 
            showSuccess: true
        );
        REQT(
            reqt: "primaryAssetTargetCount must be greater than zero", 
            assertion: saleAssets.primaryAssetTargetCount > 0, 
            showSuccess: true
        );
        true
        && true
    })  }

    func validateDetailsWhenPending(self, which : String) -> Bool {
        logGroup("mktSale: validateDetailsWhenPending(): " + which, false, () -> Bool {
            details = self.v1details();
            saleState = details.saleState;
            REQT(
                reqt: "salePace must be initialized to 1.0", 
                assertion: saleState.salePace == 1.0, 
                showSuccess: true
            );
        // assert(self.weightedPace == 0 * Duration::SECOND, "weightedPace must be zero");
            saleDetails = details.fixedSaleDetails;
            saleAssets = details.saleAssets;

            saleState.mustBePending(which + ": created sale")
            true
            && saleDetails.settings.validateDetailsWhenPending()
            && saleState.progressDetails.validateDetailsWhenPending(
                saleDetails.startAt, 
                saleAssets.totalSaleUnits
            )
            && details.threadInfo.validateDetailsWhenPending(self.id)
            && true
        })
    }

    func validatePrimaryAssetOnlyOnCreation(self) -> Bool {
        bREQTgroup("mktSale: when creating, only allows primary asset in saleUnitAssets", false, () -> Bool {
            saleAssets = self.v1details().saleAssets;
            primaryPerUnit : Int = saleAssets.primaryAssetTargetCount / saleAssets.totalSaleUnits;
            print("  -- primaryPerUnit: " + primaryPerUnit.show());
            expectedPrimaryOnly : Value = Value::new(
                AssetClass::new(
                    saleAssets.primaryAssetMph,
                    saleAssets.primaryAssetName
                ),
                primaryPerUnit
            );
            print("  -- expected asset bundle: " + expectedPrimaryOnly.show());
            print("  -- actual asset bundle: " + saleAssets.saleUnitAssets.show());
            assert(
                saleAssets.saleUnitAssets == expectedPrimaryOnly,
                "saleUnitAssets must only reference the primary asset when created"
            );
            true
        })
    }

    func validateActivating(self, utxoValue: Value, DDdetails: DgDataDetails) -> Bool {
        logGroup("mktSale: validateActivating()", false, () -> Bool {
        previous = MarketSaleData::previous(DDdetails);
        // expectedDatum : ByteArray = previous.copy(
        //     state: MarketSaleState::Active
        // ).serialize();
        // print("expectedDatum: ");
        // print(expectedDatum.show());
        // print("actualDatum: ");
        // print(self.serialize().show());
        // assert(expectedDatum == self.serialize(), "Activating a sale may only change the state to Active");

        REQT(
            reqt: "name must not change", 
            assertion: self.name == previous.name,
            showSuccess: true
        );

        previous.v1details().saleState.mustBePending("previous sale");

        REQT(
            reqt: "state must be changed to Active", 
            assertion: self.v1details().saleState.state == MarketSaleState::Active,
            showSuccess: true
        );

        // ok to change the sale start time
        // assert(self.startAt == previous.startAt, "startAt must not change");

        // assert(self.lastPurchaseAt == previous.lastPurchaseAt, "lastPurchaseAt must not change");
        // assert(self.prevPurchaseAt == previous.prevPurchaseAt, "prevPurchaseAt must not change");

        // assert(self.weightedPace == previous.weightedPace, "weightedPace must not change");
        // ok to change the assets & sale units, as long as everthing else checks out
        //    assert(self.saleUnitAssets == previous.saleUnitAssets, "saleUnitAssets must not change");
        //    assert(self.totalSaleUnits == previous.totalSaleUnits, "totalSaleUnits must not change");
        //    assert(self.singleBuyMaxUnits == previous.singleBuyMaxUnits, "singleBuyMaxUnits must not change");
        //    assert(self.currentUnitPrice == previous.currentUnitPrice, "currentUnitPrice must not change");

        assertREQTgroup("validateActivating: must have the required assets deposited to the sale", false, 
        () -> Bool {
            assets : Value = utxoValue.get_assets() - DDdetails.uutValue();
            print("expected assets: " + assets.show());

            assert(
                self.v1details().saleAssets.saleUnitAssets * 
                self.v1details().saleAssets.totalSaleUnits == assets, 
                "utxo must contain the supply of tokens to be sold"
            );
            true
        });

        assertREQTgroup("validates VxfDestination in vxfTokensTo field", false, 
        () -> Bool {
            self.v1details().fixedSaleDetails.vxfTokensTo.switch {
                Some{vxf} => {
                    assert(vxf.validate("vxfTokensTo"), "<-- that fails; this can't");
                },
                None => {
                    print("  -- vxfTokensTo is not restricted");
                }
            };
            true
        });

        assertREQTgroup("validates VxfDestination in vxfFundsTo field", false, 
        () -> Bool {
            assert(
                self.v1details().fixedSaleDetails.vxfFundsTo.unwrap().validate("vxfFundsTo"),
                "vxfFundsTo invalid"
            );
            true
        });

        true
        && self.v1details().threadInfo.validateDetailsWhenPending(self.id)
        && true
    })
    }

    func previous(ddd : DgDataDetails) -> MarketSaleData {
        MarketSaleData::from_data(ddd.inputData())    
    }

    func updated(ddd : DgDataDetails) -> MarketSaleData {
        MarketSaleData::from_data(ddd.outputData())
    }

   func validateAdding(self, ddd : DgDataDetails, mph : MintingPolicyHash, tn: ByteArray) -> Bool {
        updated = self
        previous = MarketSaleData::previous(ddd);
        
        outValue : Value = ddd.output().value;
 
        updatedAssetCount : Int = outValue.get_policy(mph).get(tn);
                // print("primary tn" + self.primaryAssetName.decode_utf8());
                // print("this tn: " + tn.decode_utf8());
                // print("primary mph" + self.primaryAssetMph.show());
                // print("this mph: " + mph.show());

        currentAssets = previous.v1details().saleAssets;
        currentState = previous.v1details().saleState;
        nextAssets = updated.v1details().saleAssets;
        nextState = updated.v1details().saleState;
        isPrimary : Bool = ( true
            && ( mph == currentAssets.primaryAssetMph )
                .trace("    -- is primary mph? ")
            && ( tn == currentAssets.primaryAssetName )
                .trace("    -- is primary tn? ")
        ).trace("  -- isPrimary? ");
            
        print("vvv ... for added tn: "+ tn.show());
        updatedAssetChunkSize : Int = nextAssets.saleUnitAssets.get_policy(mph).get(tn);
        
        // calculate the incremental amount being added
        inValue : Value = ddd.input().value;
        assetClass : AssetClass = AssetClass::new(mph, tn);
        previousAssetCount : Int = inValue.get_safe(assetClass);
        incrementalAmount : Int = updatedAssetCount - previousAssetCount;
        
        expectedAssetCount : Int = if (isPrimary) {
            existingAssetChunkSize : Int = currentAssets.saleUnitAssets.get_policy(mph).get(tn);
            if (updatedAssetChunkSize < existingAssetChunkSize) {
                error("primary asset chunk size shouldn't decrease")
            };
            print("    ... each sale-unit has " + updatedAssetChunkSize.show());
            print("    ... sale now supplied with " + updatedAssetCount.show());
            print("    ... ^ / saleUnits  "+ nextAssets.totalSaleUnits.show());
            
            // if tokens are already deposited (previousAssetCount > 0), 
            // then progressive funding is allowed in any amount
            // otherwise (first addition), the amount must be divisible by totalSaleUnits
            // Note: saleUnitAssets may be configured even when no tokens are deposited yet
            if (previousAssetCount == 0) {
                isEvenChunk : Bool = incrementalAmount % nextAssets.totalSaleUnits == 0;
                if (!isEvenChunk) {
                    error("primary asset incremental amount must be divisible by totalSaleUnits")
                };
            };
            
            percentSupplied = 100.0 * updatedAssetCount / nextAssets.primaryAssetTargetCount;
            print("Now supplied with "+ percentSupplied.show() +"% of the primary token");
    
            // allows that the primary tokens can be progressively funded,
            // without disturbing the sale-unit chunk size for that primary token
            updatedAssetCount
        } else {            
            isEvenChunk : Bool = updatedAssetCount % nextAssets.totalSaleUnits == 0;
            print("got "+ updatedAssetCount.show());
            print("Expected chunks of "+ nextAssets.totalSaleUnits.show());
            if (!isEvenChunk) {
                error("new non-primary asset must have an even distribution for each unit of sale")
            };

            print("    ... each sale-unit has " + updatedAssetChunkSize.show());
            print("    ... ^ times sale-units  "+ nextAssets.totalSaleUnits.show());

            // non-primary tokens must have the sale-unit sync'd with the deposited value
            expected : Int = updatedAssetChunkSize * nextAssets.totalSaleUnits;
            print("Expecting the value to be = "+ expected.show() + " (= current Value/this-tn)");
            
            expected
        };
        // check that the deposited assets don't exceed the number of tokens implied by the saleUnitAssets * totalSaleUnits 
        print("    ... updated value has "+ updatedAssetCount.show() + " " + tn.show());
        hasMatchyValue : Bool = if (updatedAssetCount != expectedAssetCount) {
            if (isPrimary) {
                error("no way") // unreachable
            };
            error("The updated sale-units * sale-unit-count / this-tn must match the updated deposit-value / this-tn")
        } else { true };

        currentState.mustBePending("AddTokens: previous version")
        nextState.mustBePending("AddTokens: updated sale")

        true
        && hasMatchyValue
        && updated.validate()
        && updated.v1details().threadInfo.validateDetailsWhenPending(updated.id)
        && true
    }

    //! Validates updates to a MarketSale while it's in Pending state.
    //  This function enforces which fields may be updated and which must remain unchanged.
    func validateUpdatePendingSale(self, ddd : DgDataDetails) -> Bool {
        print("mktSale: validateUpdatePendingSale()");
        previous : MarketSaleData = MarketSaleData::from_data(
            ddd.inputData()
        );
        
        prevDetails = previous.v1details();
        nextDetails = self.v1details();
        
        prevState = prevDetails.saleState;
        nextState = nextDetails.saleState;
        nextFixed = nextDetails.fixedSaleDetails;
        prevAssets = prevDetails.saleAssets;
        nextAssets = nextDetails.saleAssets;
        prevUtxoValue : Value = ddd.input().value;
                
        // Core constraints (diagnostic-friendly)
        assertREQTgroup( reqt: "fails if the token count in the UTxO is modified during the update", collapsed:false, 
        callback: () -> Bool {
            inputAssets = ddd.input().value.get_assets();
            outputAssets = ddd.output().value.get_assets();
            assert(inputAssets == outputAssets, "UTxO tokens changed; delta:  " + (outputAssets - inputAssets).show());
            true
        })

        REQT("doesn't allow changing sale pace from 1.0",
            assertion: nextState.salePace == 1.0,
            showSuccess: true
        );

        prevState.mustBePending("UpdatingPendingSale: previous record") 
        nextState.mustBePending("UpdatingPendingSale: updated record")
    
        REQT(
            reqt: "doesn't allow changing thread info",
            assertion: prevDetails.threadInfo == nextDetails.threadInfo,
            showSuccess: true
        );
        
        // Primary asset identity change logic
        primaryAssetChanged : Bool = (
            nextAssets.primaryAssetMph != prevAssets.primaryAssetMph
        ) || (
            nextAssets.primaryAssetName != prevAssets.primaryAssetName
        );
        
        if (primaryAssetChanged) {
        REQTgroup("when primary asset is changed ...", false, () -> Bool {
            previousPrimaryAssetName : String = prevAssets.primaryAssetName.decode_utf8_safe();
            nextPrimaryAssetName : String = nextAssets.primaryAssetName.decode_utf8_safe();
            print("    ... primary asset changed from " + previousPrimaryAssetName + 
                " to " + nextPrimaryAssetName
            );
            // REQT("if primary asset changes, check if old primary asset tokens exist in previous UTxO");
            prevUtxoAssets : Value = prevUtxoValue - ddd.uutValue();
            oldPrimaryAssetsDeposited : Int = prevUtxoAssets
                .get_policy(prevAssets.primaryAssetMph)
                .get(prevAssets.primaryAssetName);
            
            hasOldPrimaryTokens : Bool = oldPrimaryAssetsDeposited > 0;
            
            if (hasOldPrimaryTokens) {                
            bREQTgroup("when old primary asset tokens are present in the UTxO ...", false, () -> Bool {
                print("   -- utxo has " + oldPrimaryAssetsDeposited.show() + " " + previousPrimaryAssetName);

                nextSaleUnitOldPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(prevAssets.primaryAssetMph)
                    .get(prevAssets.primaryAssetName);

                print("   -- next saleUnit has " + nextSaleUnitOldPrimary.show() + " " + previousPrimaryAssetName);

                assertREQTgroup("... saleUnitAssets‹primaryAsset› must keep a minimum lot-size, ≥ depositedTokens/totalSaleUnits", false, () -> Bool {
                    expectedOldPrimaryPerLot : Int = oldPrimaryAssetsDeposited / nextAssets.totalSaleUnits;
                    print("    ... expectedOldPrimaryPerLot: " + expectedOldPrimaryPerLot.show());
                    assert(
                        nextSaleUnitOldPrimary >= expectedOldPrimaryPerLot,
                        "insufficient lot-size for previous primary asset"
                    );
                    true
                });

                bREQTgroup("... saleUnitAssets must contain the NEW primary token", false, () -> Bool {
                    nextSaleUnitNewPrimary : Int = nextAssets.saleUnitAssets
                        .get_assets()
                        .get_policy(nextAssets.primaryAssetMph)
                        .get(nextAssets.primaryAssetName);
                    assert(
                        nextSaleUnitNewPrimary > 0,
                        "saleUnitAssets doesn't contain the new primary asset"
                    );
                    true
                }) 
            }) } else {
            bREQTgroup("when no old primary asset tokens are present in the UTxO ...", false, () -> Bool {
                nextSaleUnitOldPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(prevAssets.primaryAssetMph)
                    .get(prevAssets.primaryAssetName);
                
                assertREQTgroup("... saleUnitAssets must not reference old primary token", false, () -> Bool {
                    print("   -- " + nextSaleUnitOldPrimary.show() + " " + previousPrimaryAssetName);
                    assert(
                        nextSaleUnitOldPrimary == 0,
                        "saleUnitAssets has old primary tokens remaining"
                    );
                    true
                });
                
                nextSaleUnitNewPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(nextAssets.primaryAssetMph)
                    .get(nextAssets.primaryAssetName);

                bREQTgroup("...saleUnitAssets must reference new primary asset", false, () -> Bool {                
                    print("   -- next saleUnit has " + nextSaleUnitNewPrimary.show() + " " + nextPrimaryAssetName);
                    assert(
                        nextSaleUnitNewPrimary > 0,
                        "saleUnitAssets must reference new primary asset"
                    );
                    true
                });
            }) }
        }) }
        
        // Primary asset target count consistency
        assertREQTgroup("fails if primaryAssetTargetCount is not an even multiple of the lot count", false, () -> Bool {
            nextPrimaryPerUnit : Int = nextAssets.saleUnitAssets
                .get_assets()
                .get_policy(nextAssets.primaryAssetMph)
                .get(nextAssets.primaryAssetName);
            expectedTargetCount : Int = nextAssets.totalSaleUnits * nextPrimaryPerUnit;
            assert(
                nextAssets.primaryAssetTargetCount == expectedTargetCount,
                "lot size has uneven primaryAssetTargetCount and mismatch with target count"
            );
            true
        });
        
        // Validate VxfDestination fields
        REQT("validates VxfDestination in vxfTokensTo if Some");
        nextFixed.vxfTokensTo.switch {
            Some{vxf} => {
                assert(vxf.validate("vxfTokensTo"), "vxfTokensTo must be valid");
            },
            None => {
                print("  -- vxfTokensTo is None (allowed)");
            }
        }
        
        REQT("validates VxfDestination in vxfFundsTo if Some");
        nextFixed.vxfFundsTo.switch {
            Some{vxf} => {
                assert(vxf.validate("vxfFundsTo"), "vxfFundsTo must be valid");
            },
            None => {
                print("  -- vxfFundsTo is None (allowed for pending updates)");
            }
        }
        
        // Final validations
        REQT("validates updated record passes all general validations");
        assert(self.validate(), "updated record must pass general validation");
        
        REQT("validates updated record passes pending-specific validations");
        assert(
            self.v1details().threadInfo.validateDetailsWhenPending(self.id),
            "updated record must pass pending validations"
        );
        
        REQT("validates settings");
        assert(
            nextFixed.settings.validateDetailsWhenPending(),
            "updated settings must pass validation"
        );
        
        REQT("validates progressDetails still matches startAt and totalSaleUnits");
        assert(
            nextState.progressDetails.validateDetailsWhenPending(
                nextFixed.startAt,
                nextAssets.totalSaleUnits
            ),
            "progressDetails must be consistent with startAt and totalSaleUnits"
        );
        
        true
    }
}