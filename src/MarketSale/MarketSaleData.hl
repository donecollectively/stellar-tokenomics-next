module MarketSaleData

import {
    REQT,
    bREQT,
    TODO
} from StellarHeliosHelpers

import {
    DgDataDetails,
    CapoCtx,
    mkCapoCtx
} from CapoHelpers

import {
    DynamicSaleV1Settings
} from DynamicSaleV1Settings

import {
    SaleProgressDetailsV1
} from SaleProgressDetails

import {
    VxfDestination
} from VxfProtocol

enum MarketSaleState {
    Pending
    Active
    Retired
    SoldOut
}

struct SaleAssetsV1 {
    saleUnitAssets: Value
    singleBuyMaxUnits: Int
    primaryAssetMph: MintingPolicyHash
    primaryAssetName: ByteArray
    primaryAssetTargetCount: Int 
    totalSaleUnits: Int
}

struct FixedSaleDetailsV1 {
    settings: DynamicSaleV1Settings
    // ^ was saleStrategy: AnySaleStrategy "strat" 
    startAt: Time

    // these details about the sale should always be sync'd to nested chunks
    vxfTokensTo: Option[VxfDestination]
    vxfFundsTo: Option[VxfDestination] 
}

struct OtherSaleStateV1 {
    progressDetails: SaleProgressDetailsV1
    salePace: Real
    state: MarketSaleState 
    // ^ was saleStrategyState: AnySaleState "stratState" 

    func mustBeActive(self, which : String) -> Bool {
        if (self.state == MarketSaleState::Active) {
            true
        } else {
            error(which + ": state must be Active")
        }
    }

    func mustBePending(self, which : String) -> Bool {
        if (self.state == MarketSaleState::Pending) {
            true
        } else {
            error(which + ": state must be Pending")
        }
    }
}

struct ThreadInfoV1 {
    // These details will always start with zero values.  
    // They act as reference-counters, and they increment during split/join transactions
    nestedThreads: Int
    retiredThreads: Int
    
    // Each chunk should point to the chunk it was split from.  Level 1 chunks will have parentChunkId == saleId
    parentChunkId: ByteArray 
    chunkForkedAt: Time 

    // saleId is empty in the root MarketSale.
    // each split chunk should point to the root MarketSale 
    saleId: ByteArray 
}

enum MktSaleDetails {
    4000: V1 {
        saleState: OtherSaleStateV1
        fixedSaleDetails: FixedSaleDetailsV1
        saleAssets: SaleAssetsV1
        threadInfo: ThreadInfoV1 
    }
}

struct MarketSaleData {
    id: ByteArray  "@id"
    type: String "tpe"
    name: String
    details: MktSaleDetails "dtl"

    // func totalSaleSize(self) -> Value {
    //     self.moreFields.saleAssets.saleUnitAssets * self.moreFields.saleAssets.totalSaleUnits
    // }

    func v1details(self) -> MktSaleDetails::V1 {
        self.details.switch {
            v1: V1 => v1
            // _ => error("expected V1 details")
        }
    }

    func validate(self) -> Bool {
        print("mktSale: validate()");
        assert(self.type == "mktSale", "wrong type");
        assert(self.name.serialize().length > 10, "name must be at least 10 characters");
        saleAssets = self.v1details().saleAssets;
        assert(
            saleAssets.totalSaleUnits *
            saleAssets.saleUnitAssets
            .get_assets()
                .get_policy(saleAssets.primaryAssetMph)
                .get(saleAssets.primaryAssetName) 
            == saleAssets.primaryAssetTargetCount, 
            "saleUnitAssets' primary-token value must divide the target-count over the sale-unit count"
        );

        // assert(self.currentUnitPrice > 0, "currentUnitPrice must be greater than zero");

        assert(saleAssets.saleUnitAssets.get_assets().to_map().length > 0, "saleUnitAssets must not be empty");
        assert(saleAssets.totalSaleUnits > 0, "totalSaleUnits must be greater than zero");
        assert(saleAssets.singleBuyMaxUnits > 0, "singleBuyMaxUnits must be greater than zero");
        assert(saleAssets.singleBuyMaxUnits < saleAssets.totalSaleUnits, "singleBuyMaxUnits must be less than totalSaleUnits");

        true
    }

    func validatePendingDetails(self) -> Bool {
        print("mktSale: validatePendingDetails()");
        threadInfo = self.v1details().threadInfo;
        assert(threadInfo.parentChunkId == #, "parentChunkId must be empty");
        assert(threadInfo.saleId == self.id, "saleId must be equal to id");
        assert(threadInfo.nestedThreads == 0, "nestedThreads must be zero");
        assert(threadInfo.retiredThreads == 0, "retiredThreads must be zero");

        true
    }

    func validateCreatedDetails(self) -> Bool {
        print("mktSale: validateCreatedDetails()");
        saleState = self.v1details().saleState;
        assert(saleState.salePace == 1.0, "salePace must be initialized to 1.0");
        // assert(self.weightedPace == 0 * Duration::SECOND, "weightedPace must be zero");
        saleDetails = self.v1details().fixedSaleDetails;
        saleAssets = self.v1details().saleAssets;
        true
        && saleState.mustBePending("created").trace("must be Pending? ")
        && saleDetails.settings.validateCreatedDetails()
        && saleState.progressDetails.validateCreatedDetails(
            saleDetails.startAt, 
            saleAssets.totalSaleUnits
        ).trace("progress details OK? ")
        && true
    }

    func validateActivating(self, utxoValue: Value, DDdetails : DgDataDetails ) -> Bool {
        print("mktSale: validateActivating()");
        prevMktSale : MarketSaleData = MarketSaleData::from_data(
            DDdetails.inputData()
        );
        // expectedDatum : ByteArray = prevMktSale.copy(
        //     state: MarketSaleState::Active
        // ).serialize();
        // print("expectedDatum: ");
        // print(expectedDatum.show());
        // print("actualDatum: ");
        // print(self.serialize().show());
        // assert(expectedDatum == self.serialize(), "Activating a sale may only change the state to Active");

        assert(self.name == prevMktSale.name, "name must not change");
        assert(
            prevMktSale.v1details().saleState.mustBePending("old"), 
            "previous sale not Pending"
        );
        assert(self.v1details().saleState.state == MarketSaleState::Active, "state must be Active");
        // ok to change the sale start time
        // assert(self.startAt == prevMktSale.startAt, "startAt must not change");

        // assert(self.lastPurchaseAt == prevMktSale.lastPurchaseAt, "lastPurchaseAt must not change");
        // assert(self.prevPurchaseAt == prevMktSale.prevPurchaseAt, "prevPurchaseAt must not change");

        // assert(self.weightedPace == prevMktSale.weightedPace, "weightedPace must not change");
        // ok to change the assets & sale units, as long as everthing else checks out
        //    assert(self.saleUnitAssets == prevMktSale.saleUnitAssets, "saleUnitAssets must not change");
        //    assert(self.totalSaleUnits == prevMktSale.totalSaleUnits, "totalSaleUnits must not change");
        //    assert(self.singleBuyMaxUnits == prevMktSale.singleBuyMaxUnits, "singleBuyMaxUnits must not change");
        //    assert(self.currentUnitPrice == prevMktSale.currentUnitPrice, "currentUnitPrice must not change");

        assets : Value = utxoValue.get_assets() - DDdetails.uutValue();
        print("expected assets: ");
        print(assets.show());

        assert(self.v1details().saleAssets.saleUnitAssets * self.v1details().saleAssets.totalSaleUnits == assets, "utxo must contain the supply of tokens to be sold");

        REQT("validates VxfDestination in vxfTokensTo field");
        self.v1details().fixedSaleDetails.vxfTokensTo.switch {
            Some{vxf} => {
                assert(vxf.validate("vxfTokensTo"), "<-- that fails; this can't");
            },
            None => {
                print("  -- vxfTokensTo is not restricted");
            }
        }

        REQT("validates VxfDestination in vxfFundsTo field");
        assert(
            (
                self.v1details().fixedSaleDetails.vxfFundsTo.unwrap().validate("vxfFundsTo")
            ).trace("  -- vxfFundsTo ok? "), 
            "^^^ that fails; this can't"
        );


        true
        && self.validatePendingDetails() 
        && true
    }

    func previous(ddd : DgDataDetails) -> MarketSaleData {
        MarketSaleData::from_data(ddd.inputData())    
    }

    func updated(ddd : DgDataDetails) -> MarketSaleData {
        MarketSaleData::from_data(ddd.outputData())
    }

   func validateAdding(self, ddd : DgDataDetails, mph : MintingPolicyHash, tn: ByteArray) -> Bool {
        updated : MarketSaleData = MarketSaleData::updated(ddd);
        outValue : Value = ddd.output().value;
 
        updatedAssetCount : Int = outValue.get_policy(mph).get(tn);
                // print("primary tn" + self.primaryAssetName.decode_utf8());
                // print("this tn: " + tn.decode_utf8());
                // print("primary mph" + self.primaryAssetMph.show());
                // print("this mph: " + mph.show());

        currentAssets = self.v1details().saleAssets;
        currentState = self.v1details().saleState;
        nextAssets = updated.v1details().saleAssets;
        nextState = updated.v1details().saleState;
        isPrimary : Bool = ( true
            && ( mph == currentAssets.primaryAssetMph )
                .trace("    -- is primary mph? ")
            && ( tn == currentAssets.primaryAssetName )
                .trace("    -- is primary tn? ")
        ).trace("  -- isPrimary? ");
            
        print("vvv ... for added tn: "+ tn.show());
        updatedAssetChunkSize : Int = nextAssets.saleUnitAssets.get_policy(mph).get(tn);
        expectedAssetCount : Int = if (isPrimary) {
            existingAssetChunkSize : Int = currentAssets.saleUnitAssets.get_policy(mph).get(tn);
            if (updatedAssetChunkSize < existingAssetChunkSize) {
                error("primary asset chunk size shouldn't decrease")
            };
            print("    ... each sale-unit has " + updatedAssetChunkSize.show());
            print("    ... sale now supplied with " + updatedAssetCount.show());
            print("    ... ^ / saleUnits  "+ nextAssets.totalSaleUnits.show());
            percentSupplied = 100.0 * updatedAssetCount / nextAssets.primaryAssetTargetCount;
            print("Now supplied with "+ percentSupplied.show() +"% of the primary token");
    
            // allows that the primary tokens can be progressively funded,
            // without disturbing the sale-unit chunk size for that primary token
            updatedAssetCount
        } else {            
            isEvenChunk : Bool = updatedAssetCount % nextAssets.totalSaleUnits == 0;
            print("got "+ updatedAssetCount.show());
            print("Expected chunks of "+ nextAssets.totalSaleUnits.show());
            if (!isEvenChunk) {
                error("new non-primary asset must have an even distribution for each unit of sale")
            };

            print("    ... each sale-unit has " + updatedAssetChunkSize.show());
            print("    ... ^ times sale-units  "+ nextAssets.totalSaleUnits.show());

            // non-primary tokens must have the sale-unit sync'd with the deposited value
            expected : Int = updatedAssetChunkSize * nextAssets.totalSaleUnits;
            print("Expecting the value to be = "+ expected.show() + " (= current Value/this-tn)");
            
            expected
        };
        // check that the deposited assets don't exceed the number of tokens implied by the saleUnitAssets * totalSaleUnits 
        print("    ... updated value has "+ updatedAssetCount.show() + " " + tn.show());
        hasMatchyValue : Bool = if (updatedAssetCount != expectedAssetCount) {
            if (isPrimary) {
                error("no way") // unreachable
            };
            error("The updated sale-units * sale-unit-count / this-tn must match the updated deposit-value / this-tn")
        } else { true };

        true
        && hasMatchyValue
        && currentState.mustBePending("old: AddTokens").trace("input sale must be Pending: ")
        && nextState.mustBePending("new:AddTokens").trace("updated sale must be Pending: ")
        && updated.validate()
        && updated.validateCreatedDetails()
        && updated.validatePendingDetails()
        && true
    }

    //! Validates updates to a MarketSale while it's in Pending state.
    //  This function enforces which fields may be updated and which must remain unchanged.
    func validateUpdatePendingSale(self, ddd : DgDataDetails) -> Bool {
        print("mktSale: validateUpdatePendingSale()");
        prevMktSale : MarketSaleData = MarketSaleData::from_data(
            ddd.inputData()
        );
        
        prevDetails = prevMktSale.v1details();
        nextDetails = self.v1details();
        
        prevState = prevDetails.saleState;
        nextState = nextDetails.saleState;
        prevFixed = prevDetails.fixedSaleDetails;
        nextFixed = nextDetails.fixedSaleDetails;
        prevAssets = prevDetails.saleAssets;
        nextAssets = nextDetails.saleAssets;
        prevThread = prevDetails.threadInfo;
        nextThread = nextDetails.threadInfo;
                
        // Core constraints
        bREQT("UTxO value MUST remain unchanged", 
            ddd.input().value == ddd.output().value,
            "UTxO value changed; delta= " + (ddd.output().value - ddd.input().value).show()
        );

        bREQT("previous sale MUST be in Pending state", prevState.mustBePending("old: UpdatingPendingSale").trace("input sale must be Pending: "));
        
        bREQT("saleState must be Pending unchanged (must stay Pending)", 
            prevDetails.saleState.switch { 
                Pending => nextDetails.mustBePending("UpdatingPendingSale: updated record"), 
                _ => false 
        });

        bREQT("threadInfo must remain unchanged", prevDetails.threadInfo == nextDetails.threadInfo);
        
        // Primary asset identity change logic
        primaryAssetChanged : Bool = (
            nextAssets.primaryAssetMph != prevAssets.primaryAssetMph
        ) || (
            nextAssets.primaryAssetName != prevAssets.primaryAssetName
        );
        
        if (primaryAssetChanged) {
            REQT("if primary asset changes, check if old primary asset tokens exist in previous UTxO");
            prevUtxoAssets : Assets = prevUtxoValue.get_assets() - ddd.uutValue();
            oldPrimaryAssetCount : Int = prevUtxoAssets
                .get_policy(prevAssets.primaryAssetMph)
                .get(prevAssets.primaryAssetName);
            
            hasOldPrimaryTokens : Bool = oldPrimaryAssetCount > 0;
            
            if (hasOldPrimaryTokens) {
                REQT("if old primary asset tokens exist, saleUnitAssets must continue to reference old primary");
                nextSaleUnitOldPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(prevAssets.primaryAssetMph)
                    .get(prevAssets.primaryAssetName);
                
                REQT("old primary asset quantity in saleUnitAssets must divide evenly by totalSaleUnits");
                assert(
                    oldPrimaryAssetCount % nextAssets.totalSaleUnits == 0,
                    "old primary asset quantity must divide evenly by totalSaleUnits"
                );
                
                expectedOldPrimaryPerUnit : Int = oldPrimaryAssetCount / nextAssets.totalSaleUnits;
                assert(
                    nextSaleUnitOldPrimary == expectedOldPrimaryPerUnit,
                    "saleUnitAssets must reference old primary asset with correct per-unit quantity"
                );
            } else {
                REQT("if no old primary asset tokens, saleUnitAssets must reference new primary and not old");
                nextSaleUnitOldPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(prevAssets.primaryAssetMph)
                    .get(prevAssets.primaryAssetName);
                
                assert(
                    nextSaleUnitOldPrimary == 0,
                    "saleUnitAssets must not reference old primary asset when no old tokens exist"
                );
                
                nextSaleUnitNewPrimary : Int = nextAssets.saleUnitAssets
                    .get_assets()
                    .get_policy(nextAssets.primaryAssetMph)
                    .get(nextAssets.primaryAssetName);
                
                assert(
                    nextSaleUnitNewPrimary > 0,
                    "saleUnitAssets must reference new primary asset"
                );
            }
        }
        
        // Primary asset target count consistency
        REQT("primaryAssetTargetCount must maintain consistency with totalSaleUnits and saleUnitAssets");
        nextPrimaryPerUnit : Int = nextAssets.saleUnitAssets
            .get_assets()
            .get_policy(nextAssets.primaryAssetMph)
            .get(nextAssets.primaryAssetName);
        expectedTargetCount : Int = nextAssets.totalSaleUnits * nextPrimaryPerUnit;
        assert(
            nextAssets.primaryAssetTargetCount == expectedTargetCount,
            "primaryAssetTargetCount must equal totalSaleUnits * saleUnitAssets[primary]"
        );
        
        // Validate VxfDestination fields
        REQT("validates VxfDestination in vxfTokensTo if Some");
        nextFixed.vxfTokensTo.switch {
            Some{vxf} => {
                assert(vxf.validate("vxfTokensTo"), "vxfTokensTo must be valid");
            },
            None => {
                print("  -- vxfTokensTo is None (allowed)");
            }
        }
        
        REQT("validates VxfDestination in vxfFundsTo if Some");
        nextFixed.vxfFundsTo.switch {
            Some{vxf} => {
                assert(vxf.validate("vxfFundsTo"), "vxfFundsTo must be valid");
            },
            None => {
                print("  -- vxfFundsTo is None (allowed for pending updates)");
            }
        }
        
        // Final validations
        REQT("validates updated record passes all general validations");
        assert(self.validate(), "updated record must pass general validation");
        
        REQT("validates updated record passes pending-specific validations");
        assert(self.validatePendingDetails(), "updated record must pass pending validations");
        
        REQT("validates settings");
        assert(
            nextFixed.settings.validateCreatedDetails(),
            "updated settings must pass validation"
        );
        
        REQT("validates progressDetails still matches startAt and totalSaleUnits");
        assert(
            nextState.progressDetails.validateCreatedDetails(
                nextFixed.startAt,
                nextAssets.totalSaleUnits
            ),
            "progressDetails must be consistent with startAt and totalSaleUnits"
        );
        
        true
    }
}