// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM
//   ... and keep checking in the changes as your on-chain types evolve.
//
// NOTE: this file is auto-generated; do not edit directly

import type { UplcData } from "@helios-lang/uplc";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    InlineTxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";
import type { Cast } from "@helios-lang/contract-utils";
import type { 
    IntLike,
    // BytesLike,
 } from "@helios-lang/codec-utils";

/**
 * @public
 */
export type TimeLike = IntLike;
 
        
import type {
    CapoHeliosBundle,
    CapoDelegateBundle,
    minimalData,
    HeliosScriptBundle,
    EnumTypeMeta,
    singleEnumVariantMeta,
    tagOnly,
    IntersectedEnum
} from "@donecollectively/stellar-contracts"


/**
 * A strong type for the canonical form of AnyData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoAnyData instead.
 * @public
 */
export interface AnyData {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
}


/**
 * An ergonomic, though less strictly-safe form of AnyData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the AnyDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoAnyData = AnyData/*like canon-other*/

/**
 * A strong type for the permissive form of AnyData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface AnyDataLike {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
}


/**
 * expresses the essential fields needed for initiating creation of a AnyData
 * @public
 */
export type minimalAnyData = minimalData<AnyDataLike>

/**
 * A strong type for the canonical form of DelegateDatum$Cip68RefToken
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateDatum$Ergo$Cip68RefToken instead.
 * @public
 */
export interface DelegateDatum$Cip68RefToken {
    cip68meta: AnyData  /*minVariantField*/ ,
    cip68version: bigint  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateDatum$Cip68RefToken
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateDatum$Cip68RefTokenLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateDatum$Ergo$Cip68RefToken = {
    cip68meta: ErgoAnyData  /*minVariantField*/ ,
    cip68version: bigint  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of DelegateDatum$Cip68RefToken
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateDatum$Cip68RefTokenLike {
    cip68meta: AnyDataLike  /*minVariantField*/ ,
    cip68version: IntLike  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of DelegationDetail
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoDelegationDetail instead.
 * @public
 */
export interface DelegationDetail {
    capoAddr: /*minStructField*/ Address
    mph: /*minStructField*/ MintingPolicyHash
    tn: /*minStructField*/ number[]
}


/**
 * An ergonomic, though less strictly-safe form of DelegationDetail
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegationDetailLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoDelegationDetail = DelegationDetail/*like canon-other*/

/**
 * A strong type for the permissive form of DelegationDetail
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegationDetailLike {
    capoAddr: /*minStructField*/ Address | string
    mph: /*minStructField*/ MintingPolicyHash | string | number[]
    tn: /*minStructField*/ number[]
}



/**
 * A strong type for the canonical form of SaleProgressDetailsV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoSaleProgressDetailsV1 instead.
 * @public
 */
export interface SaleProgressDetailsV1 {
    lastPurchaseAt: /*minStructField*/ number
    prevPurchaseAt: /*minStructField*/ number
    lotCount: /*minStructField*/ bigint
    lotsSold: /*minStructField*/ bigint
}


/**
 * An ergonomic, though less strictly-safe form of SaleProgressDetailsV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the SaleProgressDetailsV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoSaleProgressDetailsV1 = SaleProgressDetailsV1/*like canon-other*/

/**
 * A strong type for the permissive form of SaleProgressDetailsV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface SaleProgressDetailsV1Like {
    lastPurchaseAt: /*minStructField*/ TimeLike
    prevPurchaseAt: /*minStructField*/ TimeLike
    lotCount: /*minStructField*/ IntLike
    lotsSold: /*minStructField*/ IntLike
}




            /**
            * @internal
            */
            export type MarketSaleStateMeta = EnumTypeMeta<
    {module: "MarketSaleData", enumName: "MarketSaleState"}, {
        Pending: singleEnumVariantMeta<MarketSaleStateMeta, "Pending",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        Active: singleEnumVariantMeta<MarketSaleStateMeta, "Active",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        Retired: singleEnumVariantMeta<MarketSaleStateMeta, "Retired",
            "Constr#2", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        SoldOut: singleEnumVariantMeta<MarketSaleStateMeta, "SoldOut",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * MarketSaleState enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **4 variant(s)** of the MarketSaleState enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MarketSaleStateHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type MarketSaleState = 
        | { Pending: tagOnly /*minEnumVariant*/ }
        | { Active: tagOnly /*minEnumVariant*/ }
        | { Retired: tagOnly /*minEnumVariant*/ }
        | { SoldOut: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoMarketSaleState = IntersectedEnum<MarketSaleState/*like canon enum*/>

/**
 * MarketSaleState enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **4 variant(s)** of the MarketSaleState enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MarketSaleStateHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type MarketSaleStateLike = IntersectedEnum<
        | { Pending: tagOnly /*minEnumVariant*/ }
        | { Active: tagOnly /*minEnumVariant*/ }
        | { Retired: tagOnly /*minEnumVariant*/ }
        | { SoldOut: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of OtherSaleStateV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoOtherSaleStateV1 instead.
 * @public
 */
export interface OtherSaleStateV1 {
    progressDetails: /*minStructField*/ SaleProgressDetailsV1
    salePace: /*minStructField*/ number
    state: /*minStructField*/ MarketSaleState
}


/**
 * An ergonomic, though less strictly-safe form of OtherSaleStateV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the OtherSaleStateV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoOtherSaleStateV1 = {
    progressDetails: /*minStructField*/ ErgoSaleProgressDetailsV1
    salePace: /*minStructField*/ number
    state: /*minStructField*/ ErgoMarketSaleState
}


/**
 * A strong type for the permissive form of OtherSaleStateV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface OtherSaleStateV1Like {
    progressDetails: /*minStructField*/ SaleProgressDetailsV1Like
    salePace: /*minStructField*/ number
    state: /*minStructField*/ MarketSaleStateLike
}



/**
 * A strong type for the canonical form of DynamicSaleV1Settings
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoDynamicSaleV1Settings instead.
 * @public
 */
export interface DynamicSaleV1Settings {
    targetPrice: /*minStructField*/ number
    targetedSellingTime: /*minStructField*/ bigint
    minPrice: /*minStructField*/ number
    maxPrice: /*minStructField*/ number
    progressPricingDiscountFloorPoint: /*minStructField*/ number
    progressPricingDiscountWhenSlow: /*minStructField*/ number
    progressPricingExpansionWhenFast: /*minStructField*/ number
    dynaPaceFasterSaleWeight: /*minStructField*/ number
    dynaPaceIdleDecayRate: /*minStructField*/ number
    pricingWeightDynaPace: /*minStructField*/ number
}


/**
 * An ergonomic, though less strictly-safe form of DynamicSaleV1Settings
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DynamicSaleV1SettingsLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoDynamicSaleV1Settings = DynamicSaleV1Settings/*like canon-other*/

/**
 * A strong type for the permissive form of DynamicSaleV1Settings
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DynamicSaleV1SettingsLike {
    targetPrice: /*minStructField*/ number
    targetedSellingTime: /*minStructField*/ IntLike
    minPrice: /*minStructField*/ number
    maxPrice: /*minStructField*/ number
    progressPricingDiscountFloorPoint: /*minStructField*/ number
    progressPricingDiscountWhenSlow: /*minStructField*/ number
    progressPricingExpansionWhenFast: /*minStructField*/ number
    dynaPaceFasterSaleWeight: /*minStructField*/ number
    dynaPaceIdleDecayRate: /*minStructField*/ number
    pricingWeightDynaPace: /*minStructField*/ number
}



/**
 * A strong type for the canonical form of RelativeDelegateLink
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoRelativeDelegateLink instead.
 * @public
 */
export interface RelativeDelegateLink {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | undefined
    config: /*minStructField*/ number[]
}


/**
 * An ergonomic, though less strictly-safe form of RelativeDelegateLink
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the RelativeDelegateLinkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoRelativeDelegateLink = RelativeDelegateLink/*like canon-other*/

/**
 * A strong type for the permissive form of RelativeDelegateLink
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface RelativeDelegateLinkLike {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | string | number[] | undefined
    config: /*minStructField*/ number[]
}



/**
 * A strong type for the canonical form of VxfExpectedActivity$SpecificRedeemerId
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see VxfExpectedActivity$Ergo$SpecificRedeemerId instead.
 * @public
 */
export interface VxfExpectedActivity$SpecificRedeemerId {
    id: bigint  /*minVariantField*/ ,
    inNestedList: boolean  /*minVariantField*/ ,
    nestedListRedeemerId: bigint | undefined  /*minVariantField*/ ,
    appData: UplcData | undefined  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of VxfExpectedActivity$SpecificRedeemerId
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the VxfExpectedActivity$SpecificRedeemerIdLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type VxfExpectedActivity$Ergo$SpecificRedeemerId = VxfExpectedActivity$SpecificRedeemerId  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of VxfExpectedActivity$SpecificRedeemerId
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface VxfExpectedActivity$SpecificRedeemerIdLike {
    id: IntLike  /*minVariantField*/ ,
    inNestedList: boolean  /*minVariantField*/ ,
    nestedListRedeemerId: IntLike | undefined  /*minVariantField*/ ,
    appData: UplcData | undefined  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of VxfExpectedActivity$TaggedRedeemer
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see VxfExpectedActivity$Ergo$TaggedRedeemer instead.
 * @public
 */
export interface VxfExpectedActivity$TaggedRedeemer {
    firstFieldConstrTag: bigint  /*minVariantField*/ ,
    inNestedList: boolean  /*minVariantField*/ ,
    appData: UplcData | undefined  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of VxfExpectedActivity$TaggedRedeemer
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the VxfExpectedActivity$TaggedRedeemerLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type VxfExpectedActivity$Ergo$TaggedRedeemer = VxfExpectedActivity$TaggedRedeemer  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of VxfExpectedActivity$TaggedRedeemer
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface VxfExpectedActivity$TaggedRedeemerLike {
    firstFieldConstrTag: IntLike  /*minVariantField*/ ,
    inNestedList: boolean  /*minVariantField*/ ,
    appData: UplcData | undefined  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type VxfExpectedActivityMeta = EnumTypeMeta<
    {module: "VxfProtocol", enumName: "VxfExpectedActivity"}, {
        VxfTransfer: singleEnumVariantMeta<VxfExpectedActivityMeta, "VxfTransfer",
            "Constr#22104", "singletonField", /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined   , "noSpecialFlags"
        >,
        VxfStorage: singleEnumVariantMeta<VxfExpectedActivityMeta, "VxfStorage",
            "Constr#22106", "singletonField", /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined   , "noSpecialFlags"
        >,
        SpecificRedeemerId: singleEnumVariantMeta<VxfExpectedActivityMeta, "SpecificRedeemerId",
            "Constr#22107", 
            "fields", VxfExpectedActivity$SpecificRedeemerId, "noSpecialFlags"
        >,
        TaggedRedeemer: singleEnumVariantMeta<VxfExpectedActivityMeta, "TaggedRedeemer",
            "Constr#22108", 
            "fields", VxfExpectedActivity$TaggedRedeemer, "noSpecialFlags"
        >
    }
>;


/**
 * VxfExpectedActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **4 variant(s)** of the VxfExpectedActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `VxfExpectedActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type VxfExpectedActivity = 
        | { VxfTransfer: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { VxfStorage: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { SpecificRedeemerId: VxfExpectedActivity$SpecificRedeemerId /*minEnumVariant*/ }
        | { TaggedRedeemer: VxfExpectedActivity$TaggedRedeemer /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoVxfExpectedActivity = IntersectedEnum<
        | { VxfTransfer: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { VxfStorage: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { SpecificRedeemerId: VxfExpectedActivity$Ergo$SpecificRedeemerId /*minEnumVariant*/ }
        | { TaggedRedeemer: VxfExpectedActivity$Ergo$TaggedRedeemer /*minEnumVariant*/ }
>

/**
 * VxfExpectedActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **4 variant(s)** of the VxfExpectedActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `VxfExpectedActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type VxfExpectedActivityLike = IntersectedEnum<
        | { VxfTransfer: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { VxfStorage: /* implied wrapper { appData: ... } for singleVariantField */ 
			UplcData | undefined    /*minEnumVariant*/ }
        | { SpecificRedeemerId: VxfExpectedActivity$SpecificRedeemerIdLike /*minEnumVariant*/ }
        | { TaggedRedeemer: VxfExpectedActivity$TaggedRedeemerLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of VxfDestination$RelativeLink
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see VxfDestination$Ergo$RelativeLink instead.
 * @public
 */
export interface VxfDestination$RelativeLink {
    link: RelativeDelegateLink  /*minVariantField*/ ,
    vxfActivity: VxfExpectedActivity | undefined  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of VxfDestination$RelativeLink
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the VxfDestination$RelativeLinkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type VxfDestination$Ergo$RelativeLink = {
    link: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    vxfActivity: ErgoVxfExpectedActivity | undefined  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of VxfDestination$RelativeLink
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface VxfDestination$RelativeLinkLike {
    link: RelativeDelegateLinkLike  /*minVariantField*/ ,
    vxfActivity: VxfExpectedActivityLike | undefined  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of VxfDestination$AnyTokenHolder
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see VxfDestination$Ergo$AnyTokenHolder instead.
 * @public
 */
export interface VxfDestination$AnyTokenHolder {
    mph: MintingPolicyHash  /*minVariantField*/ ,
    assetName: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of VxfDestination$AnyTokenHolder
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the VxfDestination$AnyTokenHolderLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type VxfDestination$Ergo$AnyTokenHolder = VxfDestination$AnyTokenHolder  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of VxfDestination$AnyTokenHolder
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface VxfDestination$AnyTokenHolderLike {
    mph: MintingPolicyHash | string | number[]  /*minVariantField*/ ,
    assetName: number[]  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type VxfDestinationMeta = EnumTypeMeta<
    {module: "VxfProtocol", enumName: "VxfDestination"}, {
        RelativeLink: singleEnumVariantMeta<VxfDestinationMeta, "RelativeLink",
            "Constr#0", 
            "fields", VxfDestination$RelativeLink, "noSpecialFlags"
        >,
        AnyTokenHolder: singleEnumVariantMeta<VxfDestinationMeta, "AnyTokenHolder",
            "Constr#1", 
            "fields", VxfDestination$AnyTokenHolder, "noSpecialFlags"
        >,
        PubKey: singleEnumVariantMeta<VxfDestinationMeta, "PubKey",
            "Constr#2", "singletonField", /* implied wrapper { pkh: ... } for singleVariantField */ 
			PubKeyHash   , "noSpecialFlags"
        >,
        Anywhere: singleEnumVariantMeta<VxfDestinationMeta, "Anywhere",
            "Constr#98", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        NotYetDefined: singleEnumVariantMeta<VxfDestinationMeta, "NotYetDefined",
            "Constr#99", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * VxfDestination enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **5 variant(s)** of the VxfDestination enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `VxfDestinationHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type VxfDestination = 
        | { RelativeLink: VxfDestination$RelativeLink /*minEnumVariant*/ }
        | { AnyTokenHolder: VxfDestination$AnyTokenHolder /*minEnumVariant*/ }
        | { PubKey: /* implied wrapper { pkh: ... } for singleVariantField */ 
			PubKeyHash    /*minEnumVariant*/ }
        | { Anywhere: tagOnly /*minEnumVariant*/ }
        | { NotYetDefined: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoVxfDestination = IntersectedEnum<
        | { RelativeLink: VxfDestination$Ergo$RelativeLink /*minEnumVariant*/ }
        | { AnyTokenHolder: VxfDestination$Ergo$AnyTokenHolder /*minEnumVariant*/ }
        | { PubKey: /* implied wrapper { pkh: ... } for singleVariantField */ 
			PubKeyHash    /*minEnumVariant*/ }
        | { Anywhere: tagOnly /*minEnumVariant*/ }
        | { NotYetDefined: tagOnly /*minEnumVariant*/ }
>

/**
 * VxfDestination enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **5 variant(s)** of the VxfDestination enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `VxfDestinationHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type VxfDestinationLike = IntersectedEnum<
        | { RelativeLink: VxfDestination$RelativeLinkLike /*minEnumVariant*/ }
        | { AnyTokenHolder: VxfDestination$AnyTokenHolderLike /*minEnumVariant*/ }
        | { PubKey: /* implied wrapper { pkh: ... } for singleVariantField */ 
			PubKeyHash | string | number[]    /*minEnumVariant*/ }
        | { Anywhere: tagOnly /*minEnumVariant*/ }
        | { NotYetDefined: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of FixedSaleDetailsV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoFixedSaleDetailsV1 instead.
 * @public
 */
export interface FixedSaleDetailsV1 {
    settings: /*minStructField*/ DynamicSaleV1Settings
    startAt: /*minStructField*/ number
    vxfTokensTo: /*minStructField*/ VxfDestination | undefined
    vxfFundsTo: /*minStructField*/ VxfDestination | undefined
}


/**
 * An ergonomic, though less strictly-safe form of FixedSaleDetailsV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the FixedSaleDetailsV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoFixedSaleDetailsV1 = {
    settings: /*minStructField*/ ErgoDynamicSaleV1Settings
    startAt: /*minStructField*/ number
    vxfTokensTo: /*minStructField*/ ErgoVxfDestination | undefined
    vxfFundsTo: /*minStructField*/ ErgoVxfDestination | undefined
}


/**
 * A strong type for the permissive form of FixedSaleDetailsV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface FixedSaleDetailsV1Like {
    settings: /*minStructField*/ DynamicSaleV1SettingsLike
    startAt: /*minStructField*/ TimeLike
    vxfTokensTo: /*minStructField*/ VxfDestinationLike | undefined
    vxfFundsTo: /*minStructField*/ VxfDestinationLike | undefined
}



/**
 * A strong type for the canonical form of SaleAssetsV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoSaleAssetsV1 instead.
 * @public
 */
export interface SaleAssetsV1 {
    saleUnitAssets: /*minStructField*/ Value
    singleBuyMaxUnits: /*minStructField*/ bigint
    primaryAssetMph: /*minStructField*/ MintingPolicyHash
    primaryAssetName: /*minStructField*/ number[]
    primaryAssetTargetCount: /*minStructField*/ bigint
    totalSaleLots: /*minStructField*/ bigint
}


/**
 * An ergonomic, though less strictly-safe form of SaleAssetsV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the SaleAssetsV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoSaleAssetsV1 = SaleAssetsV1/*like canon-other*/

/**
 * A strong type for the permissive form of SaleAssetsV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface SaleAssetsV1Like {
    saleUnitAssets: /*minStructField*/ Value | [MintingPolicyHash | string | number[], [number[] | string, IntLike][]][] | {mph: MintingPolicyHash | string | number[], tokens: {name: number[] | string, qty: IntLike}[]}[]
    singleBuyMaxUnits: /*minStructField*/ IntLike
    primaryAssetMph: /*minStructField*/ MintingPolicyHash | string | number[]
    primaryAssetName: /*minStructField*/ number[]
    primaryAssetTargetCount: /*minStructField*/ IntLike
    totalSaleLots: /*minStructField*/ IntLike
}



/**
 * A strong type for the canonical form of ThreadInfoV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoThreadInfoV1 instead.
 * @public
 */
export interface ThreadInfoV1 {
    nestedThreads: /*minStructField*/ bigint
    retiredThreads: /*minStructField*/ bigint
    parentChunkId: /*minStructField*/ number[]
    chunkForkedAt: /*minStructField*/ number
    saleId: /*minStructField*/ number[]
}


/**
 * An ergonomic, though less strictly-safe form of ThreadInfoV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ThreadInfoV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoThreadInfoV1 = ThreadInfoV1/*like canon-other*/

/**
 * A strong type for the permissive form of ThreadInfoV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ThreadInfoV1Like {
    nestedThreads: /*minStructField*/ IntLike
    retiredThreads: /*minStructField*/ IntLike
    parentChunkId: /*minStructField*/ number[]
    chunkForkedAt: /*minStructField*/ TimeLike
    saleId: /*minStructField*/ number[]
}



/**
 * A strong type for the canonical form of MktSaleDetails$V1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see MktSaleDetails$Ergo$V1 instead.
 * @public
 */
export interface MktSaleDetails$V1 {
    saleState: OtherSaleStateV1  /*minVariantField*/ ,
    fixedSaleDetails: FixedSaleDetailsV1  /*minVariantField*/ ,
    saleAssets: SaleAssetsV1  /*minVariantField*/ ,
    threadInfo: ThreadInfoV1  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of MktSaleDetails$V1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the MktSaleDetails$V1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type MktSaleDetails$Ergo$V1 = {
    saleState: ErgoOtherSaleStateV1  /*minVariantField*/ ,
    fixedSaleDetails: ErgoFixedSaleDetailsV1  /*minVariantField*/ ,
    saleAssets: ErgoSaleAssetsV1  /*minVariantField*/ ,
    threadInfo: ErgoThreadInfoV1  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of MktSaleDetails$V1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface MktSaleDetails$V1Like {
    saleState: OtherSaleStateV1Like  /*minVariantField*/ ,
    fixedSaleDetails: FixedSaleDetailsV1Like  /*minVariantField*/ ,
    saleAssets: SaleAssetsV1Like  /*minVariantField*/ ,
    threadInfo: ThreadInfoV1Like  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type MktSaleDetailsMeta = EnumTypeMeta<
    {module: "MarketSaleData", enumName: "MktSaleDetails"}, {
        V1: singleEnumVariantMeta<MktSaleDetailsMeta, "V1",
            "Constr#4000", 
            "fields", MktSaleDetails$V1, "noSpecialFlags"
        >
    }
>;


/**
 * MktSaleDetails enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **1 variant(s)** of the MktSaleDetails enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MktSaleDetailsHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type MktSaleDetails = 
        | { V1: MktSaleDetails$V1 /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoMktSaleDetails = IntersectedEnum<
        | { V1: MktSaleDetails$Ergo$V1 /*minEnumVariant*/ }
>

/**
 * MktSaleDetails enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **1 variant(s)** of the MktSaleDetails enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MktSaleDetailsHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type MktSaleDetailsLike = IntersectedEnum<
        | { V1: MktSaleDetails$V1Like /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of MarketSaleData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoMarketSaleData instead.
 * @public
 */
export interface MarketSaleData {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    name: /*minStructField*/ string
    details: /*minStructField*/ MktSaleDetails
}


/**
 * An ergonomic, though less strictly-safe form of MarketSaleData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the MarketSaleDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoMarketSaleData = {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    name: /*minStructField*/ string
    details: /*minStructField*/ ErgoMktSaleDetails
}


/**
 * A strong type for the permissive form of MarketSaleData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface MarketSaleDataLike {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    name: /*minStructField*/ string
    details: /*minStructField*/ MktSaleDetailsLike
}


/**
 * expresses the essential fields needed for initiating creation of a MarketSaleData
 * @public
 */
export type minimalMarketSaleData = minimalData<MarketSaleDataLike>

/**
 * A strong type for the canonical form of DelegateDatum$capoStoredData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateDatum$Ergo$capoStoredData instead.
 * @public
 */
export interface DelegateDatum$capoStoredData {
    data: MarketSaleData  /*minVariantField*/ ,
    version: bigint  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateDatum$capoStoredData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateDatum$capoStoredDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateDatum$Ergo$capoStoredData = {
    data: ErgoMarketSaleData  /*minVariantField*/ ,
    version: bigint  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of DelegateDatum$capoStoredData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateDatum$capoStoredDataLike {
    data: MarketSaleDataLike  /*minVariantField*/ ,
    version: IntLike  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type DelegateDatumMeta = EnumTypeMeta<
    {module: "MarketSalePolicy", enumName: "DelegateDatum"}, {
        Cip68RefToken: singleEnumVariantMeta<DelegateDatumMeta, "Cip68RefToken",
            "Constr#0", 
            "fields", DelegateDatum$Cip68RefToken, "noSpecialFlags"
        >,
        IsDelegation: singleEnumVariantMeta<DelegateDatumMeta, "IsDelegation",
            "Constr#1", "singletonField", /* implied wrapper { dd: ... } for singleVariantField */ 
			DelegationDetail   , "noSpecialFlags"
        >,
        capoStoredData: singleEnumVariantMeta<DelegateDatumMeta, "capoStoredData",
            "Constr#2", 
            "fields", DelegateDatum$capoStoredData, "noSpecialFlags"
        >
    }
>;


/**
 * DelegateDatum enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the DelegateDatum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateDatumHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type DelegateDatum = 
        | { Cip68RefToken: DelegateDatum$Cip68RefToken /*minEnumVariant*/ }
        | { IsDelegation: /* implied wrapper { dd: ... } for singleVariantField */ 
			DelegationDetail    /*minEnumVariant*/ }
        | { capoStoredData: DelegateDatum$capoStoredData /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoDelegateDatum = IntersectedEnum<
        | { Cip68RefToken: DelegateDatum$Ergo$Cip68RefToken /*minEnumVariant*/ }
        | { IsDelegation: /* implied wrapper { dd: ... } for singleVariantField */ 
			ErgoDelegationDetail    /*minEnumVariant*/ }
        | { capoStoredData: DelegateDatum$Ergo$capoStoredData /*minEnumVariant*/ }
>

/**
 * DelegateDatum enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the DelegateDatum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateDatumHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type DelegateDatumLike = IntersectedEnum<
        | { Cip68RefToken: DelegateDatum$Cip68RefTokenLike /*minEnumVariant*/ }
        | { IsDelegation: /* implied wrapper { dd: ... } for singleVariantField */ 
			DelegationDetailLike    /*minEnumVariant*/ }
        | { capoStoredData: DelegateDatum$capoStoredDataLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$CreatingDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$CreatingDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$CreatingDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$CreatingDelegate = CapoLifecycleActivity$CreatingDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$CreatingDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type DelegateRoleMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "DelegateRole"}, {
        MintDgt: singleEnumVariantMeta<DelegateRoleMeta, "MintDgt",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        SpendDgt: singleEnumVariantMeta<DelegateRoleMeta, "SpendDgt",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        MintInvariant: singleEnumVariantMeta<DelegateRoleMeta, "MintInvariant",
            "Constr#2", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        SpendInvariant: singleEnumVariantMeta<DelegateRoleMeta, "SpendInvariant",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        DgDataPolicy: singleEnumVariantMeta<DelegateRoleMeta, "DgDataPolicy",
            "Constr#4", "singletonField", /* implied wrapper { name: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        OtherNamedDgt: singleEnumVariantMeta<DelegateRoleMeta, "OtherNamedDgt",
            "Constr#5", "singletonField", /* implied wrapper { name: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        BothMintAndSpendDgt: singleEnumVariantMeta<DelegateRoleMeta, "BothMintAndSpendDgt",
            "Constr#6", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        HandledByCapoOnly: singleEnumVariantMeta<DelegateRoleMeta, "HandledByCapoOnly",
            "Constr#7", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * DelegateRole enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **8 variant(s)** of the DelegateRole enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateRoleHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type DelegateRole = 
        | { MintDgt: tagOnly /*minEnumVariant*/ }
        | { SpendDgt: tagOnly /*minEnumVariant*/ }
        | { MintInvariant: tagOnly /*minEnumVariant*/ }
        | { SpendInvariant: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { OtherNamedDgt: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { BothMintAndSpendDgt: tagOnly /*minEnumVariant*/ }
        | { HandledByCapoOnly: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoDelegateRole = IntersectedEnum<DelegateRole/*like canon enum*/>

/**
 * DelegateRole enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **8 variant(s)** of the DelegateRole enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateRoleHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type DelegateRoleLike = IntersectedEnum<
        | { MintDgt: tagOnly /*minEnumVariant*/ }
        | { SpendDgt: tagOnly /*minEnumVariant*/ }
        | { MintInvariant: tagOnly /*minEnumVariant*/ }
        | { SpendInvariant: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { OtherNamedDgt: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { BothMintAndSpendDgt: tagOnly /*minEnumVariant*/ }
        | { HandledByCapoOnly: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$forcingNewSpendDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$forcingNewSpendDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$forcingNewSpendDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$forcingNewSpendDelegate = CapoLifecycleActivity$forcingNewSpendDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$forcingNewSpendDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$forcingNewMintDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$forcingNewMintDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$forcingNewMintDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$forcingNewMintDelegate = CapoLifecycleActivity$forcingNewMintDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$forcingNewMintDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$updatingEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$updatingEntry instead.
 * @public
 */
export interface ManifestActivity$updatingEntry {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$updatingEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$updatingEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$updatingEntry = ManifestActivity$updatingEntry  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$updatingEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$updatingEntryLike {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$addingEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$addingEntry instead.
 * @public
 */
export interface ManifestActivity$addingEntry {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$addingEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$addingEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$addingEntry = ManifestActivity$addingEntry  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$addingEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$addingEntryLike {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$forkingThreadToken
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$forkingThreadToken instead.
 * @public
 */
export interface ManifestActivity$forkingThreadToken {
    key: string  /*minVariantField*/ ,
    newThreadCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$forkingThreadToken
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$forkingThreadTokenLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$forkingThreadToken = ManifestActivity$forkingThreadToken  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$forkingThreadToken
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$forkingThreadTokenLike {
    key: string  /*minVariantField*/ ,
    newThreadCount: IntLike  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$burningThreadToken
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$burningThreadToken instead.
 * @public
 */
export interface ManifestActivity$burningThreadToken {
    key: string  /*minVariantField*/ ,
    burnedThreadCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$burningThreadToken
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$burningThreadTokenLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$burningThreadToken = ManifestActivity$burningThreadToken  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$burningThreadToken
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$burningThreadTokenLike {
    key: string  /*minVariantField*/ ,
    burnedThreadCount: IntLike  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type ManifestActivityMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "ManifestActivity"}, {
        retiringEntry: singleEnumVariantMeta<ManifestActivityMeta, "retiringEntry",
            "Constr#0", "singletonField", /* implied wrapper { key: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        updatingEntry: singleEnumVariantMeta<ManifestActivityMeta, "updatingEntry",
            "Constr#1", 
            "fields", ManifestActivity$updatingEntry, "noSpecialFlags"
        >,
        addingEntry: singleEnumVariantMeta<ManifestActivityMeta, "addingEntry",
            "Constr#2", 
            "fields", ManifestActivity$addingEntry, "noSpecialFlags"
        >,
        forkingThreadToken: singleEnumVariantMeta<ManifestActivityMeta, "forkingThreadToken",
            "Constr#3", 
            "fields", ManifestActivity$forkingThreadToken, "noSpecialFlags"
        >,
        burningThreadToken: singleEnumVariantMeta<ManifestActivityMeta, "burningThreadToken",
            "Constr#4", 
            "fields", ManifestActivity$burningThreadToken, "noSpecialFlags"
        >
    }
>;


/**
 * ManifestActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **5 variant(s)** of the ManifestActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type ManifestActivity = 
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$updatingEntry /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$addingEntry /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$forkingThreadToken /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$burningThreadToken /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoManifestActivity = IntersectedEnum<
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$Ergo$updatingEntry /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$Ergo$addingEntry /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$Ergo$forkingThreadToken /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$Ergo$burningThreadToken /*minEnumVariant*/ }
>

/**
 * ManifestActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **5 variant(s)** of the ManifestActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type ManifestActivityLike = IntersectedEnum<
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$updatingEntryLike /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$addingEntryLike /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$forkingThreadTokenLike /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$burningThreadTokenLike /*minEnumVariant*/ }
>


            /**
            * @internal
            */
            export type CapoLifecycleActivityMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "CapoLifecycleActivity"}, {
        CreatingDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "CreatingDelegate",
            "Constr#0", 
            "fields", CapoLifecycleActivity$CreatingDelegate, "isSeededActivity"
        >,
        queuePendingChange: singleEnumVariantMeta<CapoLifecycleActivityMeta, "queuePendingChange",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        removePendingChange: singleEnumVariantMeta<CapoLifecycleActivityMeta, "removePendingChange",
            "Constr#2", "singletonField", /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRole   , "noSpecialFlags"
        >,
        commitPendingChanges: singleEnumVariantMeta<CapoLifecycleActivityMeta, "commitPendingChanges",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        forcingNewSpendDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "forcingNewSpendDelegate",
            "Constr#4", 
            "fields", CapoLifecycleActivity$forcingNewSpendDelegate, "isSeededActivity"
        >,
        forcingNewMintDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "forcingNewMintDelegate",
            "Constr#5", 
            "fields", CapoLifecycleActivity$forcingNewMintDelegate, "isSeededActivity"
        >,
        updatingManifest: singleEnumVariantMeta<CapoLifecycleActivityMeta, "updatingManifest",
            "Constr#6", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivity   , "noSpecialFlags"
        >
    }
>;


/**
 * CapoLifecycleActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **7 variant(s)** of the CapoLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type CapoLifecycleActivity = 
        | { CreatingDelegate: CapoLifecycleActivity$CreatingDelegate /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRole    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$forcingNewSpendDelegate /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$forcingNewMintDelegate /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivity    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoCapoLifecycleActivity = IntersectedEnum<
        | { CreatingDelegate: CapoLifecycleActivity$Ergo$CreatingDelegate /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			ErgoDelegateRole    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$Ergo$forcingNewSpendDelegate /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$Ergo$forcingNewMintDelegate /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoManifestActivity    /*minEnumVariant*/ }
>

/**
 * CapoLifecycleActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **7 variant(s)** of the CapoLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type CapoLifecycleActivityLike = IntersectedEnum<
        | { CreatingDelegate: CapoLifecycleActivity$CreatingDelegateLike /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRoleLike    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$forcingNewSpendDelegateLike /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$forcingNewMintDelegateLike /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivityLike    /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of DelegateLifecycleActivity$ReplacingMe
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateLifecycleActivity$Ergo$ReplacingMe instead.
 * @public
 */
export interface DelegateLifecycleActivity$ReplacingMe {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateLifecycleActivity$ReplacingMe
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateLifecycleActivity$ReplacingMeLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateLifecycleActivity$Ergo$ReplacingMe = DelegateLifecycleActivity$ReplacingMe  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of DelegateLifecycleActivity$ReplacingMe
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateLifecycleActivity$ReplacingMeLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type DelegateLifecycleActivityMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "DelegateLifecycleActivity"}, {
        ReplacingMe: singleEnumVariantMeta<DelegateLifecycleActivityMeta, "ReplacingMe",
            "Constr#0", 
            "fields", DelegateLifecycleActivity$ReplacingMe, "isSeededActivity"
        >,
        Retiring: singleEnumVariantMeta<DelegateLifecycleActivityMeta, "Retiring",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        ValidatingSettings: singleEnumVariantMeta<DelegateLifecycleActivityMeta, "ValidatingSettings",
            "Constr#2", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * DelegateLifecycleActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the DelegateLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type DelegateLifecycleActivity = 
        | { ReplacingMe: DelegateLifecycleActivity$ReplacingMe /*minEnumVariant*/ }
        | { Retiring: tagOnly /*minEnumVariant*/ }
        | { ValidatingSettings: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoDelegateLifecycleActivity = IntersectedEnum<
        | { ReplacingMe: DelegateLifecycleActivity$Ergo$ReplacingMe /*minEnumVariant*/ }
        | { Retiring: tagOnly /*minEnumVariant*/ }
        | { ValidatingSettings: tagOnly /*minEnumVariant*/ }
>

/**
 * DelegateLifecycleActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the DelegateLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type DelegateLifecycleActivityLike = IntersectedEnum<
        | { ReplacingMe: DelegateLifecycleActivity$ReplacingMeLike /*minEnumVariant*/ }
        | { Retiring: tagOnly /*minEnumVariant*/ }
        | { ValidatingSettings: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of SpendingActivity$AddingToSale
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see SpendingActivity$Ergo$AddingToSale instead.
 * @public
 */
export interface SpendingActivity$AddingToSale {
    id: number[]  /*minVariantField*/ ,
    mph: MintingPolicyHash  /*minVariantField*/ ,
    tn: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of SpendingActivity$AddingToSale
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the SpendingActivity$AddingToSaleLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type SpendingActivity$Ergo$AddingToSale = SpendingActivity$AddingToSale  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of SpendingActivity$AddingToSale
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface SpendingActivity$AddingToSaleLike {
    id: number[]  /*minVariantField*/ ,
    mph: MintingPolicyHash | string | number[]  /*minVariantField*/ ,
    tn: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of SpendingActivity$SellingTokens
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see SpendingActivity$Ergo$SellingTokens instead.
 * @public
 */
export interface SpendingActivity$SellingTokens {
    id: number[]  /*minVariantField*/ ,
    sellingUnitQuantity: bigint  /*minVariantField*/ ,
    salePrice: Value  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of SpendingActivity$SellingTokens
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the SpendingActivity$SellingTokensLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type SpendingActivity$Ergo$SellingTokens = SpendingActivity$SellingTokens  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of SpendingActivity$SellingTokens
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface SpendingActivity$SellingTokensLike {
    id: number[]  /*minVariantField*/ ,
    sellingUnitQuantity: IntLike  /*minVariantField*/ ,
    salePrice: Value | [MintingPolicyHash | string | number[], [number[] | string, IntLike][]][] | {mph: MintingPolicyHash | string | number[], tokens: {name: number[] | string, qty: IntLike}[]}[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of SpendingActivity$MergingChildChunk
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see SpendingActivity$Ergo$MergingChildChunk instead.
 * @public
 */
export interface SpendingActivity$MergingChildChunk {
    id: number[]  /*minVariantField*/ ,
    childChunkId: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of SpendingActivity$MergingChildChunk
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the SpendingActivity$MergingChildChunkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type SpendingActivity$Ergo$MergingChildChunk = SpendingActivity$MergingChildChunk  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of SpendingActivity$MergingChildChunk
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface SpendingActivity$MergingChildChunkLike {
    id: number[]  /*minVariantField*/ ,
    childChunkId: string  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type SpendingActivityMeta = EnumTypeMeta<
    {module: "MarketSalePolicy", enumName: "SpendingActivity"}, {
        UpdatingRecord: singleEnumVariantMeta<SpendingActivityMeta, "UpdatingRecord",
            "Constr#0", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			number[]   , "noSpecialFlags"
        >,
        AddingToSale: singleEnumVariantMeta<SpendingActivityMeta, "AddingToSale",
            "Constr#1", 
            "fields", SpendingActivity$AddingToSale, "noSpecialFlags"
        >,
        UpdatingPendingSale: singleEnumVariantMeta<SpendingActivityMeta, "UpdatingPendingSale",
            "Constr#2", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			number[]   , "noSpecialFlags"
        >,
        Activating: singleEnumVariantMeta<SpendingActivityMeta, "Activating",
            "Constr#3", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			number[]   , "noSpecialFlags"
        >,
        SellingTokens: singleEnumVariantMeta<SpendingActivityMeta, "SellingTokens",
            "Constr#4", 
            "fields", SpendingActivity$SellingTokens, "noSpecialFlags"
        >,
        MergingChildChunk: singleEnumVariantMeta<SpendingActivityMeta, "MergingChildChunk",
            "Constr#5", 
            "fields", SpendingActivity$MergingChildChunk, "noSpecialFlags"
        >,
        Retiring: singleEnumVariantMeta<SpendingActivityMeta, "Retiring",
            "Constr#6", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			number[]   , "noSpecialFlags"
        >
    }
>;


/**
 * SpendingActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **7 variant(s)** of the SpendingActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `SpendingActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type SpendingActivity = 
        | { UpdatingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { AddingToSale: SpendingActivity$AddingToSale /*minEnumVariant*/ }
        | { UpdatingPendingSale: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { Activating: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { SellingTokens: SpendingActivity$SellingTokens /*minEnumVariant*/ }
        | { MergingChildChunk: SpendingActivity$MergingChildChunk /*minEnumVariant*/ }
        | { Retiring: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoSpendingActivity = IntersectedEnum<
        | { UpdatingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { AddingToSale: SpendingActivity$Ergo$AddingToSale /*minEnumVariant*/ }
        | { UpdatingPendingSale: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { Activating: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { SellingTokens: SpendingActivity$Ergo$SellingTokens /*minEnumVariant*/ }
        | { MergingChildChunk: SpendingActivity$Ergo$MergingChildChunk /*minEnumVariant*/ }
        | { Retiring: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
>

/**
 * SpendingActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **7 variant(s)** of the SpendingActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `SpendingActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type SpendingActivityLike = IntersectedEnum<
        | { UpdatingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { AddingToSale: SpendingActivity$AddingToSaleLike /*minEnumVariant*/ }
        | { UpdatingPendingSale: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { Activating: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { SellingTokens: SpendingActivity$SellingTokensLike /*minEnumVariant*/ }
        | { MergingChildChunk: SpendingActivity$MergingChildChunkLike /*minEnumVariant*/ }
        | { Retiring: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of MintingActivity$SplittingSaleChunkAndBuying
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see MintingActivity$Ergo$SplittingSaleChunkAndBuying instead.
 * @public
 */
export interface MintingActivity$SplittingSaleChunkAndBuying {
    seed: TxOutputId  /*minVariantField*/ ,
    parentChunkId: string  /*minVariantField*/ ,
    buyingUnitQuantity: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of MintingActivity$SplittingSaleChunkAndBuying
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the MintingActivity$SplittingSaleChunkAndBuyingLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type MintingActivity$Ergo$SplittingSaleChunkAndBuying = MintingActivity$SplittingSaleChunkAndBuying  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of MintingActivity$SplittingSaleChunkAndBuying
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface MintingActivity$SplittingSaleChunkAndBuyingLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    parentChunkId: string  /*minVariantField*/ ,
    buyingUnitQuantity: IntLike  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type MintingActivityMeta = EnumTypeMeta<
    {module: "MarketSalePolicy", enumName: "MintingActivity"}, {
        CreatingRecord: singleEnumVariantMeta<MintingActivityMeta, "CreatingRecord",
            "Constr#0", "singletonField", /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId   , "isSeededActivity"
        >,
        SplittingSaleChunkAndBuying: singleEnumVariantMeta<MintingActivityMeta, "SplittingSaleChunkAndBuying",
            "Constr#1", 
            "fields", MintingActivity$SplittingSaleChunkAndBuying, "isSeededActivity"
        >
    }
>;


/**
 * MintingActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **2 variant(s)** of the MintingActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MintingActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type MintingActivity = 
        | { CreatingRecord: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { SplittingSaleChunkAndBuying: MintingActivity$SplittingSaleChunkAndBuying /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoMintingActivity = IntersectedEnum<
        | { CreatingRecord: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { SplittingSaleChunkAndBuying: MintingActivity$Ergo$SplittingSaleChunkAndBuying /*minEnumVariant*/ }
>

/**
 * MintingActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **2 variant(s)** of the MintingActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MintingActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type MintingActivityLike = IntersectedEnum<
        | { CreatingRecord: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId | string    /*minEnumVariant*/ }
        | { SplittingSaleChunkAndBuying: MintingActivity$SplittingSaleChunkAndBuyingLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of BurningActivity$JoiningWithParentChunk
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see BurningActivity$Ergo$JoiningWithParentChunk instead.
 * @public
 */
export interface BurningActivity$JoiningWithParentChunk {
    id: string  /*minVariantField*/ ,
    parentChunkId: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of BurningActivity$JoiningWithParentChunk
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the BurningActivity$JoiningWithParentChunkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type BurningActivity$Ergo$JoiningWithParentChunk = BurningActivity$JoiningWithParentChunk  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of BurningActivity$JoiningWithParentChunk
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface BurningActivity$JoiningWithParentChunkLike {
    id: string  /*minVariantField*/ ,
    parentChunkId: string  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type BurningActivityMeta = EnumTypeMeta<
    {module: "MarketSalePolicy", enumName: "BurningActivity"}, {
        DeletingRecord: singleEnumVariantMeta<BurningActivityMeta, "DeletingRecord",
            "Constr#0", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			number[]   , "noSpecialFlags"
        >,
        JoiningWithParentChunk: singleEnumVariantMeta<BurningActivityMeta, "JoiningWithParentChunk",
            "Constr#1", 
            "fields", BurningActivity$JoiningWithParentChunk, "noSpecialFlags"
        >,
        CleanupRetired: singleEnumVariantMeta<BurningActivityMeta, "CleanupRetired",
            "Constr#2", "singletonField", /* implied wrapper { id: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >
    }
>;


/**
 * BurningActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the BurningActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `BurningActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type BurningActivity = 
        | { DeletingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { JoiningWithParentChunk: BurningActivity$JoiningWithParentChunk /*minEnumVariant*/ }
        | { CleanupRetired: /* implied wrapper { id: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoBurningActivity = IntersectedEnum<
        | { DeletingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { JoiningWithParentChunk: BurningActivity$Ergo$JoiningWithParentChunk /*minEnumVariant*/ }
        | { CleanupRetired: /* implied wrapper { id: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
>

/**
 * BurningActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the BurningActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `BurningActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type BurningActivityLike = IntersectedEnum<
        | { DeletingRecord: /* implied wrapper { id: ... } for singleVariantField */ 
			number[]    /*minEnumVariant*/ }
        | { JoiningWithParentChunk: BurningActivity$JoiningWithParentChunkLike /*minEnumVariant*/ }
        | { CleanupRetired: /* implied wrapper { id: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of DelegateActivity$CreatingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateActivity$Ergo$CreatingDelegatedData instead.
 * @public
 */
export interface DelegateActivity$CreatingDelegatedData {
    seed: TxOutputId  /*minVariantField*/ ,
    dataType: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateActivity$CreatingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateActivity$CreatingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateActivity$Ergo$CreatingDelegatedData = DelegateActivity$CreatingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of DelegateActivity$CreatingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateActivity$CreatingDelegatedDataLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    dataType: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of DelegateActivity$UpdatingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateActivity$Ergo$UpdatingDelegatedData instead.
 * @public
 */
export interface DelegateActivity$UpdatingDelegatedData {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateActivity$UpdatingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateActivity$UpdatingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateActivity$Ergo$UpdatingDelegatedData = DelegateActivity$UpdatingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of DelegateActivity$UpdatingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateActivity$UpdatingDelegatedDataLike {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of DelegateActivity$DeletingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see DelegateActivity$Ergo$DeletingDelegatedData instead.
 * @public
 */
export interface DelegateActivity$DeletingDelegatedData {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of DelegateActivity$DeletingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DelegateActivity$DeletingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type DelegateActivity$Ergo$DeletingDelegatedData = DelegateActivity$DeletingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of DelegateActivity$DeletingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DelegateActivity$DeletingDelegatedDataLike {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type DelegateActivityMeta = EnumTypeMeta<
    {module: "MarketSalePolicy", enumName: "DelegateActivity"}, {
        CapoLifecycleActivities: singleEnumVariantMeta<DelegateActivityMeta, "CapoLifecycleActivities",
            "Constr#0", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity   , "noSpecialFlags"
        >,
        DelegateLifecycleActivities: singleEnumVariantMeta<DelegateActivityMeta, "DelegateLifecycleActivities",
            "Constr#1", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivity   , "noSpecialFlags"
        >,
        SpendingActivities: singleEnumVariantMeta<DelegateActivityMeta, "SpendingActivities",
            "Constr#2", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			SpendingActivity   , "noSpecialFlags"
        >,
        MintingActivities: singleEnumVariantMeta<DelegateActivityMeta, "MintingActivities",
            "Constr#3", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			MintingActivity   , "noSpecialFlags"
        >,
        BurningActivities: singleEnumVariantMeta<DelegateActivityMeta, "BurningActivities",
            "Constr#4", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			BurningActivity   , "noSpecialFlags"
        >,
        CreatingDelegatedData: singleEnumVariantMeta<DelegateActivityMeta, "CreatingDelegatedData",
            "Constr#5", 
            "fields", DelegateActivity$CreatingDelegatedData, "isSeededActivity"
        >,
        UpdatingDelegatedData: singleEnumVariantMeta<DelegateActivityMeta, "UpdatingDelegatedData",
            "Constr#6", 
            "fields", DelegateActivity$UpdatingDelegatedData, "noSpecialFlags"
        >,
        DeletingDelegatedData: singleEnumVariantMeta<DelegateActivityMeta, "DeletingDelegatedData",
            "Constr#7", 
            "fields", DelegateActivity$DeletingDelegatedData, "noSpecialFlags"
        >,
        MultipleDelegateActivities: singleEnumVariantMeta<DelegateActivityMeta, "MultipleDelegateActivities",
            "Constr#8", "singletonField", /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>   , "noSpecialFlags"
        >,
        OtherActivities: singleEnumVariantMeta<DelegateActivityMeta, "OtherActivities",
            "Constr#9", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData   , "noSpecialFlags"
        >
    }
>;


/**
 * DelegateActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **10 variant(s)** of the DelegateActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type DelegateActivity = 
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivity    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			SpendingActivity    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			MintingActivity    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			BurningActivity    /*minEnumVariant*/ }
        | { CreatingDelegatedData: DelegateActivity$CreatingDelegatedData /*minEnumVariant*/ }
        | { UpdatingDelegatedData: DelegateActivity$UpdatingDelegatedData /*minEnumVariant*/ }
        | { DeletingDelegatedData: DelegateActivity$DeletingDelegatedData /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoDelegateActivity = IntersectedEnum<
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoCapoLifecycleActivity    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoDelegateLifecycleActivity    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoSpendingActivity    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoMintingActivity    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoBurningActivity    /*minEnumVariant*/ }
        | { CreatingDelegatedData: DelegateActivity$Ergo$CreatingDelegatedData /*minEnumVariant*/ }
        | { UpdatingDelegatedData: DelegateActivity$Ergo$UpdatingDelegatedData /*minEnumVariant*/ }
        | { DeletingDelegatedData: DelegateActivity$Ergo$DeletingDelegatedData /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
>

/**
 * DelegateActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **10 variant(s)** of the DelegateActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type DelegateActivityLike = IntersectedEnum<
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivityLike    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivityLike    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			SpendingActivityLike    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			MintingActivityLike    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			BurningActivityLike    /*minEnumVariant*/ }
        | { CreatingDelegatedData: DelegateActivity$CreatingDelegatedDataLike /*minEnumVariant*/ }
        | { UpdatingDelegatedData: DelegateActivity$UpdatingDelegatedDataLike /*minEnumVariant*/ }
        | { DeletingDelegatedData: DelegateActivity$DeletingDelegatedDataLike /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of PendingDelegateAction$Add
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingDelegateAction$Ergo$Add instead.
 * @public
 */
export interface PendingDelegateAction$Add {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateAction$Add
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateAction$AddLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingDelegateAction$Ergo$Add = PendingDelegateAction$Add  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of PendingDelegateAction$Add
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateAction$AddLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of PendingDelegateAction$Replace
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingDelegateAction$Ergo$Replace instead.
 * @public
 */
export interface PendingDelegateAction$Replace {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    replacesDgt: AssetClass  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateAction$Replace
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateAction$ReplaceLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingDelegateAction$Ergo$Replace = PendingDelegateAction$Replace  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of PendingDelegateAction$Replace
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateAction$ReplaceLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    replacesDgt: AssetClass | string | [string | MintingPolicyHash | number[], string | number[]] | {mph: MintingPolicyHash | string | number[], tokenName: string | number[]}  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type PendingDelegateActionMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "PendingDelegateAction"}, {
        Add: singleEnumVariantMeta<PendingDelegateActionMeta, "Add",
            "Constr#0", 
            "fields", PendingDelegateAction$Add, "isSeededActivity"
        >,
        Remove: singleEnumVariantMeta<PendingDelegateActionMeta, "Remove",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        Replace: singleEnumVariantMeta<PendingDelegateActionMeta, "Replace",
            "Constr#2", 
            "fields", PendingDelegateAction$Replace, "isSeededActivity"
        >
    }
>;


/**
 * PendingDelegateAction enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the PendingDelegateAction enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingDelegateActionHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type PendingDelegateAction = 
        | { Add: PendingDelegateAction$Add /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$Replace /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoPendingDelegateAction = IntersectedEnum<
        | { Add: PendingDelegateAction$Ergo$Add /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$Ergo$Replace /*minEnumVariant*/ }
>

/**
 * PendingDelegateAction enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the PendingDelegateAction enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingDelegateActionHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type PendingDelegateActionLike = IntersectedEnum<
        | { Add: PendingDelegateAction$AddLike /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$ReplaceLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of PendingDelegateChange
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoPendingDelegateChange instead.
 * @public
 */
export interface PendingDelegateChange {
    action: /*minStructField*/ PendingDelegateAction
    role: /*minStructField*/ DelegateRole
    dgtLink: /*minStructField*/ RelativeDelegateLink | undefined
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateChange
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateChangeLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoPendingDelegateChange = {
    action: /*minStructField*/ ErgoPendingDelegateAction
    role: /*minStructField*/ ErgoDelegateRole
    dgtLink: /*minStructField*/ ErgoRelativeDelegateLink | undefined
}


/**
 * A strong type for the permissive form of PendingDelegateChange
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateChangeLike {
    action: /*minStructField*/ PendingDelegateActionLike
    role: /*minStructField*/ DelegateRoleLike
    dgtLink: /*minStructField*/ RelativeDelegateLinkLike | undefined
}



/**
 * A strong type for the canonical form of ManifestEntryType$DgDataPolicy
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestEntryType$Ergo$DgDataPolicy instead.
 * @public
 */
export interface ManifestEntryType$DgDataPolicy {
    policyLink: RelativeDelegateLink  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestEntryType$DgDataPolicy
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestEntryType$DgDataPolicyLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestEntryType$Ergo$DgDataPolicy = {
    policyLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of ManifestEntryType$DgDataPolicy
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestEntryType$DgDataPolicyLike {
    policyLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: IntLike  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestEntryType$DelegateThreads
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestEntryType$Ergo$DelegateThreads instead.
 * @public
 */
export interface ManifestEntryType$DelegateThreads {
    role: DelegateRole  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestEntryType$DelegateThreads
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestEntryType$DelegateThreadsLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestEntryType$Ergo$DelegateThreads = {
    role: ErgoDelegateRole  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of ManifestEntryType$DelegateThreads
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestEntryType$DelegateThreadsLike {
    role: DelegateRoleLike  /*minVariantField*/ ,
    refCount: IntLike  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type ManifestEntryTypeMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "ManifestEntryType"}, {
        NamedTokenRef: singleEnumVariantMeta<ManifestEntryTypeMeta, "NamedTokenRef",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        DgDataPolicy: singleEnumVariantMeta<ManifestEntryTypeMeta, "DgDataPolicy",
            "Constr#1", 
            "fields", ManifestEntryType$DgDataPolicy, "noSpecialFlags"
        >,
        DelegateThreads: singleEnumVariantMeta<ManifestEntryTypeMeta, "DelegateThreads",
            "Constr#2", 
            "fields", ManifestEntryType$DelegateThreads, "noSpecialFlags"
        >,
        MerkleMembership: singleEnumVariantMeta<ManifestEntryTypeMeta, "MerkleMembership",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        MerkleStateRoot: singleEnumVariantMeta<ManifestEntryTypeMeta, "MerkleStateRoot",
            "Constr#4", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * ManifestEntryType enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **5 variant(s)** of the ManifestEntryType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestEntryTypeHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type ManifestEntryType = 
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$DgDataPolicy /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$DelegateThreads /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoManifestEntryType = IntersectedEnum<
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$Ergo$DgDataPolicy /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$Ergo$DelegateThreads /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }
>

/**
 * ManifestEntryType enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **5 variant(s)** of the ManifestEntryType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestEntryTypeHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type ManifestEntryTypeLike = IntersectedEnum<
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$DgDataPolicyLike /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$DelegateThreadsLike /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoManifestEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoCapoManifestEntry instead.
 * @public
 */
export interface CapoManifestEntry {
    entryType: /*minStructField*/ ManifestEntryType
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | undefined
}


/**
 * An ergonomic, though less strictly-safe form of CapoManifestEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoManifestEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoCapoManifestEntry = {
    entryType: /*minStructField*/ ErgoManifestEntryType
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | undefined
}


/**
 * A strong type for the permissive form of CapoManifestEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoManifestEntryLike {
    entryType: /*minStructField*/ ManifestEntryTypeLike
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | string | number[] | undefined
}



/**
 * A strong type for the canonical form of PendingCharterChange$otherManifestChange
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingCharterChange$Ergo$otherManifestChange instead.
 * @public
 */
export interface PendingCharterChange$otherManifestChange {
    activity: ManifestActivity  /*minVariantField*/ ,
    remainingDelegateValidations: Array<DelegateRole>  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingCharterChange$otherManifestChange
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingCharterChange$otherManifestChangeLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingCharterChange$Ergo$otherManifestChange = {
    activity: ErgoManifestActivity  /*minVariantField*/ ,
    remainingDelegateValidations: Array<ErgoDelegateRole>  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of PendingCharterChange$otherManifestChange
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingCharterChange$otherManifestChangeLike {
    activity: ManifestActivityLike  /*minVariantField*/ ,
    remainingDelegateValidations: Array<DelegateRoleLike>  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type PendingCharterChangeMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "PendingCharterChange"}, {
        delegateChange: singleEnumVariantMeta<PendingCharterChangeMeta, "delegateChange",
            "Constr#0", "singletonField", /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChange   , "noSpecialFlags"
        >,
        otherManifestChange: singleEnumVariantMeta<PendingCharterChangeMeta, "otherManifestChange",
            "Constr#1", 
            "fields", PendingCharterChange$otherManifestChange, "noSpecialFlags"
        >
    }
>;


/**
 * PendingCharterChange enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **2 variant(s)** of the PendingCharterChange enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingCharterChangeHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type PendingCharterChange = 
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChange    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$otherManifestChange /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoPendingCharterChange = IntersectedEnum<
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			ErgoPendingDelegateChange    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$Ergo$otherManifestChange /*minEnumVariant*/ }
>

/**
 * PendingCharterChange enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **2 variant(s)** of the PendingCharterChange enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingCharterChangeHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type PendingCharterChangeLike = IntersectedEnum<
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChangeLike    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$otherManifestChangeLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoDatum$CharterData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoDatum$Ergo$CharterData instead.
 * @public
 */
export interface CapoDatum$CharterData {
    spendDelegateLink: RelativeDelegateLink  /*minVariantField*/ ,
    spendInvariants: Array<RelativeDelegateLink>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, RelativeDelegateLink>  /*minVariantField*/ ,
    mintDelegateLink: RelativeDelegateLink  /*minVariantField*/ ,
    mintInvariants: Array<RelativeDelegateLink>  /*minVariantField*/ ,
    govAuthorityLink: RelativeDelegateLink  /*minVariantField*/ ,
    manifest: Map<string, CapoManifestEntry>  /*minVariantField*/ ,
    pendingChanges: Array<PendingCharterChange>  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoDatum$CharterData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoDatum$CharterDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoDatum$Ergo$CharterData = {
    spendDelegateLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    spendInvariants: Array<ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    mintDelegateLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    mintInvariants: Array<ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    govAuthorityLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    manifest: Map<string, ErgoCapoManifestEntry>  /*minVariantField*/ ,
    pendingChanges: Array<ErgoPendingCharterChange>  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of CapoDatum$CharterData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoDatum$CharterDataLike {
    spendDelegateLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    spendInvariants: Array<RelativeDelegateLinkLike>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, RelativeDelegateLinkLike>  /*minVariantField*/ ,
    mintDelegateLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    mintInvariants: Array<RelativeDelegateLinkLike>  /*minVariantField*/ ,
    govAuthorityLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    manifest: Map<string, CapoManifestEntryLike>  /*minVariantField*/ ,
    pendingChanges: Array<PendingCharterChangeLike>  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of cctx_CharterInputType$RefInput
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see cctx_CharterInputType$Ergo$RefInput instead.
 * @public
 */
export interface cctx_CharterInputType$RefInput {
    datum: CapoDatum$CharterData  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of cctx_CharterInputType$RefInput
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the cctx_CharterInputType$RefInputLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type cctx_CharterInputType$Ergo$RefInput = {
    datum: CapoDatum$Ergo$CharterData  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of cctx_CharterInputType$RefInput
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface cctx_CharterInputType$RefInputLike {
    datum: CapoDatum$CharterDataLike  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of cctx_CharterInputType$Input
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see cctx_CharterInputType$Ergo$Input instead.
 * @public
 */
export interface cctx_CharterInputType$Input {
    datum: CapoDatum$CharterData  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of cctx_CharterInputType$Input
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the cctx_CharterInputType$InputLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type cctx_CharterInputType$Ergo$Input = {
    datum: CapoDatum$Ergo$CharterData  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of cctx_CharterInputType$Input
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface cctx_CharterInputType$InputLike {
    datum: CapoDatum$CharterDataLike  /*minVariantField*/ ,
    utxo: TxInput  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type cctx_CharterInputTypeMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "cctx_CharterInputType"}, {
        Unk: singleEnumVariantMeta<cctx_CharterInputTypeMeta, "Unk",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        RefInput: singleEnumVariantMeta<cctx_CharterInputTypeMeta, "RefInput",
            "Constr#1", 
            "fields", cctx_CharterInputType$RefInput, "noSpecialFlags"
        >,
        Input: singleEnumVariantMeta<cctx_CharterInputTypeMeta, "Input",
            "Constr#2", 
            "fields", cctx_CharterInputType$Input, "noSpecialFlags"
        >
    }
>;


/**
 * cctx_CharterInputType enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the cctx_CharterInputType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `cctx_CharterInputTypeHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type cctx_CharterInputType = 
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { RefInput: cctx_CharterInputType$RefInput /*minEnumVariant*/ }
        | { Input: cctx_CharterInputType$Input /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type Ergocctx_CharterInputType = IntersectedEnum<
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { RefInput: cctx_CharterInputType$Ergo$RefInput /*minEnumVariant*/ }
        | { Input: cctx_CharterInputType$Ergo$Input /*minEnumVariant*/ }
>

/**
 * cctx_CharterInputType enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the cctx_CharterInputType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `cctx_CharterInputTypeHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type cctx_CharterInputTypeLike = IntersectedEnum<
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { RefInput: cctx_CharterInputType$RefInputLike /*minEnumVariant*/ }
        | { Input: cctx_CharterInputType$InputLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoCtx
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoCapoCtx instead.
 * @public
 */
export interface CapoCtx {
    mph: /*minStructField*/ MintingPolicyHash
    charter: /*minStructField*/ cctx_CharterInputType
}


/**
 * An ergonomic, though less strictly-safe form of CapoCtx
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoCtxLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoCapoCtx = {
    mph: /*minStructField*/ MintingPolicyHash
    charter: /*minStructField*/ Ergocctx_CharterInputType
}


/**
 * A strong type for the permissive form of CapoCtx
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoCtxLike {
    mph: /*minStructField*/ MintingPolicyHash | string | number[]
    charter: /*minStructField*/ cctx_CharterInputTypeLike
}



/**
 * A strong type for the canonical form of dgd_DataSrc$Both
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see dgd_DataSrc$Ergo$Both instead.
 * @public
 */
export interface dgd_DataSrc$Both {
    utxo: TxInput  /*minVariantField*/ ,
    txo: TxOutput  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of dgd_DataSrc$Both
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the dgd_DataSrc$BothLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type dgd_DataSrc$Ergo$Both = dgd_DataSrc$Both  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of dgd_DataSrc$Both
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface dgd_DataSrc$BothLike {
    utxo: TxInput  /*minVariantField*/ ,
    txo: TxOutput  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type dgd_DataSrcMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "dgd_DataSrc"}, {
        Unk: singleEnumVariantMeta<dgd_DataSrcMeta, "Unk",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        Input: singleEnumVariantMeta<dgd_DataSrcMeta, "Input",
            "Constr#1", "singletonField", /* implied wrapper { utxo: ... } for singleVariantField */ 
			TxInput   , "noSpecialFlags"
        >,
        Output: singleEnumVariantMeta<dgd_DataSrcMeta, "Output",
            "Constr#2", "singletonField", /* implied wrapper { txo: ... } for singleVariantField */ 
			TxOutput   , "noSpecialFlags"
        >,
        Both: singleEnumVariantMeta<dgd_DataSrcMeta, "Both",
            "Constr#3", 
            "fields", dgd_DataSrc$Both, "noSpecialFlags"
        >
    }
>;


/**
 * dgd_DataSrc enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **4 variant(s)** of the dgd_DataSrc enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `dgd_DataSrcHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type dgd_DataSrc = 
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { Input: /* implied wrapper { utxo: ... } for singleVariantField */ 
			TxInput    /*minEnumVariant*/ }
        | { Output: /* implied wrapper { txo: ... } for singleVariantField */ 
			TxOutput    /*minEnumVariant*/ }
        | { Both: dgd_DataSrc$Both /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type Ergodgd_DataSrc = IntersectedEnum<
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { Input: /* implied wrapper { utxo: ... } for singleVariantField */ 
			TxInput    /*minEnumVariant*/ }
        | { Output: /* implied wrapper { txo: ... } for singleVariantField */ 
			TxOutput    /*minEnumVariant*/ }
        | { Both: dgd_DataSrc$Ergo$Both /*minEnumVariant*/ }
>

/**
 * dgd_DataSrc enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **4 variant(s)** of the dgd_DataSrc enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `dgd_DataSrcHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type dgd_DataSrcLike = IntersectedEnum<
        | { Unk: tagOnly /*minEnumVariant*/ }
        | { Input: /* implied wrapper { utxo: ... } for singleVariantField */ 
			TxInput    /*minEnumVariant*/ }
        | { Output: /* implied wrapper { txo: ... } for singleVariantField */ 
			TxOutput    /*minEnumVariant*/ }
        | { Both: dgd_DataSrc$BothLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of AbstractDelegateActivitiesEnum$CreatingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see AbstractDelegateActivitiesEnum$Ergo$CreatingDelegatedData instead.
 * @public
 */
export interface AbstractDelegateActivitiesEnum$CreatingDelegatedData {
    seed: TxOutputId  /*minVariantField*/ ,
    dataType: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of AbstractDelegateActivitiesEnum$CreatingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the AbstractDelegateActivitiesEnum$CreatingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type AbstractDelegateActivitiesEnum$Ergo$CreatingDelegatedData = AbstractDelegateActivitiesEnum$CreatingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of AbstractDelegateActivitiesEnum$CreatingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface AbstractDelegateActivitiesEnum$CreatingDelegatedDataLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    dataType: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of AbstractDelegateActivitiesEnum$UpdatingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see AbstractDelegateActivitiesEnum$Ergo$UpdatingDelegatedData instead.
 * @public
 */
export interface AbstractDelegateActivitiesEnum$UpdatingDelegatedData {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of AbstractDelegateActivitiesEnum$UpdatingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the AbstractDelegateActivitiesEnum$UpdatingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type AbstractDelegateActivitiesEnum$Ergo$UpdatingDelegatedData = AbstractDelegateActivitiesEnum$UpdatingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of AbstractDelegateActivitiesEnum$UpdatingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface AbstractDelegateActivitiesEnum$UpdatingDelegatedDataLike {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of AbstractDelegateActivitiesEnum$DeletingDelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see AbstractDelegateActivitiesEnum$Ergo$DeletingDelegatedData instead.
 * @public
 */
export interface AbstractDelegateActivitiesEnum$DeletingDelegatedData {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of AbstractDelegateActivitiesEnum$DeletingDelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the AbstractDelegateActivitiesEnum$DeletingDelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type AbstractDelegateActivitiesEnum$Ergo$DeletingDelegatedData = AbstractDelegateActivitiesEnum$DeletingDelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of AbstractDelegateActivitiesEnum$DeletingDelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface AbstractDelegateActivitiesEnum$DeletingDelegatedDataLike {
    dataType: string  /*minVariantField*/ ,
    recId: number[]  /*minVariantField*/ 
}




            /**
            * @internal
            */
            export type AbstractDelegateActivitiesEnumMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "AbstractDelegateActivitiesEnum"}, {
        CapoLifecycleActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "CapoLifecycleActivities",
            "Constr#0", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity   , "noSpecialFlags"
        >,
        DelegateLifecycleActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "DelegateLifecycleActivities",
            "Constr#1", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivity   , "noSpecialFlags"
        >,
        SpendingActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "SpendingActivities",
            "Constr#2", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData   , "noSpecialFlags"
        >,
        MintingActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "MintingActivities",
            "Constr#3", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData   , "noSpecialFlags"
        >,
        BurningActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "BurningActivities",
            "Constr#4", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData   , "noSpecialFlags"
        >,
        CreatingDelegatedData: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "CreatingDelegatedData",
            "Constr#5", 
            "fields", AbstractDelegateActivitiesEnum$CreatingDelegatedData, "isSeededActivity"
        >,
        UpdatingDelegatedData: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "UpdatingDelegatedData",
            "Constr#6", 
            "fields", AbstractDelegateActivitiesEnum$UpdatingDelegatedData, "noSpecialFlags"
        >,
        DeletingDelegatedData: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "DeletingDelegatedData",
            "Constr#7", 
            "fields", AbstractDelegateActivitiesEnum$DeletingDelegatedData, "noSpecialFlags"
        >,
        MultipleDelegateActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "MultipleDelegateActivities",
            "Constr#8", "singletonField", /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>   , "noSpecialFlags"
        >,
        OtherActivities: singleEnumVariantMeta<AbstractDelegateActivitiesEnumMeta, "OtherActivities",
            "Constr#9", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData   , "noSpecialFlags"
        >
    }
>;


/**
 * AbstractDelegateActivitiesEnum enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **10 variant(s)** of the AbstractDelegateActivitiesEnum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `AbstractDelegateActivitiesEnumHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type AbstractDelegateActivitiesEnum = 
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivity    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { CreatingDelegatedData: AbstractDelegateActivitiesEnum$CreatingDelegatedData /*minEnumVariant*/ }
        | { UpdatingDelegatedData: AbstractDelegateActivitiesEnum$UpdatingDelegatedData /*minEnumVariant*/ }
        | { DeletingDelegatedData: AbstractDelegateActivitiesEnum$DeletingDelegatedData /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoAbstractDelegateActivitiesEnum = IntersectedEnum<
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoCapoLifecycleActivity    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoDelegateLifecycleActivity    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { CreatingDelegatedData: AbstractDelegateActivitiesEnum$Ergo$CreatingDelegatedData /*minEnumVariant*/ }
        | { UpdatingDelegatedData: AbstractDelegateActivitiesEnum$Ergo$UpdatingDelegatedData /*minEnumVariant*/ }
        | { DeletingDelegatedData: AbstractDelegateActivitiesEnum$Ergo$DeletingDelegatedData /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
>

/**
 * AbstractDelegateActivitiesEnum enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **10 variant(s)** of the AbstractDelegateActivitiesEnum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `AbstractDelegateActivitiesEnumHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type AbstractDelegateActivitiesEnumLike = IntersectedEnum<
        | { CapoLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivityLike    /*minEnumVariant*/ }
        | { DelegateLifecycleActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			DelegateLifecycleActivityLike    /*minEnumVariant*/ }
        | { SpendingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { MintingActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { BurningActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
        | { CreatingDelegatedData: AbstractDelegateActivitiesEnum$CreatingDelegatedDataLike /*minEnumVariant*/ }
        | { UpdatingDelegatedData: AbstractDelegateActivitiesEnum$UpdatingDelegatedDataLike /*minEnumVariant*/ }
        | { DeletingDelegatedData: AbstractDelegateActivitiesEnum$DeletingDelegatedDataLike /*minEnumVariant*/ }
        | { MultipleDelegateActivities: /* implied wrapper { activities: ... } for singleVariantField */ 
			Array<UplcData>    /*minEnumVariant*/ }
        | { OtherActivities: /* implied wrapper { activity: ... } for singleVariantField */ 
			UplcData    /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of DgDataDetails
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoDgDataDetails instead.
 * @public
 */
export interface DgDataDetails {
    dataSrc: /*minStructField*/ dgd_DataSrc
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    mph: /*minStructField*/ MintingPolicyHash
    activity: /*minStructField*/ AbstractDelegateActivitiesEnum | undefined
}


/**
 * An ergonomic, though less strictly-safe form of DgDataDetails
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DgDataDetailsLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoDgDataDetails = {
    dataSrc: /*minStructField*/ Ergodgd_DataSrc
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    mph: /*minStructField*/ MintingPolicyHash
    activity: /*minStructField*/ ErgoAbstractDelegateActivitiesEnum | undefined
}


/**
 * A strong type for the permissive form of DgDataDetails
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DgDataDetailsLike {
    dataSrc: /*minStructField*/ dgd_DataSrcLike
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
    mph: /*minStructField*/ MintingPolicyHash | string | number[]
    activity: /*minStructField*/ AbstractDelegateActivitiesEnumLike | undefined
}


/**
 * expresses the essential fields needed for initiating creation of a DgDataDetails
 * @public
 */
export type minimalDgDataDetails = minimalData<DgDataDetailsLike>

/**
 * A strong type for the canonical form of DTS_PurchaseInfo
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoDTS_PurchaseInfo instead.
 * @public
 */
export interface DTS_PurchaseInfo {
    inferredPace: /*minStructField*/ number
    hoursSinceLastPurchase: /*minStructField*/ number
    unitsPurchased: /*minStructField*/ bigint
    purchaseTime: /*minStructField*/ number
    prevSalePace: /*minStructField*/ number
    totalProgress: /*minStructField*/ SaleProgressDetailsV1
}


/**
 * An ergonomic, though less strictly-safe form of DTS_PurchaseInfo
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DTS_PurchaseInfoLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoDTS_PurchaseInfo = {
    inferredPace: /*minStructField*/ number
    hoursSinceLastPurchase: /*minStructField*/ number
    unitsPurchased: /*minStructField*/ bigint
    purchaseTime: /*minStructField*/ number
    prevSalePace: /*minStructField*/ number
    totalProgress: /*minStructField*/ ErgoSaleProgressDetailsV1
}


/**
 * A strong type for the permissive form of DTS_PurchaseInfo
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DTS_PurchaseInfoLike {
    inferredPace: /*minStructField*/ number
    hoursSinceLastPurchase: /*minStructField*/ number
    unitsPurchased: /*minStructField*/ IntLike
    purchaseTime: /*minStructField*/ TimeLike
    prevSalePace: /*minStructField*/ number
    totalProgress: /*minStructField*/ SaleProgressDetailsV1Like
}



/**
 * A strong type for the canonical form of DynamicSaleV1
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoDynamicSaleV1 instead.
 * @public
 */
export interface DynamicSaleV1 {
    settings: /*minStructField*/ DynamicSaleV1Settings
    purchase: /*minStructField*/ DTS_PurchaseInfo
    sale: /*minStructField*/ MarketSaleData
    updatedSale: /*minStructField*/ MarketSaleData | undefined
}


/**
 * An ergonomic, though less strictly-safe form of DynamicSaleV1
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the DynamicSaleV1Like type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoDynamicSaleV1 = {
    settings: /*minStructField*/ ErgoDynamicSaleV1Settings
    purchase: /*minStructField*/ ErgoDTS_PurchaseInfo
    sale: /*minStructField*/ ErgoMarketSaleData
    updatedSale: /*minStructField*/ ErgoMarketSaleData | undefined
}


/**
 * A strong type for the permissive form of DynamicSaleV1
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface DynamicSaleV1Like {
    settings: /*minStructField*/ DynamicSaleV1SettingsLike
    purchase: /*minStructField*/ DTS_PurchaseInfoLike
    sale: /*minStructField*/ MarketSaleDataLike
    updatedSale: /*minStructField*/ MarketSaleDataLike | undefined
}



