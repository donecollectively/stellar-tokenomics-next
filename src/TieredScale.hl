module TieredScale
import {
    AnyData
} from CapoHelpers

struct Tier {
    type: String
    threshold: Int
    scaledValue: Real
    /**
     * actually Map[String]Data
     * interpreted by as a concrete mStruct type by a caller, in its specific context
     */
    moreInfo: Data    
}

struct TierLookupResult {
    scaledValue: Real
    moreInfo: Option[
        Data
        // actually Map[String]Data
    ]
}

struct TieredScale {
    tiers: []Tier

    func findTierValue(self, value: Int) -> TierLookupResult {
        // list.fold_lazy[ReducedType: Any](
        //     reducer: (item: ItemType, next: () -> ReducedType) -> ReducedType,
        //     final: ReducedType
        // ) -> ReducedType
        print("  -- tiered scale: lookup value "+value.show());
        self.tiers.fold_lazy[TierLookupResult](
           // reducer: 
            (thisTier: Tier, next : () -> TierLookupResult) -> TierLookupResult {
                higherTierResult : TierLookupResult = next(); // go deep first, to the latest possible item in the list
                success : TierLookupResult = if (higherTierResult.scaledValue == 0.0) {
                    // this is potentially a match, if the threshold is met by the item
                    // print("     -- checking tier "+ thisTier.threshold.show());
                    if ( value >= thisTier.threshold) {
                        result = thisTier.scaledValue.show();
                        print("    <--  returning scaled value " + result);
                        TierLookupResult {
                            thisTier.scaledValue,
                            Option[Data]::Some{thisTier.moreInfo}
                        }
                    } else {
                        // print("      ------ threshold unmet: " + thisTier.threshold.show());

                        // this larger tier is too big to match the input value,
                        // so we return this "no match" indicator, thus
                        // ... defering to the next smaller tier at a lesser depth 
                        // ... in the list (and in the recursion sequence)
                        TierLookupResult {
                            0.0,
                            Option[Data]::None
                        }
                    }                    
                } else { 
                    // pops back through all the earlier items, returning 
                    //   that last tier having any successful lookup result
                    higherTierResult 
                 };

                 success
            },
            // the "final" item for the fold is a no-match indicator
            TierLookupResult {
                0.0,
                Option[Data]::None
            }
        )
    }
    
}


struct TierAsInt {
    type: String
    threshold: Int
    scaledValue: Int
    moreInfo: Data // actually Map[String]Data
}

struct TieredScaleAsInt {
    tiers: []TierAsInt
}
